! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine p4est_base_triangulation_process_parameters ( this, parameters ) 
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  type(parameterlist_t)            , intent(in)    :: parameters
 
  integer(ip),      allocatable :: array_size(:)
  real(rp),         allocatable :: bounding_box_limits(:)
  character(len=:), allocatable :: error_message
  integer(ip)                   :: num_dims, idime, istat
  
  call triangulation_process_parameters(this, parameters)
  
  ! Get num_dims from FPL
  assert(parameters%isPresent(p4est_triang_num_dims_key))
  assert(parameters%isAssignable(p4est_triang_num_dims_key, num_dims ))
  istat = parameters%get(key = p4est_triang_num_dims_key, value = num_dims); assert(istat==0)
  call this%set_num_dims(num_dims)
  
  if( parameters%isPresent(key = p4est_triang_domain_limits_key) ) then
    istat = parameters%GetShape(key = p4est_triang_domain_limits_key, shape = array_size); check(istat==0)
    call memalloc(array_size(1), bounding_box_limits,__FILE__,__LINE__)
    assert(parameters%isAssignable(p4est_triang_domain_limits_key, bounding_box_limits))
    istat = parameters%get(key = p4est_triang_domain_limits_key , value = bounding_box_limits); check(istat==0)

    error_message = p4est_triang_domain_limits_key //  & 
                    ' array dimension (' // ch(size(bounding_box_limits, dim=1)) // ') ' //  & 
                    ' must be equal to two times the number of dimensions' // &
                    ' (' // ch(2*this%get_num_dims()) // ') ' 
    massert ( size(bounding_box_limits, dim=1) == 2*this%get_num_dims(), error_message )

    do idime = 1,this%get_num_dims()
      error_message = p4est_triang_domain_limits_key //  & 
                      ' value (' // ch(bounding_box_limits(2*idime)) // ') ' // &
                      ' at index (' // ch(2*idime) // ') ' // & 
                      ' must be bigger than value (' // ch(bounding_box_limits(2*idime-1)) // ') ' // &
                      ' at index (' // ch(2*idime-1) // ') '
      massert(bounding_box_limits(2*idime)>bounding_box_limits(2*idime-1), error_message)

      this%bounding_box_limits(idime,1) = bounding_box_limits(2*idime-1)
      this%bounding_box_limits(idime,2) = bounding_box_limits(2*idime)
    end do
    call memfree(bounding_box_limits,__FILE__,__LINE__)
  else
    this%bounding_box_limits(:,1) = 0.0_rp
    this%bounding_box_limits(:,2) = 1.0_rp
  end if
  
  if( parameters%isPresent(key = p4est_triang_log_level_key) ) then
    assert(parameters%isAssignable(p4est_triang_log_level_key, this%p4est_log_level))
    istat = parameters%get(key = p4est_triang_log_level_key, value = this%p4est_log_level); check(istat==0)
  else
    this%p4est_log_level = default_p4est_triang_log_level
  end if
  
  if( parameters%isPresent(key = p4est_triang_2_1_k_balance_key ) ) then
    assert(parameters%isAssignable(p4est_triang_2_1_k_balance_key, this%k_2_1_balance))
    istat = parameters%get(key = p4est_triang_2_1_k_balance_key, value = this%k_2_1_balance); check(istat==0)
  else
    this%k_2_1_balance = default_p4est_triang_2_1_k_balance
  end if

  if( parameters%isPresent(key = p4est_triang_k_ghost_cells_key ) ) then
    assert(parameters%isAssignable(p4est_triang_k_ghost_cells_key, this%k_ghost_cells))
    istat = parameters%get(key = p4est_triang_k_ghost_cells_key, value = this%k_ghost_cells); check(istat==0)
  else
    this%k_ghost_cells = default_p4est_triang_k_ghost_cells
  end if
  
end subroutine p4est_base_triangulation_process_parameters


function p4est_base_triangulation_is_conforming( this ) 
 implicit none
 class(p4est_base_triangulation_t), intent(in) :: this
 logical :: p4est_base_triangulation_is_conforming
 p4est_base_triangulation_is_conforming = .false.
end function p4est_base_triangulation_is_conforming

function p4est_base_triangulation_get_num_reference_fes(this) 
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip) :: p4est_base_triangulation_get_num_reference_fes
  p4est_base_triangulation_get_num_reference_fes = 1
end function p4est_base_triangulation_get_num_reference_fes

function p4est_base_triangulation_get_reference_fe(this, ref_fe_geo_id) 
  implicit none
  class(p4est_base_triangulation_t), target, intent(in) :: this
  integer(ip)                              , intent(in) :: ref_fe_geo_id
  class(reference_fe_t), pointer :: p4est_base_triangulation_get_reference_fe
  assert ( ref_fe_geo_id == 1 )
  p4est_base_triangulation_get_reference_fe =>  this%reference_fe_geo
end function p4est_base_triangulation_get_reference_fe

function p4est_base_triangulation_get_max_num_shape_functions(this) result (num)
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip) :: num
  type(p4est_cell_iterator_t) :: cell
  call cell%create(this)
  num = cell%get_num_nodes()
  call cell%free()
end function p4est_base_triangulation_get_max_num_shape_functions

function p4est_base_triangulation_get_num_proper_vefs(this)
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip) :: p4est_base_triangulation_get_num_proper_vefs
  p4est_base_triangulation_get_num_proper_vefs = this%num_proper_vefs
end function p4est_base_triangulation_get_num_proper_vefs

function p4est_base_triangulation_get_num_improper_vefs(this)
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip) :: p4est_base_triangulation_get_num_improper_vefs
  p4est_base_triangulation_get_num_improper_vefs = this%num_improper_vefs
end function p4est_base_triangulation_get_num_improper_vefs

function p4est_bt_get_refinement_and_coarsening_flags(this)
  implicit none
  class(p4est_base_triangulation_t), target, intent(in) :: this
  type(std_vector_integer_ip_t), pointer :: p4est_bt_get_refinement_and_coarsening_flags
  p4est_bt_get_refinement_and_coarsening_flags => this%refinement_and_coarsening_flags
end function p4est_bt_get_refinement_and_coarsening_flags

subroutine p4est_base_triangulation_refine_and_coarsen(this)
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  type(c_ptr) :: p4est_old
  
  type(std_vector_integer_ip_t) :: old_lst_vefs_gids
  type(std_vector_integer_ip_t) :: cell_wise_vef_set_ids
  integer(ip), pointer :: user_pointer(:)
  class(environment_t), pointer :: p_environment

#ifdef ENABLE_P4EST
  
  p_environment => this%get_environment()
  if ( p_environment%am_i_l1_task () ) then
    ! If the user did not flag any cell between the last call to refine_and_coarsen
    ! and the current call to refine and coarsen, then we have to explicitly clear
    ! the refinement and coarsening flags array
    if ( this%clear_refinement_and_coarsening_flags_pending ) then
       call this%clear_refinement_and_coarsening_flags()
    end if
    if ( this%get_num_dims() == 2 ) then
      user_pointer => this%refinement_and_coarsening_flags%get_pointer()
      if ( associated(user_pointer) ) then
        call F90_p4est_set_user_pointer(c_loc(user_pointer),this%p4est)
      else 
        call F90_p4est_set_user_pointer(C_NULL_PTR,this%p4est)
      end if 
      p4est_old = c_null_ptr; call F90_p4est_copy(this%p4est,p4est_old)
      call F90_p4est_refine(this%p4est)
      call F90_p4est_coarsen(this%p4est)
      call F90_p4est_balance(this%k_2_1_balance,this%p4est)
      call F90_p4est_update_refinement_and_coarsening_flags(p4est_old,this%p4est)
      call F90_p4est_destroy(p4est_old)
    else if ( this%get_num_dims() == 3 ) then
      user_pointer => this%refinement_and_coarsening_flags%get_pointer()
      if ( associated(user_pointer) ) then
        call F90_p8est_set_user_pointer(c_loc(user_pointer),this%p4est)
      else
        call F90_p8est_set_user_pointer(C_NULL_PTR,this%p4est)
      end if
      p4est_old = c_null_ptr; call F90_p8est_copy(this%p4est,p4est_old)
      call F90_p8est_refine(this%p4est)
      call F90_p8est_coarsen(this%p4est)
      call F90_p8est_balance(this%k_2_1_balance,this%p4est)
      call F90_p8est_update_refinement_and_coarsening_flags(p4est_old,this%p4est)
      call F90_p8est_destroy(p4est_old)
    end if
    call this%update_p4est_mesh()
    call this%update_topology_from_p4est_mesh()
    call this%update_cell_import()
    call this%update_cell_ggids()
    call this%update_cell_myparts()
    call this%extend_p4est_topology_arrays_to_ghost_cells()
    call this%find_missing_corner_neighbours()
    call this%update_lst_vefs_gids_and_cells_around(old_lst_vefs_gids)
    call this%fill_x_cell_vertex_coordinates()
    call this%set_up_lst_itfc_vefs() 

    ! Update procedures 
    call this%update_cell_weights()
    call this%update_vef_set_ids(old_lst_vefs_gids)
    call old_lst_vefs_gids%free()
    call this%update_cell_set_ids()
    call this%extract_local_cell_wise_vef_set_ids(cell_wise_vef_set_ids)
    
    ! Comm procedures
    call this%comm_cell_set_ids()
    call this%comm_cell_wise_vef_set_ids(cell_wise_vef_set_ids)
    call this%fill_ghost_cells_from_cell_wise_vef_set_ids(cell_wise_vef_set_ids)
    call cell_wise_vef_set_ids%free()
   end if 
   ! Re-set up coarse_triangulation()
   if ( this%coarse_triangulation_is_set_up() ) then
     call this%setup_coarse_triangulation()
   end if  
   
   ! set up clear_refinement_and_coarsening_flags_pending
   this%clear_refinement_and_coarsening_flags_pending = .true.
   
#else
  call this%not_enabled_error()
#endif  
end subroutine p4est_base_triangulation_refine_and_coarsen

function p4est_base_triangulation_get_ptr_vefs_x_cell(this, icell)
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip), intent(in) :: icell

  integer(ip) :: p4est_base_triangulation_get_ptr_vefs_x_cell
  integer(ip) :: num_vefs_x_cell

  !assert (icell>= 1 .and. icell <= this%get_num_cells()+1)
  if ( this%get_num_dims() == 2 ) then
    num_vefs_x_cell = NUM_VEFS_2D
  else if ( this%get_num_dims() == 3 ) then
    num_vefs_x_cell = NUM_VEFS_3D
  end if
  p4est_base_triangulation_get_ptr_vefs_x_cell = (icell-1)*num_vefs_x_cell+1  
  
end function p4est_base_triangulation_get_ptr_vefs_x_cell

subroutine p4est_bt_update_lst_vefs_gids_and_cells_around(this, old_lst_vefs_gids)
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  type(std_vector_integer_ip_t)      , intent(inout) :: old_lst_vefs_gids
  integer(ip) :: num_corners_x_cell, num_edges_x_cell, num_faces_x_cell
  integer(ip) :: num_edge_corners, num_face_corners, num_faces_at_corner, num_subfacets_facet, num_subedgets_edget
  integer(ip) :: icell, icell_iface, icell_jface, icell_icorner, icell_iedge
  integer(ip) :: jcell, jcell_iface, jcell_icorner, jcell_iedge
  integer(ip) :: min_cell, min_cell_int_edge, min_icorner, min_iedge, min_iface, icorner, iedge, iface
  integer(ip) :: iface_at_corner, iedge_at_corner, iface_at_edge
  integer(ip) :: edge_corner, face_corner, edge_face, flip, mortar
  integer(P4EST_F90_QLEVEL) :: jcell_iconn 
  logical :: is_proper, vef_at_boundary, vef_at_interface, vef_is_ghost
  logical :: double_or_half_size_neighbour_local
  logical :: double_or_half_size_neighbour_ghost
  integer(ip) :: isubface, isubedge
  integer(ip) :: base_pos_icell, base_pos_min_cell, base_pos_ghost_cell

#if ENABLE_SINGLE_OCTREE_OPTS
  integer(ip) :: work_vector_cells_around(MAX_NUM_CELLS_AROUND_3D)
  integer(ip) :: work_vector_improper_cells_around(MAX_NUM_CELLS_AROUND_3D)
  integer(ip) :: work_vector_ivef(MAX_NUM_CELLS_AROUND_3D)
  integer(ip) :: work_vector_subvef(MAX_NUM_CELLS_AROUND_3D)
  integer(ip) :: current_cell_around
  integer(ip) :: current_improper_cell_around
#else
  type(std_vector_integer_ip_t) :: work_vector_cells_around
  type(std_vector_integer_ip_t) :: work_vector_improper_cells_around
  type(std_vector_integer_ip_t) :: work_vector_ivef
  type(std_vector_integer_ip_t) :: work_vector_subvef
#endif


  integer(ip) :: improper_cell_around_ivef
  integer(ip) :: improper_cell_around_subvef
  integer(ip) :: i
  integer(ip), pointer :: P4EST_2_FEMPAR_CORNER(:)
  integer(ip), pointer :: P4EST_FACES_AT_CORNER(:,:)
  integer(ip), pointer :: P4EST_FACE_CORNERS(:,:)
  integer(ip), pointer :: P4EST_OPPOSITE_CORNER(:)
  integer(ip), pointer :: P4EST_2_FEMPAR_FACE(:)
  integer(ip), pointer :: P4EST_CORNER_IN_FACE(:,:)
  integer(ip), pointer :: FEMPAR_SUBCELLS_IN_TOUCH_FACE(:,:)
  integer :: child_id
  integer(ip) :: vef_gid
  integer(ip) :: num_local_cells, num_cells

#ifdef ENABLE_P4EST  
  if ( this%get_num_dims() == 2 ) then
     num_corners_x_cell    =  NUM_CORNERS_2D
     num_edges_x_cell      =  0
     num_faces_x_cell      =  NUM_FACES_2D
     num_face_corners      =  NUM_FACE_CORNERS_2D
     num_faces_at_corner   =  NUM_FACES_AT_CORNER_2D
     num_subfacets_facet   =  NUM_SUBFACES_FACE_2D
     P4EST_2_FEMPAR_CORNER   => P4EST_2_FEMPAR_CORNER_2D
     P4EST_FACES_AT_CORNER   => P4EST_FACES_AT_CORNER_2D
     P4EST_FACE_CORNERS      => P4EST_FACE_CORNERS_2D
     P4EST_OPPOSITE_CORNER   => P4EST_OPPOSITE_CORNER_2D
     P4EST_2_FEMPAR_FACE     => P4EST_2_FEMPAR_FACE_2D
     P4EST_CORNER_IN_FACE    => P4EST_CORNER_IN_FACE_2D
     FEMPAR_SUBCELLS_IN_TOUCH_FACE => FEMPAR_SUBCELLS_IN_TOUCH_FACE_2D
  else if ( this%get_num_dims() == 3 ) then
     num_corners_x_cell      =  NUM_CORNERS_3D
     num_edges_x_cell        =  NUM_EDGES_3D
     num_faces_x_cell        =  NUM_FACES_3D
     num_face_corners        =  NUM_FACE_CORNERS_3D
     num_edge_corners        =  NUM_EDGE_CORNERS_3D
     num_faces_at_corner     =  NUM_FACES_AT_CORNER_3D
     num_subfacets_facet     =  NUM_SUBFACES_FACE_3D
     num_subedgets_edget     =  NUM_SUBEDGES_EDGE_3D
     P4EST_2_FEMPAR_CORNER   => P4EST_2_FEMPAR_CORNER_3D
     P4EST_FACES_AT_CORNER   => P4EST_FACES_AT_CORNER_3D
     P4EST_FACE_CORNERS      => P4EST_FACE_CORNERS_3D
     P4EST_OPPOSITE_CORNER   => P4EST_OPPOSITE_CORNER_3D
     P4EST_2_FEMPAR_FACE     => P4EST_2_FEMPAR_FACE_3D
     P4EST_CORNER_IN_FACE    => P4EST_CORNER_IN_FACE_3D
     FEMPAR_SUBCELLS_IN_TOUCH_FACE => FEMPAR_SUBCELLS_IN_TOUCH_FACE_3D
  end if

  call old_lst_vefs_gids%copy(this%lst_vefs_gids)

  ! Set to zero all global VEF GiDs. Those corresponding to ghost 
  ! VEFs will remain zero after the whole process is perfomed
  call this%lst_vefs_gids%resize(0)
  call this%lst_vefs_gids%resize(this%get_ptr_vefs_x_cell(this%get_num_cells()+1)-1,0)

  call this%ptr_cells_around_proper_vefs%resize(1)
  call this%lst_cells_around_proper_vefs%resize(0)
  call this%ptr_cells_around_improper_vefs%resize(1)
  call this%lst_cells_around_improper_vefs%resize(0)
  call this%ptr_improper_cells_around%resize(1)
  call this%lst_improper_cells_around%resize(0)
  call this%improper_vefs_improper_cell_around_ivef%resize(0)
  call this%improper_vefs_improper_cell_around_subvef%resize(0)
  call this%proper_vefs_dim%resize(0)
  call this%improper_vefs_dim%resize(0)
  call this%proper_vefs_at_boundary%resize(0)
  call this%proper_vefs_at_interface%resize(0)
  call this%improper_vefs_at_interface%resize(0)
  call this%proper_vefs_is_ghost%resize(0)
  call this%improper_vefs_is_ghost%resize(0)
  
  this%num_proper_vefs   = 0
  this%num_improper_vefs = 0
 
  num_cells = this%get_num_cells()
  num_local_cells = this%get_num_local_cells()
  do icell=1, num_cells 
    call generate_corners()
    call generate_edges()
    call generate_faces()
  end do
  call this%set_num_vefs(this%num_proper_vefs + this%num_improper_vefs)
  call this%ptr_cells_around_proper_vefs%transform_length_to_header()
  call this%ptr_cells_around_improper_vefs%transform_length_to_header()
  call this%ptr_improper_cells_around%transform_length_to_header()
#if ENABLE_SINGLE_OCTREE_OPTS
#else
  call work_vector_cells_around%free()
  call work_vector_improper_cells_around%free()
  call work_vector_ivef%free()
  call work_vector_subvef%free()
#endif
contains

   subroutine generate_corners()
     implicit none
     do icorner=1, num_corners_x_cell
        is_proper        = .true.
        min_cell         = icell
        min_icorner      = icorner 
        vef_at_boundary  = .false.
        if (icell > num_local_cells) then
          vef_at_interface = .true.
        else
          vef_at_interface = .false.
        end if 
        double_or_half_size_neighbour_local = .false.
        double_or_half_size_neighbour_ghost = .false.

#if ENABLE_SINGLE_OCTREE_OPTS
        work_vector_cells_around(1)=icell
        current_cell_around = 2
        current_improper_cell_around = 1
#else
        call work_vector_cells_around%resize(0)
        call work_vector_cells_around%push_back(icell)
        call work_vector_improper_cells_around%resize(0)
        call work_vector_ivef%resize(0)
        call work_vector_subvef%resize(0)
#endif

        ! Find face neighbours
        do iface_at_corner=1, num_faces_at_corner
           icell_iface = P4EST_FACES_AT_CORNER(iface_at_corner,icorner)
           jcell_iconn = this%quad_to_face(icell_iface,icell)

           if (this%quad_to_quad(icell_iface,icell)<0) cycle

           if (this%get_num_dims() == 2) then
              call p4est_eval_connectivity(jcell_iconn, jcell_iface, flip, mortar)
           elseif (this%get_num_dims() == 3) then
              call p8est_eval_connectivity(jcell_iconn, jcell_iface, flip, mortar)
           else
              check(.false.)
           end if
           assert (flip==1) ! All cells MUST be aligned with each other

           if (mortar == -1) then ! Conformal neighbour
              jcell      = this%quad_to_quad(icell_iface,icell)+1
              
              ! Check whether icell across current face is at the boundary
              if ( icell == jcell ) then
                 vef_at_boundary = .true.
                 cycle
              end if

              min_cell   = min(min_cell,jcell)
              if (min_cell == jcell) then
                 min_icorner=p4est_get_jcell_icorner(icell_iface,jcell_iface,icorner,P4EST_CORNER_IN_FACE,P4EST_FACE_CORNERS)
              end if
        
              if ( jcell > num_local_cells ) then 
                vef_at_interface = .true.
              end if                                           

#if ENABLE_SINGLE_OCTREE_OPTS
              work_vector_cells_around(current_cell_around) = jcell
              current_cell_around = current_cell_around + 1 
#else
              call work_vector_cells_around%push_back(jcell)
#endif
           else if ( mortar >= 1 .and. mortar <= num_subfacets_facet )  then ! Double-size neighbour 
              jcell      = this%quad_to_quad(icell_iface,icell)+1

              if ( jcell >=1 .and. jcell <= num_local_cells ) then
                 double_or_half_size_neighbour_local = .true.
              else if (jcell >= (num_local_cells+1) .and. jcell <= num_cells ) then
                 double_or_half_size_neighbour_ghost = .true.
              end if

              ! Determine whether this corner is improper
              ! 1. Go to coarser neighbour and find across which subface am I neighbour
              if (this%get_num_dims() == 2) then
                child_id = F90_p4est_quadrant_child_id(this%quad_coords(1,icell), &
                                                       this%quad_coords(2,icell), &
                                                       this%quad_level(icell)) + 1
              else
                child_id = F90_p8est_quadrant_child_id(this%quad_coords(1,icell), &
                                                       this%quad_coords(2,icell), &
                                                       this%quad_coords(3,icell), &
                                                       this%quad_level(icell)) + 1
              end if
                            
              do isubface = 1, num_subfacets_facet
                 if (FEMPAR_SUBCELLS_IN_TOUCH_FACE(isubface,P4EST_2_FEMPAR_FACE(icell_iface)) == child_id) then
                    exit
                 end if
              end do
              assert(isubface<=num_subfacets_facet)

              ! 2. Determine which face_corner of my face am I
              do face_corner=1, num_face_corners
                 if (P4EST_FACE_CORNERS(face_corner,icell_iface) == icorner) then
                    exit
                 end if
              end do
              assert(face_corner<=num_face_corners)

              ! 3. I am improper if am either corner 1 of subface 0 or corner 0 of subface 1
              if ( face_corner /= isubface ) then
                   if (this%get_num_dims() == 3 ) then
                    ! Distinguish among the situation where the corner is within a face 
                    ! or on its boundary, i.e., on top of an edge !!!
                    if ( P4EST_OPPOSITE_CORNER_2D(isubface) == face_corner ) then
                        ! The non_proper vef is within a face
                        improper_cell_around_ivef = num_corners_x_cell+num_edges_x_cell+P4EST_2_FEMPAR_FACE(jcell_iface)
                    else
                        ! DETERMINE icell_iedge 
                        icell_iedge  = -1
                        ! Go over edges belonging to icorner
                        do iedge_at_corner=1, NUM_EDGES_AT_CORNER_3D 
                           icell_iedge = P4EST_EDGES_AT_CORNER_3D(iedge_at_corner,icorner)
                           ! Go over faces belonging to iedge
                           do iface_at_edge=1, num_faces_at_edge_3d
                              icell_jface = P4EST_FACES_AT_EDGE_3D(iface_at_edge,icell_iedge)
                              if (icell_jface == icell_iface) exit
                           end do   
                           ! If at the end of the loop there is no face match, cycle
                           if (iface_at_edge > num_faces_at_edge_3d) then 
                               cycle
                           else 
                           !   If edge at boundary, or has edge neighbour in the local portion, or the edge neighbour exists in the global mesh
                           !   but not in the local portion (local+ghost cells) of this processor ...
                             if ( this%quad_to_quad_by_edge(icell_iedge,icell)+1 > 0 .or. &
                                    this%quad_to_quad_by_edge(icell_iedge,icell) == -2  ) then
                                   exit       
                             end if
                           end if
                        end do
                        assert ( iedge_at_corner <= NUM_EDGES_AT_CORNER_3D )
                        jcell_iedge= p4est_get_jcell_icorner(icell_iface,jcell_iface,icell_iedge,P4EST_EDGE_IN_FACE_3D,P4EST_FACE_EDGES_3D)
                        ! The non_proper vef is within an edge
                        improper_cell_around_ivef = num_corners_x_cell+P4EST_2_FEMPAR_EDGE_3D(jcell_iedge)
                     end if
                     improper_cell_around_subvef  = -1
                   else ! this%get_num_dims() == 2
                     improper_cell_around_ivef    = num_corners_x_cell+P4EST_2_FEMPAR_FACE(jcell_iface)                     
                     improper_cell_around_subvef  = -1
                   end if
                 is_proper = .false.
#if ENABLE_SINGLE_OCTREE_OPTS
                 work_vector_improper_cells_around(current_improper_cell_around) = jcell
                 work_vector_ivef(current_improper_cell_around) = improper_cell_around_ivef
                 work_vector_subvef(current_improper_cell_around) = improper_cell_around_subvef
                 current_improper_cell_around = current_improper_cell_around + 1 
#else
                 call work_vector_improper_cells_around%push_back(jcell)
                 call work_vector_ivef%push_back(improper_cell_around_ivef)
                 call work_vector_subvef%push_back(improper_cell_around_subvef)
#endif
                 if ( jcell > num_local_cells ) then
                   vef_at_interface = .true.
                 end if
              else
                min_cell   = min(min_cell,jcell)
                if (min_cell == jcell) then
                   min_icorner=p4est_get_jcell_icorner(icell_iface,jcell_iface,icorner,P4EST_CORNER_IN_FACE,P4EST_FACE_CORNERS)
                end if
                if ( jcell > num_local_cells ) then
                  vef_at_interface = .true.
                end if
#if ENABLE_SINGLE_OCTREE_OPTS
                work_vector_cells_around(current_cell_around) = jcell
                current_cell_around = current_cell_around + 1 
#else
                call work_vector_cells_around%push_back(jcell)
#endif
              end if
           else ! Half-side neighbour 
              assert (mortar == num_subfacets_facet+1)
              
              do isubface=1, size(this%quad_to_half,1)
                jcell      = this%quad_to_half(isubface,this%quad_to_quad(icell_iface,icell)+1)+1
                if ( jcell >=1 .and. jcell <= num_local_cells ) then
                   double_or_half_size_neighbour_local = .true.
                else if (jcell >= (num_local_cells+1) .and. jcell <= num_cells ) then
                   double_or_half_size_neighbour_ghost = .true.    
                end if
              end do

              ! Determine which face_corner of my face am I
              do face_corner=1, num_face_corners
                 if (P4EST_FACE_CORNERS(face_corner,icell_iface) == icorner) then
                    exit
                 end if
              end do
              assert(face_corner<=num_face_corners)
              jcell      = this%quad_to_half(face_corner,this%quad_to_quad(icell_iface,icell)+1)+1
              if ( jcell > 0 ) then
                min_cell   = min(min_cell,jcell)
                if (min_cell == jcell) then
                  min_icorner=p4est_get_jcell_icorner(icell_iface,jcell_iface,icorner,P4EST_CORNER_IN_FACE,P4EST_FACE_CORNERS)
                end if
                if ( jcell > num_local_cells ) then
                  vef_at_interface = .true.
                end if
#if ENABLE_SINGLE_OCTREE_OPTS
                work_vector_cells_around(current_cell_around) = jcell
                current_cell_around = current_cell_around + 1 
#else
                call work_vector_cells_around%push_back(jcell)
#endif
              end if
           end if
        end do  ! End loop faces at corner

        ! Find the edge neighbors
        if (this%get_num_dims() == 3) then
           do iedge_at_corner=1, NUM_EDGES_AT_CORNER_3D

              icell_iedge = P4EST_EDGES_AT_CORNER_3D(iedge_at_corner,icorner)
              jcell_iconn = this%quad_to_edge(icell_iedge,icell)         
              jcell       = this%quad_to_quad_by_edge(icell_iedge,icell)+1 
              
              ! If there is not edge neighbour across this edge ...
              if (.not. jcell>0) cycle
                            
              call p8est_eval_edge_connectivity(jcell_iconn, jcell_iedge, flip, mortar)
              assert (flip==1) ! All cells MUST be aligned with each other

              if (mortar == -1) then ! Conformal neighbour
                 ! Check whether icell across current edge is at the boundary
                 if ( icell == jcell ) then
                    vef_at_boundary = .true.
                    cycle
                 end if

                 min_cell   = min(min_cell,jcell)
                 if (min_cell == jcell) then
                    min_icorner= p4est_get_jcell_icorner(icell_iedge,jcell_iedge,icorner,P4EST_CORNER_IN_EDGE_3D,P4EST_EDGE_CORNERS_3D)
                 end if
                 
                 if ( jcell > num_local_cells ) then 
                   vef_at_interface = .true.
                 end if
#if ENABLE_SINGLE_OCTREE_OPTS
                 work_vector_cells_around(current_cell_around) = jcell
                 current_cell_around = current_cell_around + 1 
#else
                 call work_vector_cells_around%push_back(jcell)
#endif
              else if ( mortar >= 1 .and. mortar <= num_subedgets_edget )  then ! Double-size neighbour

                 if ( jcell >=1 .and. jcell <= num_local_cells ) then
                   double_or_half_size_neighbour_local = .true.
                 else if (jcell >= (num_local_cells+1) .and. jcell <= num_cells ) then
                   double_or_half_size_neighbour_ghost = .true.  
                 end if

                 ! 1. Determine whether this corner is improper 
                 child_id = F90_p8est_quadrant_child_id(this%quad_coords(1,icell), &
                                                        this%quad_coords(2,icell), &
                                                        this%quad_coords(3,icell), &
                                                        this%quad_level(icell)) + 1
                 
                 do isubedge = 1, num_subedgets_edget
                   if (FEMPAR_SUBCELLS_IN_TOUCH_EDGE_3D(isubedge,P4EST_2_FEMPAR_EDGE_3D(icell_iedge)) == child_id) then
                    exit
                   end if
                 end do
                 assert(isubedge<=num_subedgets_edget)
                 
                 ! 2. Determine which edge_corner of my edge am I
                 do edge_corner=1, num_edge_corners
                    if (P4EST_EDGE_CORNERS_3D(edge_corner,icell_iedge) == icorner) then
                       exit
                    end if
                 end do
                 assert(edge_corner<=num_edge_corners)

                 ! 3. I am improper if am either corner 1 of subedge 0 or corner 0 of subedge 1
                 if ( edge_corner /= isubedge ) then
                    improper_cell_around_ivef    = num_corners_x_cell+P4EST_2_FEMPAR_EDGE_3D(jcell_iedge)
                    improper_cell_around_subvef  = -1
                    is_proper = .false.
#if ENABLE_SINGLE_OCTREE_OPTS
                    work_vector_improper_cells_around(current_improper_cell_around) = jcell
                    work_vector_ivef(current_improper_cell_around) = improper_cell_around_ivef
                    work_vector_subvef(current_improper_cell_around) = improper_cell_around_subvef
                    current_improper_cell_around = current_improper_cell_around + 1 
#else
                    call work_vector_improper_cells_around%push_back(jcell)
                    call work_vector_ivef%push_back(improper_cell_around_ivef)
                    call work_vector_subvef%push_back(improper_cell_around_subvef)
#endif
                    if ( jcell > num_local_cells ) then
                      vef_at_interface = .true.
                    end if
                 else
                    min_cell   = min(min_cell,jcell)
                    if (min_cell == jcell) then
                       min_icorner=p4est_get_jcell_icorner(icell_iedge,jcell_iedge,icorner,P4EST_CORNER_IN_EDGE_3D,P4EST_EDGE_CORNERS_3D)
                    end if
                    
                    if ( jcell > num_local_cells ) then
                       vef_at_interface = .true.
                    end if
#if ENABLE_SINGLE_OCTREE_OPTS
                    work_vector_cells_around(current_cell_around) = jcell
                    current_cell_around = current_cell_around + 1 
#else
                    call work_vector_cells_around%push_back(jcell)
#endif
                 end if
              else ! Half-side neighbour 
                 assert (mortar == num_subedgets_edget+1)
                 do isubedge=1, size(this%quad_to_half_by_edge,1)
                   jcell      = this%quad_to_half_by_edge(isubedge,this%quad_to_quad_by_edge(icell_iedge,icell)+1)+1
                   if ( jcell >=1 .and. jcell <= num_local_cells ) then
                      double_or_half_size_neighbour_local = .true.
                   else if (jcell >= (num_local_cells+1) .and. jcell <= num_cells ) then
                      double_or_half_size_neighbour_ghost = .true. 
                   end if
                 end do
                 ! Determine which edge_corner of my edge am I
                 do edge_corner=1, num_edge_corners
                    if (P4EST_EDGE_CORNERS_3D(edge_corner,icell_iedge) == icorner) then
                       exit
                    end if
                 end do
                 assert(edge_corner<=num_edge_corners)
                 jcell       = this%quad_to_half_by_edge(edge_corner,this%quad_to_quad_by_edge(icell_iedge,icell)+1)+1
                 if ( jcell > 0 ) then
                   min_cell   = min(min_cell,jcell)
                   if (min_cell == jcell) then
                     min_icorner=p4est_get_jcell_icorner(icell_iedge,jcell_iedge,icorner,P4EST_CORNER_IN_EDGE_3D,P4EST_EDGE_CORNERS_3D)
                   end if
                   if ( jcell > num_local_cells ) then 
                     vef_at_interface = .true.
                   end if 
#if ENABLE_SINGLE_OCTREE_OPTS
                   work_vector_cells_around(current_cell_around) = jcell
                   current_cell_around = current_cell_around + 1 
#else
                   call work_vector_cells_around%push_back(jcell)
#endif
                 end if 
              end if
           end do
        end if

        ! A corner cannot become improper by a corner neighbour which is not a face neighbour
        jcell          = this%quad_to_corner(icorner,icell)+1
        jcell_icorner  = P4EST_OPPOSITE_CORNER(icorner)

        if (jcell > 0) then
           min_cell   = min(min_cell,jcell)
           if (min_cell == jcell) then
              min_icorner=jcell_icorner
           end if
           if ( jcell > num_local_cells ) then
              vef_at_interface = .true.
           end if
#if ENABLE_SINGLE_OCTREE_OPTS
           work_vector_cells_around(current_cell_around) = jcell
           current_cell_around = current_cell_around + 1 
#else
           call work_vector_cells_around%push_back(jcell)
#endif
        end if

        base_pos_icell    = this%get_ptr_vefs_x_cell(icell)-1
        base_pos_min_cell = this%get_ptr_vefs_x_cell(min_cell)-1

        ! If am owner of this corner
        if (icell == min_cell) then
           if (is_proper) then
              this%num_proper_vefs = this%num_proper_vefs+1
              call this%lst_vefs_gids%set(base_pos_icell+P4EST_2_FEMPAR_CORNER(icorner), this%num_proper_vefs)
              
#if ENABLE_SINGLE_OCTREE_OPTS
              call this%ptr_cells_around_proper_vefs%push_back(current_cell_around-1)
              do i=1, current_cell_around-1
                call this%lst_cells_around_proper_vefs%push_back(work_vector_cells_around(i))
              end do
#else
              call this%ptr_cells_around_proper_vefs%push_back(work_vector_cells_around%size())
              ! Process local cells around
              do i=1, work_vector_cells_around%size()
                 call this%lst_cells_around_proper_vefs%push_back(work_vector_cells_around%get(i))
              end do
#endif
              
              ! Fill proper vefs dim
              call this%proper_vefs_dim%push_back(0)

              ! Fill proper vefs at boundary
              if ( vef_at_boundary ) then
                 call this%proper_vefs_at_boundary%push_back(.true.)
              else
                 call this%proper_vefs_at_boundary%push_back(.false.)
              end if

              ! Fill proper vefs at interface 
              if ( vef_at_interface .or.  double_or_half_size_neighbour_ghost) then
                 call this%proper_vefs_at_interface%push_back(.true.)
              else
                 call this%proper_vefs_at_interface%push_back(.false.)
              end if

              if ( (min_cell >=1 .and. min_cell <= num_local_cells) .or. double_or_half_size_neighbour_local) then
                call this%proper_vefs_is_ghost%push_back(.false.)
              else
                call this%proper_vefs_is_ghost%push_back(.true.)
              end if 
           else 
              this%num_improper_vefs = this%num_improper_vefs+1
              call this%lst_vefs_gids%set(base_pos_icell+P4EST_2_FEMPAR_CORNER(icorner), -this%num_improper_vefs)

#if ENABLE_SINGLE_OCTREE_OPTS
              ! Fill cells_around improper vefs
              call this%ptr_cells_around_improper_vefs%push_back(current_cell_around-1)
              do i=1, current_cell_around-1
                call this%lst_cells_around_improper_vefs%push_back(work_vector_cells_around(i))
              end do
              
              ! Fill improper cells_around improper vefs
              call this%ptr_improper_cells_around%push_back(current_improper_cell_around-1)
              do i=1, current_improper_cell_around-1
                 call this%lst_improper_cells_around%push_back(work_vector_improper_cells_around(i))
                 call this%improper_vefs_improper_cell_around_ivef%push_back(work_vector_ivef(i))
                 call this%improper_vefs_improper_cell_around_subvef%push_back(work_vector_subvef(i)) 
              end do
#else
              ! Fill local cells_around improper vefs 
              call this%ptr_cells_around_improper_vefs%push_back(work_vector_cells_around%size())
              do i=1, work_vector_cells_around%size()
                 call this%lst_cells_around_improper_vefs%push_back(work_vector_cells_around%get(i))
              end do
              ! Fill improper cells_around improper vefs
              call this%ptr_improper_cells_around%push_back(work_vector_improper_cells_around%size())
              do i=1, work_vector_improper_cells_around%size()
                 call this%lst_improper_cells_around%push_back(work_vector_improper_cells_around%get(i))
                 call this%improper_vefs_improper_cell_around_ivef%push_back(work_vector_ivef%get(i))
                 call this%improper_vefs_improper_cell_around_subvef%push_back(work_vector_subvef%get(i)) 
              end do
#endif
              
              ! Fill improper vefs dim
              call this%improper_vefs_dim%push_back(0)
              
              ! Fill proper vefs at interface 
              if ( vef_at_interface ) then
                 call this%improper_vefs_at_interface%push_back(.true.)
              else
                 call this%improper_vefs_at_interface%push_back(.false.)
              end if
              if ( (min_cell >=1 .and. min_cell <= num_local_cells) .or. double_or_half_size_neighbour_local) then
                call this%improper_vefs_is_ghost%push_back(.false.)
              else
                call this%improper_vefs_is_ghost%push_back(.true.)
              end if 
           end if
        else
           vef_gid = this%lst_vefs_gids%get(base_pos_min_cell+P4EST_2_FEMPAR_CORNER(min_icorner))
           call this%lst_vefs_gids%set(base_pos_icell+P4EST_2_FEMPAR_CORNER(icorner), vef_gid)
           if ( min_cell > num_local_cells .and. double_or_half_size_neighbour_local ) then
             if ( vef_gid > 0 ) then
               call this%proper_vefs_is_ghost%set(vef_gid, .false.)
             else 
               call this%improper_vefs_is_ghost%set(abs(vef_gid), .false.)
             end if
           end if 
           if ( double_or_half_size_neighbour_ghost ) then
             if ( vef_gid > 0 ) then
               call this%proper_vefs_at_interface%set(vef_gid, .true.)
             end if
           end if 
        end if
     end do ! icorner
   end subroutine generate_corners
  
   subroutine generate_edges()
     implicit none
     if (this%get_num_dims() == 3) then
        do iedge=1, num_edges_x_cell
           is_proper         = .true.
           min_cell          = icell
           min_iedge         = iedge
           vef_at_boundary   = .false.
           if (icell > num_local_cells) then
             vef_at_interface = .true.
           else
             vef_at_interface = .false.
           end if 
           min_cell_int_edge = 0
           double_or_half_size_neighbour_local = .false.
           double_or_half_size_neighbour_ghost = .false.
#if ENABLE_SINGLE_OCTREE_OPTS
           work_vector_cells_around(1)=icell
           current_cell_around = 2
           current_improper_cell_around = 1
#else
           call work_vector_cells_around%resize(0)
           call work_vector_cells_around%push_back(icell)
           call work_vector_improper_cells_around%resize(0)
           call work_vector_ivef%resize(0)
           call work_vector_subvef%resize(0)
#endif
           
           ! Find neigs only by edge
           jcell = this%quad_to_quad_by_edge(iedge,icell)+1
           if (jcell > 0) then
              jcell_iconn = this%quad_to_edge(iedge,icell)         

              call p8est_eval_edge_connectivity(jcell_iconn, jcell_iedge, flip, mortar)
              assert (flip==1) ! All cells MUST be aligned with each other
              
              if (icell /= jcell .and. mortar == -1) then ! Conformal neighbour
                 min_cell   = min(min_cell,jcell)
                 if (min_cell == jcell) then
                    min_iedge   = this%quad_to_edge(iedge,icell)+1
                 end if                 
                 if ( jcell > num_local_cells ) then ! If neighbour cell is ghost
                    vef_at_interface = .true.
                 end if
#if ENABLE_SINGLE_OCTREE_OPTS
                 work_vector_cells_around(current_cell_around) = jcell
                 current_cell_around = current_cell_around + 1 
#else
                 call work_vector_cells_around%push_back(jcell)
#endif
              else if ( mortar >= 1 .and. mortar <= num_subedgets_edget )  then ! Double-size neighbour
                 jcell         = this%quad_to_quad_by_edge(iedge,icell)+1
                 
                 ! 1. Determine whether this edge is improper 
                 child_id = F90_p8est_quadrant_child_id(this%quad_coords(1,icell), &
                                                        this%quad_coords(2,icell), &
                                                        this%quad_coords(3,icell), &
                                                        this%quad_level(icell)) + 1
                 
                 do isubedge = 1, num_subedgets_edget
                   if (FEMPAR_SUBCELLS_IN_TOUCH_EDGE_3D(isubedge,P4EST_2_FEMPAR_EDGE_3D(iedge)) == child_id) then
                    exit
                   end if
                 end do
                 assert(isubedge<=num_subedgets_edget)
                 
                 improper_cell_around_ivef    = num_corners_x_cell+P4EST_2_FEMPAR_EDGE_3D(jcell_iedge)
                 improper_cell_around_subvef  = isubedge
                 is_proper = .false.
#if ENABLE_SINGLE_OCTREE_OPTS
                 work_vector_improper_cells_around(current_improper_cell_around) = jcell
                 work_vector_ivef(current_improper_cell_around) = improper_cell_around_ivef
                 work_vector_subvef(current_improper_cell_around) = improper_cell_around_subvef
                 current_improper_cell_around = current_improper_cell_around + 1 
#else
                 call work_vector_improper_cells_around%push_back(jcell)
                 call work_vector_ivef%push_back(improper_cell_around_ivef)
                 call work_vector_subvef%push_back(improper_cell_around_subvef)
#endif
                 if ( jcell > num_local_cells ) then
                   vef_at_interface = .true.
                 end if
                 if ( jcell >=1 .and. jcell <= num_local_cells ) then
                   double_or_half_size_neighbour_local = .true.
                 else if (jcell >= (num_local_cells+1) .and. jcell <= num_cells ) then
                   double_or_half_size_neighbour_ghost = .true.
                 end if  
              else if (mortar == num_subedgets_edget+1) then ! Half-size neighbour
                 do isubedge=1, size(this%quad_to_half_by_edge,1)
                   jcell      = this%quad_to_half_by_edge(isubedge,this%quad_to_quad_by_edge(iedge,icell)+1)+1
                   if ( jcell >=1 .and. jcell <= num_local_cells ) then
                      double_or_half_size_neighbour_local = .true.
                   else if (jcell >= (num_local_cells+1) .and. jcell <= num_cells ) then
                      double_or_half_size_neighbour_ghost = .true.
                   end if
                 end do
              end if
           end if           

           ! Find face neighbors
           do iface_at_edge=1, NUM_FACES_AT_EDGE_3D
              icell_iface = P4EST_FACES_AT_EDGE_3D(iface_at_edge,iedge)
              jcell_iconn = this%quad_to_face(icell_iface,icell)         
              
              if (this%quad_to_quad(icell_iface,icell)<0) cycle
              
              call p8est_eval_connectivity(jcell_iconn, jcell_iface, flip, mortar)
              assert (flip==1) ! All cells MUST be aligned with each other

              if (mortar == -1) then ! Conformal neighbour
                 jcell      = this%quad_to_quad(icell_iface,icell)+1 
                 if ( icell == jcell ) then
                    vef_at_boundary = .true.
                    cycle
                 end if
                 min_cell   = min(min_cell,jcell)
                 if (min_cell == jcell) then
                    min_iedge= p4est_get_jcell_icorner(icell_iface,jcell_iface,iedge,P4EST_EDGE_IN_FACE_3D,P4EST_FACE_EDGES_3D)
                 end if
                 if ( jcell > num_local_cells ) then ! If neighbour cell is ghost
                    vef_at_interface = .true.
                 end if
#if ENABLE_SINGLE_OCTREE_OPTS
                 work_vector_cells_around(current_cell_around) = jcell
                 current_cell_around = current_cell_around + 1 
#else
                 call work_vector_cells_around%push_back(jcell)
#endif
              else if ( mortar >= 1 .and. mortar <= num_subfacets_facet )  then ! Double-size neighbour 
                 jcell      = this%quad_to_quad(icell_iface,icell)+1
                 if ( jcell >=1 .and. jcell <= num_local_cells ) then
                   double_or_half_size_neighbour_local = .true.
                 else if (jcell >= (num_local_cells+1) .and. jcell <= num_cells ) then
                   double_or_half_size_neighbour_ghost = .true.  
                 end if
                 if ( min_cell_int_edge == 0 ) then
                   min_cell_int_edge = jcell
                 else
                   min_cell_int_edge = min(min_cell_int_edge, jcell)
                 end if
                 
                 child_id = F90_p8est_quadrant_child_id(this%quad_coords(1,icell), &
                                                        this%quad_coords(2,icell), &
                                                        this%quad_coords(3,icell), &
                                                        this%quad_level(icell)) + 1
                            
                 do isubface = 1, num_subfacets_facet
                    if (FEMPAR_SUBCELLS_IN_TOUCH_FACE(isubface,P4EST_2_FEMPAR_FACE(icell_iface)) == child_id) then
                       exit
                    end if
                 end do
                 assert(isubface<=num_subfacets_facet)

                 ! If there is edge neighbour in the local portion, 
                 ! or not in the local portion but in the global octree ...
                 if (this%quad_to_quad_by_edge(iedge,icell)+1 > 0 .or. & 
                      this%quad_to_quad_by_edge(iedge,icell) == -2) then
                    ! The current edge is for sure improper
                    ! 1. Determine jcell_iedge
                    jcell_iedge= p4est_get_jcell_icorner(icell_iface,jcell_iface,iedge,P4EST_EDGE_IN_FACE_3D,P4EST_FACE_EDGES_3D)

                    ! 2. Determine which edge_face of icell_iface am I
                    do edge_face=1, NUM_FACE_EDGES_3D
                       if (P4EST_FACE_EDGES_3D(edge_face,icell_iface) == iedge ) exit
                    end do
                    assert(edge_face<=NUM_FACE_EDGES_3D)

                    improper_cell_around_ivef    = num_corners_x_cell+P4EST_2_FEMPAR_EDGE_3D(jcell_iedge)
                    if ( (edge_face-1)/2 == 0 ) then ! if edge_face == 1 .or. edge_face == 2
                       improper_cell_around_subvef = (isubface+1)/2
                    else
                       if ( mod(isubface,2) /= 0 ) then
                         improper_cell_around_subvef  = 1
                       else
                         improper_cell_around_subvef  = 2
                       end if
                    end if
                 ! If there is not edge neighbour (cause edge in the middle of a face)
                 else if (this%quad_to_quad_by_edge(iedge,icell) == -1) then 
                    improper_cell_around_ivef    = num_corners_x_cell+num_edges_x_cell+P4EST_2_FEMPAR_FACE(jcell_iface)
                    if ( min_cell_int_edge == jcell ) then
                      improper_cell_around_subvef  = -1
                    end if  
                 end if 
                 is_proper = .false.
#if ENABLE_SINGLE_OCTREE_OPTS
                 work_vector_improper_cells_around(current_improper_cell_around) = jcell
                 work_vector_ivef(current_improper_cell_around) = improper_cell_around_ivef
                 work_vector_subvef(current_improper_cell_around) = improper_cell_around_subvef
                 current_improper_cell_around = current_improper_cell_around + 1 
#else
                 call work_vector_improper_cells_around%push_back(jcell)
                 call work_vector_ivef%push_back(improper_cell_around_ivef)
                 call work_vector_subvef%push_back(improper_cell_around_subvef)
#endif
                 if ( jcell > num_local_cells ) then
                   vef_at_interface = .true.
                 end if
              else ! half-size neighbour
                 assert ( mortar == num_subfacets_facet + 1 )  
                 do isubface=1, size(this%quad_to_half,1)
                   jcell      = this%quad_to_half(isubface,this%quad_to_quad(icell_iface,icell)+1)+1
                   if ( jcell >=1 .and. jcell <= num_local_cells ) then
                     double_or_half_size_neighbour_local = .true.
                   else if (jcell >= (num_local_cells+1) .and. jcell <= num_cells ) then
                     double_or_half_size_neighbour_ghost = .true.  
                   end if
                 end do
            end if  
           end do ! iface_at_edge

           base_pos_icell    = this%get_ptr_vefs_x_cell(icell)-1    + num_corners_x_cell
           base_pos_min_cell = this%get_ptr_vefs_x_cell(min_cell)-1 + num_corners_x_cell

             ! If am owner of this edge
             if (icell == min_cell) then
              if (is_proper) then
                 this%num_proper_vefs = this%num_proper_vefs+1
                 call this%lst_vefs_gids%set(base_pos_icell+P4EST_2_FEMPAR_EDGE_3D(iedge), this%num_proper_vefs)

#if ENABLE_SINGLE_OCTREE_OPTS
                 call this%ptr_cells_around_proper_vefs%push_back(current_cell_around-1)
                 do i=1, current_cell_around-1
                   call this%lst_cells_around_proper_vefs%push_back(work_vector_cells_around(i))
                 end do
#else
                 call this%ptr_cells_around_proper_vefs%push_back(work_vector_cells_around%size())
                 do i=1, work_vector_cells_around%size()
                    call this%lst_cells_around_proper_vefs%push_back(work_vector_cells_around%get(i))
                 end do
#endif
                  
                 ! Fill proper vefs dim
                 call this%proper_vefs_dim%push_back(1)

                 ! Fill proper vefs at boundary
                 if ( vef_at_boundary ) then
                    call this%proper_vefs_at_boundary%push_back(.true.)
                 else
                    call this%proper_vefs_at_boundary%push_back(.false.)
                 end if
                 
                 ! Fill proper vefs at interface 
                 if ( vef_at_interface .or. double_or_half_size_neighbour_ghost ) then
                   call this%proper_vefs_at_interface%push_back(.true.)
                 else
                   call this%proper_vefs_at_interface%push_back(.false.)
                 end if

                 if ( (min_cell >=1 .and. min_cell <= num_local_cells) .or. double_or_half_size_neighbour_local) then
                   call this%proper_vefs_is_ghost%push_back(.false.)
                 else
                   call this%proper_vefs_is_ghost%push_back(.true.)
                 end if 
              else
                 this%num_improper_vefs = this%num_improper_vefs+1
                 call this%lst_vefs_gids%set(base_pos_icell+P4EST_2_FEMPAR_EDGE_3D(iedge), -this%num_improper_vefs)

#if ENABLE_SINGLE_OCTREE_OPTS
                 ! Fill cells_around improper vefs
                 call this%ptr_cells_around_improper_vefs%push_back(current_cell_around-1)
                 do i=1, current_cell_around-1
                   call this%lst_cells_around_improper_vefs%push_back(work_vector_cells_around(i))
                 end do
              
                 ! Fill improper cells_around improper vefs
                 call this%ptr_improper_cells_around%push_back(current_improper_cell_around-1)
                 do i=1, current_improper_cell_around-1
                   call this%lst_improper_cells_around%push_back(work_vector_improper_cells_around(i))
                   call this%improper_vefs_improper_cell_around_ivef%push_back(work_vector_ivef(i))
                   call this%improper_vefs_improper_cell_around_subvef%push_back(work_vector_subvef(i)) 
                 end do
#else
                 ! Fill cells_around improper vefs 
                 call this%ptr_cells_around_improper_vefs%push_back(work_vector_cells_around%size())
                 do i=1, work_vector_cells_around%size()
                   call this%lst_cells_around_improper_vefs%push_back(work_vector_cells_around%get(i))
                 end do
                 ! Fill improper cells_around improper vefs
                 call this%ptr_improper_cells_around%push_back(work_vector_improper_cells_around%size())
                 do i=1, work_vector_improper_cells_around%size()
                    call this%lst_improper_cells_around%push_back(work_vector_improper_cells_around%get(i))
                    call this%improper_vefs_improper_cell_around_ivef%push_back(work_vector_ivef%get(i))
                    call this%improper_vefs_improper_cell_around_subvef%push_back(work_vector_subvef%get(i)) 
                 end do
#endif

                 ! Fill improper vefs dim
                 call this%improper_vefs_dim%push_back(1)
                 
                 ! Fill proper vefs at interface 
                 if ( vef_at_interface ) then
                   call this%improper_vefs_at_interface%push_back(.true.)
                 else
                   call this%improper_vefs_at_interface%push_back(.false.)
                 end if

                 if ( (min_cell >=1 .and. min_cell <= num_local_cells) .or. double_or_half_size_neighbour_local) then
                   call this%improper_vefs_is_ghost%push_back(.false.)
                 else
                   call this%improper_vefs_is_ghost%push_back(.true.)
                 end if
              end if
             else
                vef_gid =this%lst_vefs_gids%get(base_pos_min_cell+P4EST_2_FEMPAR_EDGE_3D(min_iedge)) 
                call this%lst_vefs_gids%set(base_pos_icell+P4EST_2_FEMPAR_EDGE_3D(iedge), vef_gid)
                if ( min_cell > num_local_cells .and. double_or_half_size_neighbour_local ) then
                  if ( vef_gid > 0 ) then
                    call this%proper_vefs_is_ghost%set(vef_gid, .false.)
                  else
                    call this%improper_vefs_is_ghost%set(abs(vef_gid), .false.)
                  end if
                end if
                if ( double_or_half_size_neighbour_ghost ) then
                  if ( vef_gid > 0 ) then
                    call this%proper_vefs_at_interface%set(vef_gid, .true.)
                  end if
                end if
             end if
        end do ! iedge
     end if
   end subroutine generate_edges
   
   subroutine generate_faces()
     implicit none
     do iface=1, num_faces_x_cell
        is_proper        = .true.
        min_cell         = icell
        min_iface        = iface 
        vef_at_boundary  = .false.
        if (icell > num_local_cells) then
          vef_at_interface = .true.
        else
          vef_at_interface = .false.
        end if 
        double_or_half_size_neighbour_local = .false.
        double_or_half_size_neighbour_ghost = .false.

        if (this%quad_to_quad(iface,icell)>=0) then
#if ENABLE_SINGLE_OCTREE_OPTS
           work_vector_cells_around(1)=icell
           current_cell_around = 2
           current_improper_cell_around = 1
#else
           call work_vector_cells_around%resize(0)
           call work_vector_cells_around%push_back(icell)
           call work_vector_improper_cells_around%resize(0)
           call work_vector_ivef%resize(0)
           call work_vector_subvef%resize(0)
#endif
           
           jcell_iconn = this%quad_to_face(iface,icell)         
           
           if (this%get_num_dims() == 2) then
              call p4est_eval_connectivity(jcell_iconn, jcell_iface, flip, mortar)
           elseif (this%get_num_dims() == 3) then
              call p8est_eval_connectivity(jcell_iconn, jcell_iface, flip, mortar)
           else
              check(.false.)
           end if
           
           assert (flip==1) ! All cells we are working with MUST be aligned with each other
           if (mortar == -1) then ! Conformal neighbour
              jcell      = this%quad_to_quad(iface,icell)+1 

              min_cell = min(min_cell,jcell)
              if (min_cell == jcell) then
                 min_iface=this%quad_to_face(iface,icell)+1 
              end if
              if ( jcell /= icell ) then ! Skip myself if at boundary
                 if ( jcell > num_local_cells ) then
                    vef_at_interface = .true.
                 end if
#if ENABLE_SINGLE_OCTREE_OPTS
                 work_vector_cells_around(current_cell_around) = jcell
                 current_cell_around = current_cell_around + 1 
#else
                 call work_vector_cells_around%push_back(jcell)
#endif
              else
                 vef_at_boundary = .true.
              end if
           else if ( mortar >= 1 .and. mortar <= num_subfacets_facet )  then ! Double-size neighbour 
              improper_cell_around_ivef    = num_corners_x_cell+num_edges_x_cell+P4EST_2_FEMPAR_FACE(jcell_iface)
              improper_cell_around_subvef  = mortar
              jcell      = this%quad_to_quad(iface,icell)+1
              is_proper = .false. 
#if ENABLE_SINGLE_OCTREE_OPTS
              work_vector_improper_cells_around(current_improper_cell_around) = jcell
              work_vector_ivef(current_improper_cell_around) = improper_cell_around_ivef
              work_vector_subvef(current_improper_cell_around) = improper_cell_around_subvef
              current_improper_cell_around = current_improper_cell_around + 1 
#else
              call work_vector_improper_cells_around%push_back(jcell)
              call work_vector_ivef%push_back(improper_cell_around_ivef)
              call work_vector_subvef%push_back(improper_cell_around_subvef)
#endif
              if ( jcell > num_local_cells ) then
                 vef_at_interface = .true.
              end if
              if ( jcell >=1 .and. jcell <= num_local_cells ) then
                 double_or_half_size_neighbour_local = .true.
              else if (jcell >= (num_local_cells+1) .and. jcell <= num_cells ) then
                 double_or_half_size_neighbour_ghost = .true.   
              end if
           else ! Half-size neighbour
             do isubface=1, size(this%quad_to_half,1)
                jcell      = this%quad_to_half(isubface,this%quad_to_quad(iface,icell)+1)+1
                if ( jcell >=1 .and. jcell <= num_local_cells ) then
                   double_or_half_size_neighbour_local = .true.
                else if (jcell >= (num_local_cells+1) .and. jcell <= num_cells ) then
                 double_or_half_size_neighbour_ghost = .true.
                end if
             end do
           end if
        end if 

        base_pos_icell    = this%get_ptr_vefs_x_cell(icell)-1    + num_corners_x_cell + num_edges_x_cell
        base_pos_min_cell = this%get_ptr_vefs_x_cell(min_cell)-1 + num_corners_x_cell + num_edges_x_cell

        ! If am owner of this corner
        if (icell == min_cell) then
           if (is_proper) then
              this%num_proper_vefs=this%num_proper_vefs+1
              call this%lst_vefs_gids%set(base_pos_icell+P4EST_2_FEMPAR_FACE(iface), this%num_proper_vefs)

#if ENABLE_SINGLE_OCTREE_OPTS
              call this%ptr_cells_around_proper_vefs%push_back(current_cell_around-1)
              do i=1, current_cell_around-1
                call this%lst_cells_around_proper_vefs%push_back(work_vector_cells_around(i))
              end do
#else
              ! Fill local cells_around proper vefs
              call this%ptr_cells_around_proper_vefs%push_back(work_vector_cells_around%size())
              do i=1, work_vector_cells_around%size()
                 call this%lst_cells_around_proper_vefs%push_back(work_vector_cells_around%get(i))
              end do
#endif

              ! Fill proper vefs dim
              call this%proper_vefs_dim%push_back(this%get_num_dims()-1)

              ! Fill proper vefs at boundary
              if ( vef_at_boundary ) then
                 call this%proper_vefs_at_boundary%push_back(.true.)
              else
                 call this%proper_vefs_at_boundary%push_back(.false.)
              end if

              ! Fill proper vefs at interface 
              if ( vef_at_interface .or. double_or_half_size_neighbour_ghost ) then
                 call this%proper_vefs_at_interface%push_back(.true.)
              else
                 call this%proper_vefs_at_interface%push_back(.false.)
              end if

              if ( (min_cell >=1 .and. min_cell <= num_local_cells) .or. double_or_half_size_neighbour_local) then
                call this%proper_vefs_is_ghost%push_back(.false.)
              else
                call this%proper_vefs_is_ghost%push_back(.true.)
              end if
           else 
              this%num_improper_vefs=this%num_improper_vefs+1
              call this%lst_vefs_gids%set(base_pos_icell+P4EST_2_FEMPAR_FACE(iface), -this%num_improper_vefs)

#if ENABLE_SINGLE_OCTREE_OPTS
              ! Fill cells_around improper vefs
              call this%ptr_cells_around_improper_vefs%push_back(current_cell_around-1)
              do i=1, current_cell_around-1
                call this%lst_cells_around_improper_vefs%push_back(work_vector_cells_around(i))
              end do
              
              ! Fill improper cells_around improper vefs
              call this%ptr_improper_cells_around%push_back(current_improper_cell_around-1)
              do i=1, current_improper_cell_around-1
                 call this%lst_improper_cells_around%push_back(work_vector_improper_cells_around(i))
                 call this%improper_vefs_improper_cell_around_ivef%push_back(work_vector_ivef(i))
                 call this%improper_vefs_improper_cell_around_subvef%push_back(work_vector_subvef(i)) 
              end do
#else
              ! Fill cells_around improper vefs
              call this%ptr_cells_around_improper_vefs%push_back(work_vector_cells_around%size())
              do i=1, work_vector_cells_around%size()
                 call this%lst_cells_around_improper_vefs%push_back(work_vector_cells_around%get(i))
              end do

              ! Fill improper cells_around improper vefs
              call this%ptr_improper_cells_around%push_back(work_vector_improper_cells_around%size())
              do i=1, work_vector_improper_cells_around%size()
                 call this%lst_improper_cells_around%push_back(work_vector_improper_cells_around%get(i))
                 call this%improper_vefs_improper_cell_around_ivef%push_back(work_vector_ivef%get(i))
                 call this%improper_vefs_improper_cell_around_subvef%push_back(work_vector_subvef%get(i)) 
              end do
#endif

              ! Fill improper vefs dim
              call this%improper_vefs_dim%push_back(this%get_num_dims()-1)
              
              ! Fill proper vefs at interface 
              if ( vef_at_interface ) then
                 call this%improper_vefs_at_interface%push_back(.true.)
              else
                 call this%improper_vefs_at_interface%push_back(.false.)
              end if

              if ( (min_cell >=1 .and. min_cell <= num_local_cells) .or. double_or_half_size_neighbour_local) then
                 call this%improper_vefs_is_ghost%push_back(.false.)
              else
                 call this%improper_vefs_is_ghost%push_back(.true.)
              end if
           end if
        else ! Borrow vef gid from owner
           call this%lst_vefs_gids%set(base_pos_icell+P4EST_2_FEMPAR_FACE(iface), &
                this%lst_vefs_gids%get(base_pos_min_cell+P4EST_2_FEMPAR_FACE(min_iface)))
        end if
     end do ! iface
   end subroutine generate_faces
#else
  call this%not_enabled_error()
#endif
end subroutine p4est_bt_update_lst_vefs_gids_and_cells_around

subroutine p4est_bt_update_cell_set_ids(this)
  implicit none
  class(p4est_base_triangulation_t), intent(inout)    :: this
  type(std_vector_integer_ip_t) :: old_cell_set_ids
  integer(ip) :: num_children_x_cell
  integer(ip) :: old_cell_set_id
  integer(ip) :: transformation_flag
  integer(ip) :: i, j
  integer(ip)         , pointer :: p_cell_set_ids(:)
  class(environment_t), pointer :: environment
  type(cell_import_t) , pointer :: cell_import 
  
  
#ifdef ENABLE_P4EST
  call old_cell_set_ids%copy(this%cell_set_ids)
  call this%cell_set_ids%resize(0)
  if ( this%get_num_dims() == 2 ) then
    num_children_x_cell = NUM_CORNERS_2D
  else if ( this%get_num_dims() == 3 ) then
    num_children_x_cell = NUM_CORNERS_3D
  end if
  
  assert ( old_cell_set_ids%size() == this%refinement_and_coarsening_flags%size() )
  
  i=1
  do while ( i <= this%previous_num_local_cells )
    transformation_flag = this%refinement_and_coarsening_flags%get(i)
    old_cell_set_id     = old_cell_set_ids%get(i)
    if ( transformation_flag == do_nothing ) then
      call this%cell_set_ids%push_back(old_cell_set_id)
    else if ( transformation_flag == refinement ) then
      do j=1, num_children_x_cell
        call this%cell_set_ids%push_back(old_cell_set_id)
      end do
    else if ( transformation_flag == coarsening ) then
      call this%cell_set_ids%push_back(old_cell_set_id)
      do j=1, num_children_x_cell
        i=i+1
      end do
      cycle
    else 
      assert(.false.)
    end if
    i=i+1
  end do
  call old_cell_set_ids%free()
  call this%cell_set_ids%resize(this%cell_set_ids%size()+this%get_num_ghost_cells(),0)
#else
  call this%not_enabled_error()
#endif        
  
end subroutine p4est_bt_update_cell_set_ids

subroutine p4est_bt_update_cell_weights(this)
  implicit none
  class(p4est_base_triangulation_t), intent(inout)    :: this
  type(std_vector_integer_ip_t) :: old_cell_weights
  integer(ip) :: num_children_x_cell
  integer(ip) :: old_cell_weight
  integer(ip) :: transformation_flag
  integer(ip) :: i, j
  integer(ip)         , pointer :: p_cell_weights(:)
  class(environment_t), pointer :: environment
  type(cell_import_t) , pointer :: cell_import 
  
  
#ifdef ENABLE_P4EST
  call old_cell_weights%copy(this%cell_weights)
  call this%cell_weights%resize(0)
  if ( this%get_num_dims() == 2 ) then
    num_children_x_cell = NUM_CORNERS_2D
  else if ( this%get_num_dims() == 3 ) then
    num_children_x_cell = NUM_CORNERS_3D
  end if
  
  assert ( old_cell_weights%size() == this%refinement_and_coarsening_flags%size() )
  
  i=1
  do while ( i <= this%previous_num_local_cells )
    transformation_flag = this%refinement_and_coarsening_flags%get(i)
    old_cell_weight     = old_cell_weights%get(i)
    if ( transformation_flag == do_nothing ) then
      call this%cell_weights%push_back(old_cell_weight)
    else if ( transformation_flag == refinement ) then
      do j=1, num_children_x_cell
        call this%cell_weights%push_back(old_cell_weight)
      end do
    else if ( transformation_flag == coarsening ) then
      call this%cell_weights%push_back(old_cell_weight)
      do j=1, num_children_x_cell
        i=i+1
      end do
      cycle
    else 
      assert(.false.)
    end if
    i=i+1
  end do
  call old_cell_weights%free()
  call this%cell_weights%resize(this%cell_weights%size()+this%get_num_ghost_cells(),0)
#else
  call this%not_enabled_error()
#endif        
  
end subroutine p4est_bt_update_cell_weights


subroutine p4est_bt_comm_cell_set_ids(this)
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  class(environment_t), pointer     :: environment
  class(cell_import_t), pointer     :: cell_import
  integer(ip)         , pointer     :: p_cell_set_ids(:)
  
#ifdef ENABLE_P4EST
  environment    => this%get_environment()
  if( environment%get_l1_size() > 1 ) then
    cell_import    => this%get_cell_import()
    p_cell_set_ids => this%cell_set_ids%get_pointer()
    call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                              cell_import%get_neighbours_ids(), &
                                              cell_import%get_rcv_ptrs(),       &
                                              cell_import%get_rcv_leids(),      &
                                              cell_import%get_num_neighbours(), &
                                              cell_import%get_neighbours_ids(), &
                                              cell_import%get_snd_ptrs(),       &
                                              cell_import%get_snd_leids(),      &
                                              p_cell_set_ids, p_cell_set_ids )
  end if
#else
  call this%not_enabled_error()
#endif
  
end subroutine p4est_bt_comm_cell_set_ids

subroutine p4est_bt_update_vef_set_ids(this, old_lst_vefs_gids)
  implicit none
  class(p4est_base_triangulation_t), intent(inout)   :: this
  type(std_vector_integer_ip_t)      , intent(in)    :: old_lst_vefs_gids
  
  integer(ip) :: old_num_cells
  integer(ip) :: old_cell_id, new_cell_id, old_cell_base_pos
  integer(ip) :: transformation_flag
  integer(ip) :: num_corners
  integer(ip) :: ivef, iface, j, iedge
  integer(ip) :: old_vef_gid, old_vef_set_id
  type(p4est_cell_iterator_t) :: cell
  type(p4est_vef_iterator_t) :: vef
  
  type(list_t), pointer :: vertices_n_face
  type(list_iterator_t) :: vertices_x_n_face_iterator
  type(std_vector_integer_ip_t) :: old_proper_vefs_set_ids
  type(std_vector_integer_ip_t) :: old_improper_vefs_set_ids
  integer(ip), pointer :: FEMPAR_SUBCELLS_IN_TOUCH_FACE(:,:)
  integer(ip) :: NUM_SUBCELLS_IN_TOUCH_FACE
  integer(ip) :: num_edges_ref_elem_geo
  integer(ip) :: num_vefs, vef_lid
  integer(ip) :: i, base_pos_old
  type(cell_import_t) , pointer :: cell_import
  class(environment_t), pointer :: environment
  integer(ip), pointer :: p_old_vef_set_ids(:)

#ifdef ENABLE_P4EST    
  if (this%get_num_dims() == 2) then
    FEMPAR_SUBCELLS_IN_TOUCH_FACE => FEMPAR_SUBCELLS_IN_TOUCH_FACE_2D
    NUM_SUBCELLS_IN_TOUCH_FACE = NUM_SUBCELLS_IN_TOUCH_FACE_2D
    num_edges_ref_elem_geo = 0
  else
    FEMPAR_SUBCELLS_IN_TOUCH_FACE => FEMPAR_SUBCELLS_IN_TOUCH_FACE_3D
    NUM_SUBCELLS_IN_TOUCH_FACE = NUM_SUBCELLS_IN_TOUCH_FACE_3D
    num_edges_ref_elem_geo = this%reference_fe_geo%get_num_n_faces_of_dim(1)
  end if
  
  call old_proper_vefs_set_ids%copy(this%proper_vefs_set_ids)
  call old_improper_vefs_set_ids%copy(this%improper_vefs_set_ids)
  
  call this%clear_vef_set_ids()
  
  call cell%create(this)
  call vef%create(this)
  
  old_num_cells = this%previous_num_local_cells 
 
  vertices_n_face => this%reference_fe_geo%get_vertices_n_face()
  old_cell_id = 1
  new_cell_id = 1
  do while (old_cell_id <= old_num_cells)
    
    transformation_flag = this%refinement_and_coarsening_flags%get(old_cell_id)
    old_cell_base_pos   = this%get_ptr_vefs_x_cell(old_cell_id)
    
    call cell%set_gid(new_cell_id)
    
    if ( transformation_flag == do_nothing ) then
      do ivef=1, cell%get_num_vefs()
        call cell%get_vef(ivef,vef)
        old_vef_gid = old_lst_vefs_gids%get(old_cell_base_pos+ivef-1)
        old_vef_set_id = get_vef_set_id( old_vef_gid, old_proper_vefs_set_ids, old_improper_vefs_set_ids)
        call vef%set_set_id(old_vef_set_id)
      end do
      new_cell_id = new_cell_id + 1
      old_cell_id = old_cell_id+1
    else if ( transformation_flag == refinement ) then
      ! Transfer set_id's of coarse cell vertices from coarse to refined cells
      do j=1, this%reference_fe_geo%get_num_n_faces_of_dim(0) !num_children_x_cell 
        call cell%set_gid(new_cell_id+j-1)
        call cell%get_vef(j,vef)
        old_vef_gid = old_lst_vefs_gids%get(old_cell_base_pos+j-1)
        old_vef_set_id = get_vef_set_id( old_vef_gid, old_proper_vefs_set_ids, old_improper_vefs_set_ids)
        call vef%set_set_id(old_vef_set_id)
      end do

      if (this%get_num_dims() == 3) then
        do iedge=1, this%reference_fe_geo%get_num_n_faces_of_dim(1)
           ivef = this%reference_fe_geo%get_num_n_faces_of_dim(0)  + iedge
           do j=1, NUM_SUBCELLS_IN_TOUCH_EDGE_3D
              call cell%set_gid(new_cell_id + FEMPAR_SUBCELLS_IN_TOUCH_EDGE_3D(j,iedge)-1)
              call cell%get_vef(ivef,vef)
              old_vef_gid = old_lst_vefs_gids%get(old_cell_base_pos+ivef-1)
              old_vef_set_id = get_vef_set_id( old_vef_gid, old_proper_vefs_set_ids, old_improper_vefs_set_ids)
              call vef%set_set_id(old_vef_set_id)
           end do
           vertices_x_n_face_iterator = vertices_n_face%create_iterator(ivef)
           call cell%get_vef(vertices_x_n_face_iterator%get_current(),vef)
           old_vef_gid = old_lst_vefs_gids%get(old_cell_base_pos+ivef-1)
           old_vef_set_id = get_vef_set_id( old_vef_gid, old_proper_vefs_set_ids, old_improper_vefs_set_ids)
           call vef%set_set_id(old_vef_set_id)
        end do
      end if
      
      do iface=1, this%reference_fe_geo%get_num_facets()
         ivef = this%reference_fe_geo%get_num_n_faces_of_dim(0) + num_edges_ref_elem_geo  + iface
         do j=1, NUM_SUBCELLS_IN_TOUCH_FACE
            call cell%set_gid(new_cell_id + FEMPAR_SUBCELLS_IN_TOUCH_FACE(j,iface)-1)
            call cell%get_vef(ivef,vef)
            old_vef_gid = old_lst_vefs_gids%get(old_cell_base_pos+ivef-1)
            old_vef_set_id = get_vef_set_id( old_vef_gid, old_proper_vefs_set_ids, old_improper_vefs_set_ids)
            call vef%set_set_id(old_vef_set_id)
            if (this%get_num_dims() == 3) then
              iedge = FEMPAR_EDGE_OF_SUBCELLS_IN_TOUCH_FACE_3D(j,iface)
              call cell%get_vef(this%reference_fe_geo%get_num_n_faces_of_dim(0)+iedge,vef)
              call vef%set_set_id(old_vef_set_id)
            end if
         end do
         vertices_x_n_face_iterator = vertices_n_face%create_iterator(ivef)
         call cell%get_vef(vertices_x_n_face_iterator%get_current(),vef)
         old_vef_gid = old_lst_vefs_gids%get(old_cell_base_pos+ivef-1)
         old_vef_set_id = get_vef_set_id( old_vef_gid, old_proper_vefs_set_ids, old_improper_vefs_set_ids)
         call vef%set_set_id(old_vef_set_id)
      end do
      new_cell_id = new_cell_id + this%reference_fe_geo%get_num_n_faces_of_dim(0)
      old_cell_id = old_cell_id+1
    else if ( transformation_flag == coarsening ) then
      ! Transfer set_id's of refined cells vertices from refined to coarse cells
      do j=1, this%reference_fe_geo%get_num_n_faces_of_dim(0) ! (num_children_x_cell)
        call cell%get_vef(j,vef)
        old_vef_gid = old_lst_vefs_gids%get(old_cell_base_pos+ (j-1)*this%reference_fe_geo%get_num_n_faces() + j-1)
        old_vef_set_id = get_vef_set_id( old_vef_gid, old_proper_vefs_set_ids, old_improper_vefs_set_ids)
        call vef%set_set_id(old_vef_set_id)
      end do
      
      if (this%get_num_dims() == 3) then
        do iedge=1, this%reference_fe_geo%get_num_n_faces_of_dim(1)
           ivef = this%reference_fe_geo%get_num_n_faces_of_dim(0) + iedge
           call cell%get_vef(ivef,vef)
           ! The VEF set id of a edge in the coarse cell is extracted (arbitrarily) from
           ! the refined cell corresponding to its first sub-edge
           old_vef_gid = old_lst_vefs_gids%get(old_cell_base_pos+&
             (FEMPAR_SUBCELLS_IN_TOUCH_EDGE_3D(1,iedge)-1)*this%reference_fe_geo%get_num_n_faces() + ivef-1)
           old_vef_set_id = get_vef_set_id( old_vef_gid, old_proper_vefs_set_ids, old_improper_vefs_set_ids)
           call vef%set_set_id(old_vef_set_id)
        end do
      end if

      do iface=1, this%reference_fe_geo%get_num_facets()
         ivef = this%reference_fe_geo%get_num_n_faces_of_dim(0) + num_edges_ref_elem_geo  + iface
         call cell%get_vef(ivef,vef)
         ! The VEF set id of a face in the coarse cell is extracted (arbitrarily) from the refined cell corresponding to its first subface
         old_vef_gid = old_lst_vefs_gids%get(old_cell_base_pos+ (FEMPAR_SUBCELLS_IN_TOUCH_FACE(1,iface)-1)*this%reference_fe_geo%get_num_n_faces() + ivef-1)
         old_vef_set_id = get_vef_set_id( old_vef_gid, old_proper_vefs_set_ids, old_improper_vefs_set_ids)
         call vef%set_set_id(old_vef_set_id)
      end do
      old_cell_id = old_cell_id + this%reference_fe_geo%get_num_n_faces_of_dim(0)
      new_cell_id = new_cell_id+1
    else 
      assert(.false.)
    end if
  end do
  call old_proper_vefs_set_ids%free()
  call old_improper_vefs_set_ids%free()
  call cell%free()
  call vef%free()
#else
  call this%not_enabled_error()
#endif
contains
  function get_vef_set_id( vef_gid, proper_vefs_set_ids, improper_vefs_set_ids)
    implicit none
    integer(ip), intent(in) :: vef_gid
    type(std_vector_integer_ip_t), intent(in) :: proper_vefs_set_ids
    type(std_vector_integer_ip_t), intent(in) :: improper_vefs_set_ids
    integer(ip) :: get_vef_set_id
    if ( vef_gid > 0 ) then
        get_vef_set_id = proper_vefs_set_ids%get(vef_gid)
    else
        get_vef_set_id = improper_vefs_set_ids%get(abs(vef_gid))
    end if
  end function get_vef_set_id
end subroutine p4est_bt_update_vef_set_ids

subroutine p4est_bt_extract_local_cell_wise_vef_set_ids( this, cell_wise_vef_set_ids )
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  type(std_vector_integer_ip_t)    , intent(inout) :: cell_wise_vef_set_ids
  integer(ip) :: num_vefs
  integer(ip) :: vef_gid
  integer(ip) :: vef_set_id
  integer(ip) :: base_pos
  integer(ip) :: i, vef_lid
  num_vefs = this%get_ptr_vefs_x_cell(2)-this%get_ptr_vefs_x_cell(1)
  call cell_wise_vef_set_ids%resize(0)
  do i=1, this%get_num_local_cells()
      base_pos = this%get_ptr_vefs_x_cell(i)-1
      do vef_lid=1, num_vefs
        vef_gid = this%lst_vefs_gids%get(base_pos+vef_lid)
        if ( vef_gid > 0 ) then ! VEF is proper
          vef_set_id = this%proper_vefs_set_ids%get(vef_gid)
        else                    ! VEF is improper
          vef_set_id = this%improper_vefs_set_ids%get(abs(vef_gid))
        end if
        call cell_wise_vef_set_ids%push_back(vef_set_id)
      end do
  end do
  call cell_wise_vef_set_ids%resize(this%get_num_cells()*num_vefs)
end subroutine p4est_bt_extract_local_cell_wise_vef_set_ids
  
subroutine p4est_bt_fill_ghost_cells_from_cell_wise_vef_set_ids ( this, cell_wise_vef_set_ids ) 
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  type(std_vector_integer_ip_t)    , intent(in)    :: cell_wise_vef_set_ids
  integer(ip) :: num_vefs, vef_lid
  integer(ip) :: base_pos, vef_set_id
  integer(ip), pointer :: p_cell_wise_vef_set_ids(:)
  type(p4est_cell_iterator_t) :: cell
  type(p4est_vef_iterator_t)  :: vef
  if ( this%get_num_ghost_cells() > 0 ) then
    p_cell_wise_vef_set_ids => cell_wise_vef_set_ids%get_pointer()
    call cell%create(this)
    call vef%create(this)
    num_vefs = cell%get_num_vefs()
    call cell%set_gid(this%get_num_local_cells()+1)
    do while ( .not. cell%has_finished() )
      base_pos = this%get_ptr_vefs_x_cell(cell%get_gid())-1
      do vef_lid=1, num_vefs
        call cell%get_vef(vef_lid,vef)
        vef_set_id  = p_cell_wise_vef_set_ids(base_pos+vef_lid)
        call vef%set_set_id(vef_set_id)
      end do
      call cell%next()
    end do
    call cell%free()
    call vef%free()
  end if
end subroutine p4est_bt_fill_ghost_cells_from_cell_wise_vef_set_ids

subroutine p4est_bt_fill_local_cells_from_cell_wise_vef_set_ids ( this, cell_wise_vef_set_ids ) 
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  type(std_vector_integer_ip_t)    , intent(in)    :: cell_wise_vef_set_ids
  integer(ip) :: num_vefs, vef_lid
  integer(ip) :: base_pos, vef_set_id
  integer(ip), pointer :: p_cell_wise_vef_set_ids(:)
  type(p4est_cell_iterator_t) :: cell
  type(p4est_vef_iterator_t)  :: vef
  if ( this%get_num_local_cells() > 0 ) then
    p_cell_wise_vef_set_ids => cell_wise_vef_set_ids%get_pointer()
    call cell%create(this)
    call vef%create(this)
    num_vefs = cell%get_num_vefs()
    do while ( .not. cell%has_finished() )
      base_pos = this%get_ptr_vefs_x_cell(cell%get_gid())-1
      do vef_lid=1, num_vefs
        call cell%get_vef(vef_lid,vef)
        vef_set_id  = p_cell_wise_vef_set_ids(base_pos+vef_lid)
        call vef%set_set_id(vef_set_id)
      end do
      call cell%next()
    end do
    call cell%free()
    call vef%free()
  end if
end subroutine p4est_bt_fill_local_cells_from_cell_wise_vef_set_ids

subroutine p4est_bt_std_vector_transform_length_to_header(this,std_vector_integer_ip)
  implicit none
  class(p4est_base_triangulation_t), intent(in)    :: this
  type(std_vector_integer_ip_t)      , intent(inout) :: std_vector_integer_ip
  integer(ip) :: i
#ifdef ENABLE_P4EST    
  call std_vector_integer_ip%set(1,1)
  do i=1, std_vector_integer_ip%size()-1
    call std_vector_integer_ip%set(i+1,std_vector_integer_ip%get(i)+std_vector_integer_ip%get(i+1))
  end do
#else
  call this%not_enabled_error()
#endif      
end subroutine p4est_bt_std_vector_transform_length_to_header

subroutine p4est_bt_std_vector_transform_header_to_length(this,std_vector_integer_ip)
  implicit none
  class(p4est_base_triangulation_t), intent(in)    :: this
  type(std_vector_integer_ip_t)      , intent(inout) :: std_vector_integer_ip
  integer(ip) :: i
#ifdef ENABLE_P4EST    
  do i=std_vector_integer_ip%size(),2,-1 
    call std_vector_integer_ip%set(i,std_vector_integer_ip%get(i)-std_vector_integer_ip%get(i-1))
  end do
#else
  call this%not_enabled_error()
#endif      
end subroutine p4est_bt_std_vector_transform_header_to_length

subroutine p4est_bt_allocate_and_fill_x_cell_vertex_coordinates(this)
  implicit none
  class(p4est_base_triangulation_t), intent(inout)    :: this
  integer(ip) :: idime, icell, istat, num_corners, current, corner
  real(rp) :: vxyz(3)
  type(point_t), pointer :: raw_per_cell_vertex_coordinates(:)
  integer(ip) :: num_dims

  
#ifdef ENABLE_P4EST
  
  num_dims = this%get_num_dims()
  if ( num_dims == 2 ) then
    num_corners = NUM_CORNERS_2D
  else if ( num_dims == 3 ) then
    num_corners = NUM_CORNERS_3D
  end if
  call this%per_cell_vertex_coordinates%resize(0)
  call this%per_cell_vertex_coordinates%resize(this%get_num_cells()*num_corners)
  
  raw_per_cell_vertex_coordinates => this%per_cell_vertex_coordinates%get_pointer()
 
  current = 1 
  do icell=1, this%get_num_cells()
     do corner=0, num_corners-1
       if ( num_dims == 2 ) then
         call F90_p4est_get_quadrant_vertex_coordinates(this%p4est_connectivity,&
                                                        int(0,P4EST_F90_TOPIDX),&
                                                        this%quad_coords(1,icell),&
                                                        this%quad_coords(2,icell), &
                                                        this%quad_level(icell),&
                                                        corner,&
                                                        vxyz)
       else if ( num_dims == 3 ) then
         call F90_p8est_get_quadrant_vertex_coordinates(this%p4est_connectivity,&
                                                        int(0,P4EST_F90_TOPIDX),&
                                                        this%quad_coords(1,icell),&
                                                        this%quad_coords(2,icell), &
                                                        this%quad_coords(3,icell), &
                                                        this%quad_level(icell),&
                                                        corner,&
                                                        vxyz)
       end if
       call raw_per_cell_vertex_coordinates(current)%init(vxyz)
       current = current + 1 
     end do  
  end do
#else
  call this%not_enabled_error()
#endif        
end subroutine p4est_bt_allocate_and_fill_x_cell_vertex_coordinates

subroutine p4est_bt_clear_refinement_and_coarsening_flags(this)
  implicit none
  class(p4est_base_triangulation_t), intent(inout)    :: this
  integer(ip) :: istat
  class(environment_t), pointer :: environment
#ifdef ENABLE_P4EST
  environment => this%get_environment()
  if (environment%am_i_l1_task()) then
    call this%refinement_and_coarsening_flags%resize(0)
    call this%refinement_and_coarsening_flags%resize(this%get_num_cells(), do_nothing)
  end if
  this%clear_refinement_and_coarsening_flags_pending = .false.
#else
  call this%not_enabled_error()
#endif        
end subroutine p4est_bt_clear_refinement_and_coarsening_flags

subroutine p4est_bt_clear_cell_weights(this)
  implicit none
  class(p4est_base_triangulation_t), intent(inout)    :: this
  integer(ip) :: istat
  class(environment_t), pointer :: environment
#ifdef ENABLE_P4EST
  environment => this%get_environment()
  if (environment%am_i_l1_task()) then
    call this%cell_weights%resize(0)
    call this%cell_weights%resize(this%get_num_cells(), 1)
  end if  
#else
  call this%not_enabled_error()
#endif        
end subroutine p4est_bt_clear_cell_weights


subroutine p4est_bt_clear_cell_set_ids(this)
  implicit none
  class(p4est_base_triangulation_t), intent(inout)    :: this
  integer(ip) :: istat
  class(environment_t), pointer :: environment
#ifdef ENABLE_P4EST
  environment => this%get_environment()
  if (environment%am_i_l1_task()) then
    call this%cell_set_ids%resize(0)
    call this%cell_set_ids%resize(this%get_num_cells(), 1)
  end if  
#else
  call this%not_enabled_error()
#endif        
end subroutine p4est_bt_clear_cell_set_ids

subroutine p4est_bt_clear_vef_set_ids(this)
  implicit none
  class(p4est_base_triangulation_t), intent(inout)    :: this
  integer(ip) :: istat
  class(environment_t), pointer :: environment
#ifdef ENABLE_P4EST
  environment => this%get_environment()
  if (environment%am_i_l1_task()) then
    call this%proper_vefs_set_ids%resize(0)
    call this%proper_vefs_set_ids%resize(this%num_proper_vefs, 0)
    call this%improper_vefs_set_ids%resize(0)
    call this%improper_vefs_set_ids%resize(this%num_improper_vefs, 0)
  end if
#else
  call this%not_enabled_error()
#endif        
end subroutine p4est_bt_clear_vef_set_ids

subroutine p4est_bt_update_cell_import( this )
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  
  integer(ip) :: num_neighbours
  type(c_ptr) :: neighbour_ids
  type(c_ptr) :: rcv_ptrs
  type(c_ptr) :: rcv_leids
  type(c_ptr) :: snd_ptrs
  type(c_ptr) :: snd_leids
  
  integer(ip), pointer :: p_neighbour_ids(:)
  integer(ip), pointer :: p_rcv_ptrs(:)
  integer(ip), pointer :: p_rcv_leids(:)
  integer(ip), pointer :: p_snd_ptrs(:)
  integer(ip), pointer :: p_snd_leids(:)
  
  type(cell_import_t) , pointer :: cell_import
  class(environment_t), pointer :: environment

#ifdef ENABLE_P4EST  
  neighbour_ids = c_null_ptr
  rcv_ptrs  = c_null_ptr
  rcv_leids = c_null_ptr
  snd_ptrs  = c_null_ptr
  snd_leids = c_null_ptr
  if ( this%get_num_dims() == 2 ) then
    call F90_p4est_allocate_and_fill_cell_import_raw_arrays(this%p4est, &
                                                            this%p4est_ghost, &
                                                            num_neighbours, &
                                                            neighbour_ids, &
                                                            rcv_ptrs, &
                                                            rcv_leids, & 
                                                            snd_ptrs, &
                                                            snd_leids)    
  else if ( this%get_num_dims() == 3 ) then
    call F90_p8est_allocate_and_fill_cell_import_raw_arrays(this%p4est, &
                                                            this%p4est_ghost, &
                                                            num_neighbours, &
                                                            neighbour_ids, &
                                                            rcv_ptrs, &
                                                            rcv_leids, & 
                                                            snd_ptrs, &
                                                            snd_leids)   
  end if 
  
  call c_f_pointer(neighbour_ids, p_neighbour_ids, [num_neighbours]  )
  call c_f_pointer(rcv_ptrs     , p_rcv_ptrs     , [num_neighbours+1])
  call c_f_pointer(snd_ptrs     , p_snd_ptrs     , [num_neighbours+1])
  call c_f_pointer(rcv_leids    , p_rcv_leids    , [p_rcv_ptrs(num_neighbours+1)-1])
  call c_f_pointer(snd_leids    , p_snd_leids    , [p_snd_ptrs(num_neighbours+1)-1])
  
  cell_import => this%get_cell_import()
  environment => this%get_environment()
  call cell_import%create(environment%get_l1_rank()+1,&
                          environment%get_l1_size(),&
                          this%get_num_ghost_cells(), &
                          num_neighbours, &
                          p_neighbour_ids, &
                          p_rcv_ptrs, &
                          p_rcv_leids, &
                          p_snd_ptrs, &
                          p_snd_leids )
  
  call F90_p4est_locidx_buffer_destroy (neighbour_ids)
  call F90_p4est_locidx_buffer_destroy (rcv_ptrs)
  call F90_p4est_locidx_buffer_destroy (rcv_leids)
  call F90_p4est_locidx_buffer_destroy (snd_ptrs)
  call F90_p4est_locidx_buffer_destroy (snd_leids)
#else
  call this%not_enabled_error()
#endif          
end subroutine p4est_bt_update_cell_import


function p4est_bt_get_previous_num_local_cells ( this )
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip) :: p4est_bt_get_previous_num_local_cells
  p4est_bt_get_previous_num_local_cells = this%previous_num_local_cells
end function p4est_bt_get_previous_num_local_cells

function p4est_bt_get_previous_num_ghost_cells ( this )
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip) :: p4est_bt_get_previous_num_ghost_cells
  p4est_bt_get_previous_num_ghost_cells = this%previous_num_ghost_cells
end function p4est_bt_get_previous_num_ghost_cells

subroutine p4est_bt_allocate_and_gen_reference_fe_geo_scratch_data ( this) 
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  type(list_t), pointer :: dofs_n_face
  type(list_iterator_t) :: dofs_n_face_iterator
  integer(ip) :: num_n_faces
  integer(ip) :: current
  integer(ip) :: field_id, i 
  integer(ip) :: istat, icell
  
  call this%free_reference_fe_geo_scratch_data()
    
  dofs_n_face => this%reference_fe_geo%get_dofs_n_face()
  num_n_faces    = dofs_n_face%get_num_pointers()
  
  call memalloc ( num_n_faces+1, & 
                  this%ptr_dofs_n_face, __FILE__, __LINE__ ) 
   
  this%ptr_dofs_n_face(1) = 1
  do i=1, num_n_faces
     this%ptr_dofs_n_face(i+1) = this%ptr_dofs_n_face(i) + &
                                    dofs_n_face%get_sublist_size(i)
  end do
   
  call memalloc ( this%ptr_dofs_n_face(num_n_faces+1)-1, & 
                  this%lst_dofs_n_face, __FILE__, __LINE__ ) 
   
  current=1
  do i=1, dofs_n_face%get_num_pointers()
     dofs_n_face_iterator = this%reference_fe_geo%create_dofs_n_face_iterator(i)
     do while( .not. dofs_n_face_iterator%is_upper_bound() )
        this%lst_dofs_n_face(current) = dofs_n_face_iterator%get_current()
        current = current + 1
        call dofs_n_face_iterator%next()
     end do
  end do
  
end subroutine p4est_bt_allocate_and_gen_reference_fe_geo_scratch_data

subroutine p4est_bt_free_reference_fe_geo_scratch_data(this)
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  integer(ip) :: i, istat
  if ( allocated(this%ptr_dofs_n_face) ) then
    call memfree(this%ptr_dofs_n_face, __FILE__, __LINE__ )
  end if
  if ( allocated(this%lst_dofs_n_face) ) then
    call memfree(this%lst_dofs_n_face, __FILE__, __LINE__ )
  end if  
end subroutine p4est_bt_free_reference_fe_geo_scratch_data

subroutine p4est_bt_fill_cells_set (this, cells_set)
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  integer(ip)                        , intent(in)    :: cells_set(:)
  integer(ip)  :: i 
  integer(ip), pointer :: p_cell_set_ids(:)
  class(environment_t), pointer :: environment
  type(cell_import_t), pointer  :: cell_import 
#ifdef ENABLE_P4EST
  environment => this%get_environment()
  cell_import => this%get_cell_import() 
  if (environment%am_i_l1_task()) then
    assert ( size(cells_set) == this%get_num_local_cells() )
    do i=1, size(cells_set)
      call this%cell_set_ids%set(i,cells_set(i))
    end do
  end if
  call this%comm_cell_set_ids()
#else
  call this%not_enabled_error()
#endif        
end subroutine p4est_bt_fill_cells_set 

function p4est_bt_compute_max_cells_set_id (this)
  implicit none
  class(p4est_base_triangulation_t), intent(inout)   :: this
  integer(ip)                                        :: p4est_bt_compute_max_cells_set_id
  integer(ip)         , pointer :: p_cell_set_ids(:)
  class(environment_t), pointer :: environment 
  
  p_cell_set_ids => this%cell_set_ids%get_pointer()
  p4est_bt_compute_max_cells_set_id = maxval(p_cell_set_ids)
  
  environment => this%get_environment()
  call environment%l1_max(p4est_bt_compute_max_cells_set_id) 
      
end function p4est_bt_compute_max_cells_set_id 

subroutine p4est_bt_resize_disconnected_cells_set (this)
  implicit none
  class(p4est_base_triangulation_t), intent(inout)   :: this
   call this%disconnected_cells_set_ids%resize(0)
   call this%disconnected_cells_set_ids%resize(this%get_num_cells(),0)
end subroutine p4est_bt_resize_disconnected_cells_set

subroutine p4est_bt_fill_disconnected_cells_set (this, disconnected_cells_set)
  implicit none
  class(p4est_base_triangulation_t), intent(inout)   :: this
  integer(ip)                        , intent(in)    :: disconnected_cells_set(:)
  integer(ip)  :: i 
  integer(ip), pointer :: p_cell_set_ids(:)
  class(environment_t), pointer :: environment
  type(cell_import_t), pointer  :: cell_import 
#ifdef ENABLE_P4EST
  environment => this%get_environment()
  cell_import => this%get_cell_import() 
  if (environment%am_i_l1_task()) then
    assert ( size(disconnected_cells_set) <= this%disconnected_cells_set_ids%size())
    do i=1, this%get_num_local_cells()
    call this%disconnected_cells_set_ids%set(i, disconnected_cells_set(i) ) 
    end do 
    p_cell_set_ids => this%disconnected_cells_set_ids%get_pointer() 
    if(environment%get_l1_size()>1) &
    call environment%l1_neighbours_exchange (cell_import%get_num_neighbours(),    &
                                             cell_import%get_neighbours_ids(),    &
                                             cell_import%get_rcv_ptrs(),          &
                                             cell_import%get_rcv_leids(),         &
                                             cell_import%get_num_neighbours(),    &
                                             cell_import%get_neighbours_ids(),    &
                                             cell_import%get_snd_ptrs(),          &
                                             cell_import%get_snd_leids(),         &
                                             p_cell_set_ids,                      & 
                                             p_cell_set_ids)
  end if
#else
  call this%not_enabled_error()
#endif        
end subroutine p4est_bt_fill_disconnected_cells_set

subroutine p4est_base_triangulation_update_p4est_mesh(this)
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
#ifdef ENABLE_P4EST
  if ( this%get_num_dims() == 2 ) then
    call F90_p4est_mesh_new(this%k_ghost_cells, this%p4est, this%p4est_ghost, this%p4est_mesh)
  else if ( this%get_num_dims() == 3 ) then
    call F90_p8est_mesh_new(this%k_ghost_cells, this%p4est, this%p4est_ghost, this%p4est_mesh)
  end if
#else
  call this%not_enabled_error()
#endif   
end subroutine p4est_base_triangulation_update_p4est_mesh

subroutine p4est_base_triangulation_update_topology_from_p4est_mesh(this)
 implicit none 
 class(p4est_base_triangulation_t), intent(inout) :: this
 integer(P4EST_F90_LOCIDX) :: local_num_quadrants
 integer(P4EST_F90_LOCIDX) :: ghost_num_quadrants
 integer(P4EST_F90_GLOIDX) :: global_num_quadrants
 integer(P4EST_F90_LOCIDX) :: num_half_faces
 integer(P4EST_F90_LOCIDX) :: num_half_edges
 type(c_ptr) :: QQ, QF, QH, QC, QQE, QE
 integer(ip) :: i
 class(environment_t), pointer :: environment
#ifdef ENABLE_P4EST
 
 if (allocated(this%global_first_quadrant)) then
   call memfree(this%global_first_quadrant, __FILE__, __LINE__ )
 end if
 
 environment => this%get_environment()
 call memalloc(environment%get_l1_size()+1, &
               this%global_first_quadrant, &
               __FILE__, __LINE__ )
 this%global_first_quadrant = 0
 
 if (allocated(this%quad_coords)) &
     call memfree(this%quad_coords, __FILE__, __LINE__)
  
  if (allocated(this%quad_level)) &
    call memfree(this%quad_level, __FILE__, __LINE__)
 
 if ( this%get_num_dims() == 2 ) then
  call F90_p4est_get_mesh_info(this%p4est, &
                               this%p4est_mesh, &
                               local_num_quadrants, &
                               ghost_num_quadrants, &
                               global_num_quadrants, &
                               this%global_first_quadrant, &
                               num_half_faces)
  
  call memalloc(2, local_num_quadrants+ghost_num_quadrants, this%quad_coords, __FILE__, __LINE__)
  call memalloc(local_num_quadrants+ghost_num_quadrants, this%quad_level, __FILE__, __LINE__ )
  
  QQ = c_null_ptr
  QF = c_null_ptr
  QH = c_null_ptr
  QC = c_null_ptr
  call F90_p4est_get_mesh_topology_arrays(this%p4est, &
                                          this%p4est_mesh, &
                                          this%p4est_ghost, &
                                          QQ, &
                                          QF, &
                                          QH, &
                                          QC, &
                                          this%quad_coords, &
                                          this%quad_level)
  
  if (associated(this%quad_to_quad))   deallocate(this%quad_to_quad)
  if (associated(this%quad_to_face))   deallocate(this%quad_to_face)
  if (associated(this%quad_to_half))   deallocate(this%quad_to_half)
  if (associated(this%quad_to_corner)) deallocate(this%quad_to_corner)

  call c_f_pointer(qq,this%quad_to_quad,[NUM_FACES_2D,local_num_quadrants])
  call c_f_pointer(qf,this%quad_to_face,[NUM_FACES_2D,local_num_quadrants])
  if(num_half_faces>0) then 
    call c_f_pointer(qh,this%quad_to_half,[NUM_SUBFACES_FACE_2D,num_half_faces])
  else
    nullify(this%quad_to_half)
  end if 
  call c_f_pointer(qc,this%quad_to_corner,[NUM_CORNERS_2D,local_num_quadrants])
 else if ( this%get_num_dims() == 3 ) then
  call F90_p8est_get_mesh_info(this%p4est, &
                               this%p4est_mesh, &
                               local_num_quadrants, &
                               ghost_num_quadrants, &
                               global_num_quadrants, &
                               this%global_first_quadrant, &
                               num_half_faces)
 
  if (allocated(this%quad_to_quad_by_edge)) &
    call memfree(this%quad_to_quad_by_edge, __FILE__, __LINE__)

  if (allocated(this%quad_to_edge)) &
    call memfree(this%quad_to_edge, __FILE__, __LINE__)
  
  call memalloc(3, local_num_quadrants+ghost_num_quadrants, this%quad_coords, __FILE__, __LINE__)
  call memalloc(local_num_quadrants+ghost_num_quadrants, this%quad_level, __FILE__, __LINE__ )
  call memalloc(NUM_EDGES_3D,local_num_quadrants, this%quad_to_quad_by_edge, __FILE__, __LINE__ )
  call memalloc(NUM_EDGES_3D,local_num_quadrants, this%quad_to_edge, __FILE__, __LINE__ )
  
  QQ  = c_null_ptr
  QF  = c_null_ptr
  QH  = c_null_ptr
  QC  = c_null_ptr
  call F90_p8est_get_mesh_topology_arrays(this%p4est, &
                                          this%p4est_mesh, &
                                          this%p4est_ghost, &
                                          QQ, &
                                          QF, &
                                          QH, &
                                          this%quad_to_quad_by_edge,&
                                          this%quad_to_edge,&
                                          num_half_edges,&
                                          this%QHE,&
                                          QC, &
                                          this%quad_coords, &
                                          this%quad_level)
  
  if (associated(this%quad_to_quad))   deallocate(this%quad_to_quad)
  if (associated(this%quad_to_face))   deallocate(this%quad_to_face)
  if (associated(this%quad_to_half))   deallocate(this%quad_to_half)
  if (associated(this%quad_to_corner)) deallocate(this%quad_to_corner)
  if (associated(this%quad_to_half_by_edge)) deallocate(this%quad_to_half_by_edge) 
  
  call c_f_pointer(qq,this%quad_to_quad,[NUM_FACES_3D,local_num_quadrants])
  call c_f_pointer(qf,this%quad_to_face,[NUM_FACES_3D,local_num_quadrants])
  if(num_half_faces>0) then 
    call c_f_pointer(qh,this%quad_to_half,[NUM_SUBFACES_FACE_3D,num_half_faces])
  else
    nullify(this%quad_to_half)
  end if   
  call c_f_pointer(qc,this%quad_to_corner,[NUM_CORNERS_3D,local_num_quadrants])
  if(num_half_edges>0) then 
    call c_f_pointer(this%QHE,this%quad_to_half_by_edge,[NUM_SUBEDGES_EDGE_3D,num_half_edges])
  else
    nullify(this%quad_to_half_by_edge)
  end if   
 end if
 
  this%previous_num_local_cells = this%get_num_local_cells()
  this%previous_num_ghost_cells = this%get_num_ghost_cells()
 
  ! Update the num of triangulation cells
  call this%set_num_global_cells(int(global_num_quadrants,igp))
  call this%set_num_local_cells(local_num_quadrants)
  call this%set_num_ghost_cells(ghost_num_quadrants)
#else
  call this%not_enabled_error()
#endif
end subroutine p4est_base_triangulation_update_topology_from_p4est_mesh

subroutine p4est_bt_extend_p4est_topology_arrays_to_ghost_cells(this)
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
#ifdef ENABLE_P4EST
  integer(ip), pointer :: quad_to_quad(:,:)
  integer(P4EST_F90_QLEVEL), pointer :: quad_to_face(:,:)
  integer(ip), pointer :: quad_to_half(:,:)
  integer(ip), pointer :: quad_to_corner(:,:)
  integer(ip), pointer :: quad_to_half_by_edge(:,:)
  integer(ip), allocatable :: quad_to_quad_by_edge(:,:)
  integer(P4EST_F90_QLEVEL), allocatable :: quad_to_edge(:,:)
  integer(ip) :: num_corners_x_cell, num_edges_x_cell, num_faces_x_cell
  integer(ip) :: num_subfacets_facet
  integer(ip) :: num_subedgets_edget
  integer(ip) :: icell, iface, icorner, jcell, jcell_iface, iedge, jcell_iedge
  integer(ip) :: flip, mortar, icell_iface
  integer(ip) :: isubedge, isubface
  integer(ip) :: i,j,k,l,m
  integer(P4EST_F90_QLEVEL) :: jcell_iconn
  class(environment_t), pointer :: environment
  class(execution_context_t), pointer :: l1_context
  class(cell_import_t), pointer :: cell_import 
  
  integer(igp)             , allocatable :: quad_to_quad_buffer(:)
  integer(ip)              , allocatable :: quad_to_face_buffer(:)
  integer(igp)             , allocatable :: quad_to_half_buffer(:)
  integer(igp)             , allocatable :: quad_to_corner_buffer(:)
  integer(ip)              , allocatable :: num_half_faces_x_neighbour(:)
  type(allocatable_array_igp1_t), allocatable :: quad_to_half_buffers(:)
  
  integer(igp)             , allocatable :: quad_to_quad_by_edge_buffer(:)
  integer(ip)              , allocatable :: quad_to_edge_buffer(:)
  integer(igp)             , allocatable :: quad_to_half_by_edge_buffer(:)
  integer(ip)              , allocatable :: num_half_edges_x_neighbour(:)
  type(allocatable_array_igp1_t), allocatable :: quad_to_half_by_edge_buffers(:)
  
  
  integer :: status(MPI_STATUS_SIZE)
  integer :: ierr
  integer(ip), pointer :: neighbours_ids(:)
  
  integer(ip) :: istat 
  integer(ip) :: quad_to_half_size_1
  integer(ip) :: quad_to_half_size_2
  integer(ip) :: quad_to_half_by_edge_size_1
  integer(ip) :: quad_to_half_by_edge_size_2
  type(std_vector_integer_ip_t), allocatable :: extra_cols_quad_to_half(:)
  type(std_vector_integer_ip_t), allocatable :: extra_cols_quad_to_half_by_edge(:)
  integer(ip) :: num_half_edges, num_half_faces
  integer(ip) :: current
  type(hash_table_igp_ip_t) :: g2l_map
  integer(ip) :: part_id, neighbour_id
  logical :: local_or_ghost_found
  integer(ip) :: num_itfc_half_faces
  logical, allocatable :: local_cell_is_at_interface(:)
  integer(ip), pointer :: snd_leids(:)
  type(std_vector_integer_ip_t) :: itfc_half_faces
  integer(ip) :: num_itfc_half_edges
  type(std_vector_integer_ip_t) :: itfc_half_edges
 
  if ( this%get_num_dims() == 2 ) then
     num_corners_x_cell    =  NUM_CORNERS_2D
     num_edges_x_cell      =  0
     num_faces_x_cell      =  NUM_FACES_2D
     num_subfacets_facet   =  NUM_SUBFACES_FACE_2D
  else if ( this%get_num_dims() == 3 ) then
     num_corners_x_cell      =  NUM_CORNERS_3D
     num_edges_x_cell        =  NUM_EDGES_3D
     num_faces_x_cell        =  NUM_FACES_3D
     num_subfacets_facet     =  NUM_SUBFACES_FACE_3D
     num_subedgets_edget     =  NUM_SUBEDGES_EDGE_3D
  end if
  
  ! Generate data for local cells on the interface
  call memalloc ( num_faces_x_cell*this%get_num_cells(), quad_to_quad_buffer, __FILE__, __LINE__ )
  quad_to_quad_buffer   = -1_igp
  call memalloc ( num_faces_x_cell*this%get_num_cells(), quad_to_face_buffer, __FILE__, __LINE__ )
  quad_to_face_buffer   = -1_ip
  call memalloc ( num_corners_x_cell*this%get_num_cells(), quad_to_corner_buffer, __FILE__, __LINE__ )
  quad_to_corner_buffer = -1_igp
    
  if ( this%get_num_dims() == 3 ) then
     call memalloc ( num_edges_x_cell*this%get_num_cells(), quad_to_quad_by_edge_buffer, __FILE__, __LINE__ )
     quad_to_quad_by_edge_buffer   = -1_igp
     call memalloc ( num_edges_x_cell*this%get_num_cells(), quad_to_edge_buffer, __FILE__, __LINE__ )
     quad_to_edge_buffer   = -1_ip
  end if
  
  call memalloc ( this%get_num_local_cells(), local_cell_is_at_interface, __FILE__, __LINE__ ) 
  local_cell_is_at_interface = .false. 
  
  cell_import => this%get_cell_import()
  snd_leids   => cell_import%get_snd_leids()
  do j=1, size(snd_leids)
    local_cell_is_at_interface(snd_leids(j)) = .true.
  end do
  
  j=1
  k=1
  l=1
  num_itfc_half_faces = 0
  num_itfc_half_edges = 0
  do icell=1, this%get_num_local_cells()
     do iface=1, num_faces_x_cell
      jcell_iconn = this%quad_to_face(iface,icell)
      if (this%get_num_dims() == 2) then
        call p4est_eval_connectivity(jcell_iconn, jcell_iface, flip, mortar)
      elseif (this%get_num_dims() == 3) then
        call p8est_eval_connectivity(jcell_iconn, jcell_iface, flip, mortar)
      else
        check(.false.)
      end if
      assert (flip==1) ! All cells we are working with MUST be aligned with each other
      if (mortar == -1) then ! Conformal neighbour  
        quad_to_quad_buffer(j) = this%cell_ggids%get(this%quad_to_quad(iface,icell)+1)
      else if ( mortar >= 1 .and. mortar <= num_subfacets_facet )  then ! Double-size neighbour 
        quad_to_quad_buffer(j) = this%cell_ggids%get(this%quad_to_quad(iface,icell)+1)
      else
        if ( local_cell_is_at_interface(icell) ) then
          num_itfc_half_faces = num_itfc_half_faces+1
          call itfc_half_faces%push_back(this%quad_to_quad(iface,icell)+1)
          quad_to_quad_buffer(j) = num_itfc_half_faces
        else
          quad_to_quad_buffer(j) = this%quad_to_quad(iface,icell)+1
        end if   
      end if 
      quad_to_face_buffer(j) = this%quad_to_face(iface,icell)
      j=j+1 
     end do 
     
     if ( this%get_num_dims() == 3 ) then
       do iedge=1, num_edges_x_cell
         if (this%quad_to_quad_by_edge(iedge,icell) >= 0 ) then
           jcell_iconn = this%quad_to_edge(iedge,icell)
           call p8est_eval_edge_connectivity(jcell_iconn, jcell_iedge, flip, mortar)
         
           assert (flip==1) ! All cells we are working with MUST be aligned with each other
           if (mortar == -1) then ! Conformal neighbour  
             quad_to_quad_by_edge_buffer(l) = this%cell_ggids%get(this%quad_to_quad_by_edge(iedge,icell)+1)
           else if ( mortar >= 1 .and. mortar <= num_subedgets_edget )  then ! Double-size neighbour 
             quad_to_quad_by_edge_buffer(l) = this%cell_ggids%get(this%quad_to_quad_by_edge(iedge,icell)+1)
           else
             if ( local_cell_is_at_interface(icell) ) then
               num_itfc_half_edges = num_itfc_half_edges +1
               call itfc_half_edges%push_back(this%quad_to_quad_by_edge(iedge,icell)+1)
               quad_to_quad_by_edge_buffer(l) = num_itfc_half_edges
             else
               quad_to_quad_by_edge_buffer(l) = this%quad_to_quad_by_edge(iedge,icell)+1
             end if
           end if 
           quad_to_edge_buffer(l) = this%quad_to_edge(iedge,icell) 
         end if 
         l=l+1 
       end do 
     end if 
    
     do icorner=1, num_corners_x_cell
       if ( this%quad_to_corner(icorner,icell) < 0 ) then
         quad_to_corner_buffer(k) = -1_igp
       else
         quad_to_corner_buffer(k) = this%cell_ggids%get(this%quad_to_corner(icorner,icell)+1)
       end if
       k=k+1
     end do
  end do  
  call memfree ( local_cell_is_at_interface, __FILE__, __LINE__ ) 

  if ( associated(this%quad_to_half) ) then
    quad_to_half_size_1 = size(this%quad_to_half,1)
    quad_to_half_size_2 = num_itfc_half_faces
  else
    quad_to_half_size_1 = 0_ip
    quad_to_half_size_2 = 0_ip
  end if
  
  call memalloc ( quad_to_half_size_1*quad_to_half_size_2, quad_to_half_buffer, __FILE__, __LINE__ )
  quad_to_half_buffer = -1_igp
  
  j=1
  do i=1, num_itfc_half_faces
    do isubface=1, quad_to_half_size_1
      quad_to_half_buffer(j) = this%cell_ggids%get(this%quad_to_half(isubface,itfc_half_faces%get(i))+1) 
      j=j+1
    end do 
  end do
  call itfc_half_faces%free()
  
  if ( this%get_num_dims() == 3 ) then
    if ( associated(this%quad_to_half_by_edge) ) then
     quad_to_half_by_edge_size_1 = size(this%quad_to_half_by_edge,1)
     quad_to_half_by_edge_size_2 = num_itfc_half_edges
    else
     quad_to_half_by_edge_size_1 = 0_ip
     quad_to_half_by_edge_size_2 = 0_ip
    end if
     
    call memalloc ( quad_to_half_by_edge_size_1*quad_to_half_by_edge_size_2, quad_to_half_by_edge_buffer, __FILE__, __LINE__ )
    quad_to_half_by_edge_buffer = -1_igp  
  
    j=1
    do i=1, quad_to_half_by_edge_size_2
      do isubedge=1, quad_to_half_by_edge_size_1
        quad_to_half_by_edge_buffer(j) = this%cell_ggids%get(this%quad_to_half_by_edge(isubedge,itfc_half_edges%get(i))+1) 
        j=j+1
      end do 
    end do
  end if
  
  environment => this%get_environment()
  cell_import => this%get_cell_import()
  call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_rcv_ptrs(),&
                                            cell_import%get_rcv_leids(),&
                                            cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_snd_ptrs(),&
                                            cell_import%get_snd_leids(),&
                                            quad_to_quad_buffer, & 
                                            quad_to_quad_buffer, &
                                            num_faces_x_cell ) 

  call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_rcv_ptrs(),&
                                            cell_import%get_rcv_leids(),&
                                            cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_snd_ptrs(),&
                                            cell_import%get_snd_leids(),&
                                            quad_to_face_buffer, &
                                            quad_to_face_buffer, &
                                            num_faces_x_cell )
  
  if ( this%get_num_dims() == 3 ) then
    call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                              cell_import%get_neighbours_ids(),&
                                              cell_import%get_rcv_ptrs(),&
                                              cell_import%get_rcv_leids(),&
                                              cell_import%get_num_neighbours(), &
                                              cell_import%get_neighbours_ids(),&
                                              cell_import%get_snd_ptrs(),&
                                              cell_import%get_snd_leids(),&
                                              quad_to_quad_by_edge_buffer, &
                                              quad_to_quad_by_edge_buffer, &
                                              num_edges_x_cell )
    
    call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                              cell_import%get_neighbours_ids(),&
                                              cell_import%get_rcv_ptrs(),&
                                              cell_import%get_rcv_leids(),&
                                              cell_import%get_num_neighbours(), &
                                              cell_import%get_neighbours_ids(),&
                                              cell_import%get_snd_ptrs(),&
                                              cell_import%get_snd_leids(),&
                                              quad_to_edge_buffer, &
                                              quad_to_edge_buffer, &
                                              num_edges_x_cell )
  end if 

  
  call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_rcv_ptrs(),&
                                            cell_import%get_rcv_leids(),&
                                            cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_snd_ptrs(),&
                                            cell_import%get_snd_leids(),&
                                            quad_to_corner_buffer, &
                                            quad_to_corner_buffer, &
                                            num_corners_x_cell )

  call memalloc ( cell_import%get_num_neighbours(), num_half_faces_x_neighbour, __FILE__, __LINE__ ) 

  neighbours_ids => cell_import%get_neighbours_ids() 
  l1_context     => environment%get_l1_context()
  call l1_context%neighbours_exchange(cell_import%get_num_neighbours(), &
                                      neighbours_ids, &
                                      quad_to_half_size_2, &
                                      num_half_faces_x_neighbour)
  
  allocate ( quad_to_half_buffers(cell_import%get_num_neighbours()), stat=istat); check(istat==0); 
  do i=1, cell_import%get_num_neighbours()
    call quad_to_half_buffers(i)%create(num_subfacets_facet*num_half_faces_x_neighbour(i))
  end do 
  
  select type ( l1_context )
   class is (mpi_context_t)
     call l1_context%neighbours_exchange_multiple_igp ( cell_import%get_num_neighbours(), &
       &                             neighbours_ids, &
       &                             size(quad_to_half_buffer), &
       &                             quad_to_half_buffer,&
       &                             num_subfacets_facet*num_half_faces_x_neighbour,&
       &                             quad_to_half_buffers)
   class is (serial_context_t)
   class default
    check(.false.)
  end select
  
  if ( this%get_num_dims() == 3 ) then
    call memalloc ( cell_import%get_num_neighbours(), num_half_edges_x_neighbour, __FILE__, __LINE__ ) 

    neighbours_ids => cell_import%get_neighbours_ids() 
    l1_context     => environment%get_l1_context()
    
    call l1_context%neighbours_exchange(cell_import%get_num_neighbours(), &
                                        neighbours_ids, &
                                        quad_to_half_by_edge_size_2, &
                                        num_half_edges_x_neighbour)
    
    allocate ( quad_to_half_by_edge_buffers(cell_import%get_num_neighbours()), stat=istat); check(istat==0); 
    do i=1, cell_import%get_num_neighbours() 
      call quad_to_half_by_edge_buffers(i)%create(num_subedgets_edget*num_half_edges_x_neighbour(i))
    end do
    select type ( l1_context )
     class is (mpi_context_t)
       call l1_context%neighbours_exchange_multiple_igp ( cell_import%get_num_neighbours(), &
          &                             neighbours_ids, &
          &                             size(quad_to_half_by_edge_buffer), &
          &                             quad_to_half_by_edge_buffer,&
          &                             num_subedgets_edget*num_half_edges_x_neighbour,&
          &                             quad_to_half_by_edge_buffers)
     class is (serial_context_t)
     class default
      check(.false.)
    end select
    
  end if 
 

  allocate ( quad_to_quad(num_faces_x_cell    , this%get_num_cells()), stat=istat); check(istat==0);
  allocate ( quad_to_face(num_faces_x_cell    , this%get_num_cells()), stat=istat); check(istat==0);
  allocate ( quad_to_corner(num_corners_x_cell, this%get_num_cells()), stat=istat); check(istat==0);
  allocate(extra_cols_quad_to_half(num_subfacets_facet), stat=istat); check(istat==0);
  
  if ( this%get_num_dims() == 3 ) then
    call memalloc ( num_edges_x_cell, this%get_num_cells(), quad_to_quad_by_edge, __FILE__, __LINE__ )
    call memalloc ( num_edges_x_cell, this%get_num_cells(), quad_to_edge        , __FILE__, __LINE__ )
    allocate(extra_cols_quad_to_half_by_edge(num_subedgets_edget), stat=istat); check(istat==0);
  end if
  
  quad_to_quad  (1:num_faces_x_cell  , this%get_num_local_cells()+1:this%get_num_cells()) = -1
  quad_to_face  (1:num_faces_x_cell  , this%get_num_local_cells()+1:this%get_num_cells()) = -1 
  quad_to_corner(1:num_corners_x_cell, this%get_num_local_cells()+1:this%get_num_cells()) = -1
  
  do j = 1, this%get_num_local_cells()
    do i = 1, num_faces_x_cell
      quad_to_quad(i,j) = this%quad_to_quad(i,j)
      quad_to_face(i,j) = this%quad_to_face(i,j)
    end do
    do i = 1, num_corners_x_cell
      quad_to_corner(i,j) = this%quad_to_corner(i,j)
    end do
  end do
  
  if ( this%get_num_dims() == 3 ) then
    quad_to_quad_by_edge(1:num_edges_x_cell, this%get_num_local_cells()+1:this%get_num_cells()) = -1
    quad_to_edge        (1:num_edges_x_cell, this%get_num_local_cells()+1:this%get_num_cells()) = -1
    do j = 1, this%get_num_local_cells()
      do i = 1, num_edges_x_cell
        quad_to_quad_by_edge(i,j) = this%quad_to_quad_by_edge(i,j)
        quad_to_edge(i,j)         = this%quad_to_edge(i,j)
      end do
    end do
  end if 
  
  
  ! 1. Generate global to local map
  ! The numbering scheme of cell GGIDs in p4est is s.t.
  ! all local cells in a processor's subdomain get consecutive
  ! cell GGIDs. Thus, if we select the size of the hash table
  ! to be the number of cells in a processor's subdomain we thus
  ! may only have hash table conflict in ghost cells, at the expense
  ! of consuming (temporary) memory on the order of local+ghost cells 
  call g2l_map%init(this%get_num_cells())
  do icell=1, this%get_num_cells()
    call g2l_map%put(key=this%cell_ggids%get(icell), val=icell, stat=istat)
    assert ( istat == now_stored )
  end do 

  if (associated(this%quad_to_half)) then 
    num_half_faces=size(this%quad_to_half,2)
  else
    num_half_faces=0
  end if 
  
  if ( this%get_num_dims() == 3 ) then
    if (associated(this%quad_to_half_by_edge)) then 
      num_half_edges=size(this%quad_to_half_by_edge,2)
    else
      num_half_edges=0
    end if
    m=(this%get_num_local_cells())*num_edges_x_cell+1
  end if 
  
  ! 2. Go over ghost cells and fill quad_to_quad, quad_to_face, quad_to_corner, while 
  !    counting/registering extra half_num_faces 
  j=(this%get_num_local_cells())*num_faces_x_cell+1
  l=(this%get_num_local_cells())*num_corners_x_cell+1
  do icell=1, this%get_num_ghost_cells()
     do iface=1, num_faces_x_cell
      jcell_iconn = quad_to_face_buffer(j)
      if (this%get_num_dims() == 2) then
        call p4est_eval_connectivity(jcell_iconn, jcell_iface, flip, mortar)
      elseif (this%get_num_dims() == 3) then
        call p8est_eval_connectivity(jcell_iconn, jcell_iface, flip, mortar)
      else
        check(.false.)
      end if
      assert (flip==1) ! All cells we are working with MUST be aligned with each other
      if (mortar == -1) then ! Conformal neighbour  
        call g2l_map%get(key=quad_to_quad_buffer(j), val=jcell, stat=istat)
        if ( istat == key_found ) then
          quad_to_quad(iface,icell+this%get_num_local_cells()) = jcell-1 
          quad_to_face(iface,icell+this%get_num_local_cells()) = quad_to_face_buffer(j)
        end if
      else if ( mortar >= 1 .and. mortar <= num_subfacets_facet )  then ! Double-size neighbour 
        call g2l_map%get(key=quad_to_quad_buffer(j), val=jcell, stat=istat)
        if ( istat == key_found ) then
          quad_to_quad(iface,icell+this%get_num_local_cells()) = jcell-1 
          quad_to_face(iface,icell+this%get_num_local_cells()) = quad_to_face_buffer(j)
        end if
      else ! Half_size neighbour
        part_id      = this%cell_myparts%get(icell+this%get_num_local_cells())
        neighbour_id = cell_import%get_local_neighbour_id(part_id)
       
        local_or_ghost_found = .false.
        do isubface=1, num_subfacets_facet
          k = (quad_to_quad_buffer(j)-1)*num_subfacets_facet + isubface
          call g2l_map%get(key=quad_to_half_buffers(neighbour_id)%a(k), val=jcell, stat=istat)
          if ( istat == key_found ) then
            local_or_ghost_found = .true.
            num_half_faces = num_half_faces+1
            quad_to_quad(iface,icell+this%get_num_local_cells()) = num_half_faces-1
            quad_to_face(iface,icell+this%get_num_local_cells()) = quad_to_face_buffer(j)
            exit 
          end if
        end do  

        if (local_or_ghost_found) then
          do isubface=1, num_subfacets_facet
            k = (quad_to_quad_buffer(j)-1)*num_subfacets_facet + isubface
            call g2l_map%get(key=quad_to_half_buffers(neighbour_id)%a(k), val=jcell, stat=istat)
            if ( istat == key_found ) then
              call extra_cols_quad_to_half(isubface)%push_back(jcell-1)
            else
              call extra_cols_quad_to_half(isubface)%push_back(-1)
            end if
          end do 
        end if
      end if 
      j=j+1 
     end do 
     
     if ( this%get_num_dims() == 3 ) then
       do iedge=1, num_edges_x_cell
        if ( quad_to_quad_by_edge_buffer(m) >=0 ) then   
         jcell_iconn = quad_to_edge_buffer(m)
         call p8est_eval_edge_connectivity(jcell_iconn, jcell_iedge, flip, mortar)
         
         assert (flip==1) ! All cells we are working with MUST be aligned with each other
         if (mortar == -1) then ! Conformal neighbour  
           call g2l_map%get(key=quad_to_quad_by_edge_buffer(m), val=jcell, stat=istat)
           if ( istat == key_found ) then
             quad_to_quad_by_edge(iedge,icell+this%get_num_local_cells()) = jcell-1 
             quad_to_edge        (iedge,icell+this%get_num_local_cells()) = quad_to_edge_buffer(m)
           else
             ! A conformal edge neighbour exists in the global octree, however not in the local
             ! portion of this processor. We signal this scenario differently as p4est_bt_update_lst_vefs_gids_and_cells_around
             ! requires in 3D to determine whether a hanging edge is either hanging on an coarser edge or face
             quad_to_quad_by_edge(iedge,icell+this%get_num_local_cells()) = -2
           end if
         else if ( mortar >= 1 .and. mortar <= num_subedgets_edget )  then ! Double-size neighbour 
           call g2l_map%get(key=quad_to_quad_by_edge_buffer(m), val=jcell, stat=istat)
           if ( istat == key_found ) then
             quad_to_quad_by_edge(iedge,icell+this%get_num_local_cells()) = jcell-1 
             quad_to_edge        (iedge,icell+this%get_num_local_cells()) = quad_to_edge_buffer(m)
           else 
             ! A double-size edge neighbour exists in the global octree, however not in the local
             ! portion of this processor. We signal this scenario differently as p4est_bt_update_lst_vefs_gids_and_cells_around
             ! requires in 3D to determine whether a hanging edge is either hanging on an coarser edge or face
             quad_to_quad_by_edge(iedge,icell+this%get_num_local_cells()) = -2
           end if
         else ! Half_size neighbour
           part_id      = this%cell_myparts%get(icell+this%get_num_local_cells())
           neighbour_id = cell_import%get_local_neighbour_id(part_id)
       
           local_or_ghost_found = .false.
           do isubedge=1, num_subedgets_edget
             k = (quad_to_quad_by_edge_buffer(m)-1)*num_subedgets_edget + isubedge
             call g2l_map%get(key=quad_to_half_by_edge_buffers(neighbour_id)%a(k), val=jcell, stat=istat)
             if ( istat == key_found ) then
               local_or_ghost_found = .true.
               num_half_edges = num_half_edges+1
               quad_to_quad_by_edge(iedge,icell+this%get_num_local_cells()) = num_half_edges-1
               quad_to_edge        (iedge,icell+this%get_num_local_cells()) = quad_to_edge_buffer(m)
               exit 
             end if
           end do 

           if (local_or_ghost_found) then
            do isubedge=1, num_subedgets_edget
             k = (quad_to_quad_by_edge_buffer(m)-1)*num_subedgets_edget + isubedge
             call g2l_map%get(key=quad_to_half_by_edge_buffers(neighbour_id)%a(k), val=jcell, stat=istat)
             if ( istat == key_found ) then
              call extra_cols_quad_to_half_by_edge(isubedge)%push_back(jcell-1)
             else
              call extra_cols_quad_to_half_by_edge(isubedge)%push_back(-1)
             end if
            end do  
           end if
         end if  
        end if  
        m=m+1
       end do 
     end if 
     
     do icorner=1, num_corners_x_cell
       if ( .not. (quad_to_corner_buffer(l) <= 0_igp) ) then
         call g2l_map%get(key=quad_to_corner_buffer(l), val=jcell, stat=istat)
         if ( istat == key_found ) then
           quad_to_corner(icorner,icell+this%get_num_local_cells()) = jcell-1
         end if
       end if   
       l=l+1
     end do
  end do

  if ( num_half_faces > 0 ) then
    allocate ( quad_to_half(num_subfacets_facet, num_half_faces), stat=istat); check(istat==0);
  else
    nullify(quad_to_half)
  end if 
  
  if (associated(this%quad_to_half)) then
    quad_to_half(1:num_subfacets_facet, 1:size(this%quad_to_half,2)) = this%quad_to_half
    current = size(this%quad_to_half,2)+1
  else
    current = 1
  end if 
  
  do i=1, extra_cols_quad_to_half(1)%size()
    do isubface = 1, num_subfacets_facet
      quad_to_half(isubface, current) = extra_cols_quad_to_half(isubface)%get(i)
    end do
    current = current + 1 
  end do

  if ( this%get_num_dims() == 3 ) then
    if ( num_half_edges > 0 ) then
      allocate ( quad_to_half_by_edge(num_subedgets_edget, num_half_edges), stat=istat); check(istat==0);
    else
      nullify(quad_to_half_by_edge)
    end if 
  
    if (associated(this%quad_to_half_by_edge)) then
      quad_to_half_by_edge(1:num_subedgets_edget, 1:size(this%quad_to_half_by_edge,2)) = this%quad_to_half_by_edge
      current = size(this%quad_to_half_by_edge,2)+1
    else
      current = 1
    end if 
  
    do i=1, extra_cols_quad_to_half_by_edge(1)%size()
      do isubedge = 1, num_subedgets_edget
        quad_to_half_by_edge(isubedge, current) = extra_cols_quad_to_half_by_edge(isubedge)%get(i)
      end do
      current = current + 1 
    end do
  end if
  
  ! * IMPORTANT NOTE *: This set of 4x pointer re-associations does NOT cause
  ! any memory leak. These pointers are associated with C data arrays that
  ! in turn are to be deallocated by an internal p4est subroutine later on
  this%quad_to_quad   => quad_to_quad
  this%quad_to_face   => quad_to_face
  this%quad_to_half   => quad_to_half
  this%quad_to_corner => quad_to_corner
  if ( this%get_num_dims() == 3 ) then
    call memfree (this%quad_to_quad_by_edge, __FILE__, __LINE__)
    call memfree (this%quad_to_edge, __FILE__, __LINE__)
    call memmovealloc(quad_to_quad_by_edge, this%quad_to_quad_by_edge, __FILE__, __LINE__)
    call memmovealloc(quad_to_edge, this%quad_to_edge, __FILE__, __LINE__)
    
    ! * IMPORTANT NOTE *: This pointer re-associations will cause a memory leak if 
    ! we do not deallocate (free) in advance the C data array it is associated to 
    call F90_p4est_locidx_buffer_destroy(this%QHE)
    this%quad_to_half_by_edge   => quad_to_half_by_edge
    
    do i=1, cell_import%get_num_neighbours()
      call quad_to_half_by_edge_buffers(i)%free()
    end do 
    deallocate ( quad_to_half_by_edge_buffers, stat=istat); check(istat==0); 
    call memfree ( num_half_edges_x_neighbour, __FILE__, __LINE__ ) 
    call memfree ( quad_to_quad_by_edge_buffer  , __FILE__, __LINE__ )
    call memfree ( quad_to_edge_buffer  , __FILE__, __LINE__ )
    call memfree ( quad_to_half_by_edge_buffer  , __FILE__, __LINE__ )
    
    do isubedge=1, num_subedgets_edget
      call extra_cols_quad_to_half_by_edge(isubedge)%free()
    end do   
    deallocate(extra_cols_quad_to_half_by_edge, stat=istat); check(istat==0);
  end if
  
  do isubface=1, num_subfacets_facet
    call extra_cols_quad_to_half(isubface)%free()
  end do   
  deallocate(extra_cols_quad_to_half, stat=istat); check(istat==0);
  
  do i=1, cell_import%get_num_neighbours()
    call quad_to_half_buffers(i)%free()
  end do 
  deallocate ( quad_to_half_buffers, stat=istat); check(istat==0); 
  call memfree ( num_half_faces_x_neighbour, __FILE__, __LINE__ ) 
  call memfree ( quad_to_quad_buffer  , __FILE__, __LINE__ )
  call memfree ( quad_to_face_buffer  , __FILE__, __LINE__ )
  call memfree ( quad_to_half_buffer  , __FILE__, __LINE__ )
  call memfree ( quad_to_corner_buffer, __FILE__, __LINE__ )
  call g2l_map%free()
#else  
  call this%not_enabled_error()
#endif    
end subroutine p4est_bt_extend_p4est_topology_arrays_to_ghost_cells


subroutine p4est_bt_find_missing_corner_neighbours(this)
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
#ifdef ENABLE_P4EST  
  integer(ip) :: num_corners_x_cell
  integer(ip) :: num_edges_x_cell
  integer(ip) :: num_faces_x_cell
  integer(ip) :: num_subfacets_facet
  integer(ip) :: num_subedgets_edget
  integer(ip) :: icell, jcell, kcell
  integer(ip) :: lcell, lcell_iface, lcell_icorner
  integer(ip) :: iedge
  integer(ip) :: edget_id
  integer(ip) :: jcell_icorner, jcell_iface, jcell_iedge, kcell_iface, flip, mortar
  integer(P4EST_F90_QLEVEL) :: jcell_iconn 
  logical :: face_neighbours_at_the_same_refinement_level
  logical :: both_face_neighbours_are_double
  logical :: corner_found
  integer(ip) :: iface_at_edge
  integer(ip) :: iface_at_corner
  integer(ip) :: icorner_at_edge
  integer(ip) :: kcell_icorner, kcell_iedge
  integer(ip) :: kcell_face_neighbours(2,2)
  integer(ip) :: kcell_iedge_face_neighbours(2,2)
  integer(ip) :: kcell_icorner_face_neighbours(2,2)
  integer(ip) :: aux
  integer(ip) :: isubface 
  
  if ( this%get_num_dims() == 3 ) then   
     num_corners_x_cell      =  NUM_CORNERS_3D
     num_edges_x_cell        =  NUM_EDGES_3D
     num_faces_x_cell        =  NUM_FACES_3D
     num_subfacets_facet     =  NUM_SUBFACES_FACE_3D
     num_subedgets_edget     =  NUM_SUBEDGES_EDGE_3D
     
     do icell=1, this%get_num_cells()
       do iedge=1, num_edges_x_cell
        ! Find neigs only by edge
        jcell = this%quad_to_quad_by_edge(iedge,icell)+1
        if ( jcell > 0 ) then
          jcell_iconn = this%quad_to_edge(iedge,icell)
          call p8est_eval_edge_connectivity(jcell_iconn, jcell_iedge, flip, mortar)
          assert (flip==1) ! All cells MUST be aligned with each other

          if ( mortar == num_subedgets_edget+1 ) then ! Half-size edge neighbour 
            face_neighbours_at_the_same_refinement_level = .true.
            do edget_id = 1, num_subedgets_edget 
              jcell = this%quad_to_half_by_edge(edget_id,this%quad_to_quad_by_edge(iedge,icell)+1)+1   
              if ( jcell > 0 ) then
                do iface_at_edge=1, NUM_FACES_AT_EDGE_3D
                  jcell_iface = P4EST_FACES_AT_EDGE_3D(iface_at_edge,jcell_iedge)
                  jcell_iconn = this%quad_to_face(jcell_iface,jcell)
                  kcell       = this%quad_to_quad(jcell_iface,jcell)+1
                  if ( kcell /= jcell .and. kcell > 0 ) then
                    call p8est_eval_connectivity(jcell_iconn, kcell_iface, flip, mortar)
                    assert (flip==1) ! All cells MUST be aligned with each other
                  
                    ! If octree is 2:1 balanced, then face neighbour cannot be half!!!
                    assert(.not. (mortar==num_subfacets_facet+1))
                  
                    ! If neighbour across jcell_iface is double ...
                    if (mortar >= 1 .and. mortar <= num_subfacets_facet) then
                      face_neighbours_at_the_same_refinement_level = .false.
                      exit
                    else
                      assert(mortar==-1)
                      kcell_face_neighbours (iface_at_edge,edget_id) = kcell
                      kcell_iedge_face_neighbours(iface_at_edge,edget_id) = p4est_get_jcell_icorner(jcell_iface,kcell_iface,jcell_iedge,P4EST_EDGE_IN_FACE_3D,P4EST_FACE_EDGES_3D)
                    end if
                  else
                    face_neighbours_at_the_same_refinement_level = .false.
                  end if
                end do
              else
                face_neighbours_at_the_same_refinement_level = .false.
              end if
            end do 
            
            ! Generate kcell_icorner_face_neighbours
            if (face_neighbours_at_the_same_refinement_level) then
              do edget_id = 1, num_subedgets_edget   
                do iface_at_edge=1, NUM_FACES_AT_EDGE_3D
                   kcell = kcell_face_neighbours (iface_at_edge,edget_id)
                   kcell_iedge = kcell_iedge_face_neighbours(iface_at_edge,edget_id)
                   
                   ! Find corner within kcell thorough which a new corner neighbour is to be inserted
                   corner_found = .false.
                   find_corner: do icorner_at_edge=1, NUM_EDGE_CORNERS_3D 
                      kcell_icorner = P4EST_EDGE_CORNERS_3D(icorner_at_edge, kcell_iedge)
                      do iface_at_corner=1, NUM_FACES_AT_CORNER_3D
                         kcell_iface = P4EST_FACES_AT_CORNER_3D(iface_at_corner, kcell_icorner)
                         lcell       = this%quad_to_quad(kcell_iface, kcell)+1
                         
                         aux = edget_id+1
                         if ( aux > num_subedgets_edget) aux = 1 
                         
                         if ( lcell == kcell_face_neighbours(iface_at_edge, aux) ) then
                           corner_found = .true. 
                           exit find_corner
                         end if 
                      end do
                   end do find_corner
                  
                   if ( corner_found ) then
                     kcell_icorner_face_neighbours(iface_at_edge,edget_id) = kcell_icorner
                   end if 
                end do
              end do 
              
              ! Fill missing corner neighbours
              ! 1. kcell_face_neighbours(1,1) <-> kcell_face_neighbours(2,2)
              assert ( this%quad_to_corner(kcell_icorner_face_neighbours(1,1), kcell_face_neighbours(1,1)) == -1 )
              assert ( this%quad_to_corner(kcell_icorner_face_neighbours(2,2), kcell_face_neighbours(2,2)) == -1 )
              this%quad_to_corner(kcell_icorner_face_neighbours(1,1), kcell_face_neighbours(1,1)) = kcell_face_neighbours(2,2)-1
              this%quad_to_corner(kcell_icorner_face_neighbours(2,2), kcell_face_neighbours(2,2)) = kcell_face_neighbours(1,1)-1
              
              ! 2. kcell_face_neighbours(1,2) <-> kcell_face_neighbours(2,1)
              assert ( this%quad_to_corner(kcell_icorner_face_neighbours(1,2), kcell_face_neighbours(1,2)) == -1 )
              assert ( this%quad_to_corner(kcell_icorner_face_neighbours(2,1), kcell_face_neighbours(2,1)) == -1 )
              this%quad_to_corner(kcell_icorner_face_neighbours(1,2), kcell_face_neighbours(1,2)) = kcell_face_neighbours(2,1)-1
              this%quad_to_corner(kcell_icorner_face_neighbours(2,1), kcell_face_neighbours(2,1)) = kcell_face_neighbours(1,2)-1
            end if 
          else if ( icell /= jcell .and. mortar == -1 ) then ! Conformal neighbour
            both_face_neighbours_are_double = .true.
            do iface_at_edge=1, NUM_FACES_AT_EDGE_3D
              jcell_iface = P4EST_FACES_AT_EDGE_3D(iface_at_edge,jcell_iedge)
              jcell_iconn = this%quad_to_face(jcell_iface,jcell)
              kcell       = this%quad_to_quad(jcell_iface,jcell)+1
              if ( kcell /= jcell .and. kcell > 0 ) then
                call p8est_eval_connectivity(jcell_iconn, kcell_iface, flip, mortar)
                assert (flip==1) ! All cells MUST be aligned with each other
                
                ! If neighbour across jcell_iface is NOT double ...
                if (.not. (mortar >= 1 .and. mortar <= num_subfacets_facet)) then
                  both_face_neighbours_are_double = .false.
                  exit
                end if
              else
                both_face_neighbours_are_double = .false.
              end if
            end do

            !write (*,*) 'XXX', icell, iedge, jcell, jcell_iedge, kcell, kcell_iface, both_face_neighbours_are_double
            
            ! If both face neighbours are double ... then corner neighbour is missing
            if ( both_face_neighbours_are_double ) then
              ! Go over corners of jcell_iedge on jcell
              corner_found = .false.
              find_corner_bis: do icorner_at_edge=1, NUM_EDGE_CORNERS_3D 
                jcell_icorner = P4EST_EDGE_CORNERS_3D(icorner_at_edge, jcell_iedge)
                
                ! Go over faces of current corner on jcell 
                do iface_at_corner=1, NUM_FACES_AT_CORNER_3D
                  ! Check whether the current face is conformal, and if so, whether
                  ! the cell across this face belongs to the set of half cells across
                  ! any of the two coarse faces traversed above (registered in (kcell,kcell_iface))
                  jcell_iface = P4EST_FACES_AT_CORNER_3D(iface_at_corner, jcell_icorner)
                  jcell_iconn = this%quad_to_face(jcell_iface,jcell)
                  lcell       = this%quad_to_quad(jcell_iface,jcell)+1
                  if ( lcell > 0 ) then
                    call p8est_eval_connectivity(jcell_iconn, lcell_iface, flip, mortar)
                    assert (flip==1) ! All cells MUST be aligned with each other
                    if ( lcell /= jcell .and. mortar == -1 ) then
                       ! Go over half-size neighbours of kcell_iface within kcell  
                       do isubface=1, size(this%quad_to_half,1)
                          if ( this%quad_to_half(isubface,this%quad_to_quad(kcell_iface,kcell)+1)+1 == lcell ) then
                             corner_found = .true.
                             exit find_corner_bis
                          end if  
                       end do
                    end if 
                  end if
                end do
              end do find_corner_bis 
              
              if ( corner_found ) then
                ! jcell, jcell_icorner, jcell_iface, lcell_iface
                lcell_icorner = p4est_get_jcell_icorner(jcell_iface,lcell_iface,jcell_icorner,P4EST_CORNER_IN_FACE_3D,P4EST_FACE_CORNERS_3D)
                if ( this%quad_to_corner(lcell_icorner                          , lcell) == -1 ) then
                  assert ( this%quad_to_corner(P4EST_OPPOSITE_CORNER_3D(lcell_icorner), icell) == -1 )
                  this%quad_to_corner(lcell_icorner                          , lcell) = icell-1 
                  this%quad_to_corner(P4EST_OPPOSITE_CORNER_3D(lcell_icorner), icell) = lcell-1 
                else 
                  assert ( this%quad_to_corner(lcell_icorner                          , lcell) == icell-1 )
                  assert ( this%quad_to_corner(P4EST_OPPOSITE_CORNER_3D(lcell_icorner), icell) == lcell-1  )
                end if
              end if

            end if 
          end if 
        end if  
       end do 
     end do
  end if
  
#else  
  call this%not_enabled_error()
#endif      
end subroutine p4est_bt_find_missing_corner_neighbours

subroutine p4est_base_triangulation_update_cell_ggids ( this )
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  integer(ip) :: i
  class(environment_t), pointer :: environment
  integer(igp), pointer :: global_ggids(:)
  environment => this%get_environment()
#ifdef ENABLE_P4EST  
  ! Update the cell global identifiers of local cells
  call this%cell_ggids%resize(this%get_num_local_cells()+this%get_num_ghost_cells())
  do i=1, this%get_num_local_cells()
    call this%cell_ggids%set(i,this%global_first_quadrant(environment%get_l1_rank()+1)+i)
  end do
  global_ggids => this%cell_ggids%get_pointer()
  
  if ( associated(global_ggids) ) then
    if ( this%get_num_dims() == 2 ) then
      call F90_p4est_fill_ghost_ggids(this%p4est_ghost,&
                                      this%global_first_quadrant, &
                                      global_ggids(this%get_num_local_cells()+1:))
    else if ( this%get_num_dims() == 3 ) then
      call F90_p8est_fill_ghost_ggids(this%p4est_ghost,&
                                      this%global_first_quadrant, &
                                      global_ggids(this%get_num_local_cells()+1:))
    end if
  end if   
#else  
  call this%not_enabled_error()
#endif  
end subroutine p4est_base_triangulation_update_cell_ggids 

subroutine p4est_base_triangulation_comm_cell_ggids ( this )
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  class(environment_t), pointer :: environment
  class(cell_import_t), pointer :: cell_import 
  integer(igp), pointer :: cell_ggids(:)
#ifdef ENABLE_P4EST  
  environment => this%get_environment()
  cell_ggids => this%cell_ggids%get_pointer()
  cell_import => this%get_cell_import()
  call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_rcv_ptrs(),&
                                            cell_import%get_rcv_leids(),&
                                            cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_snd_ptrs(),&
                                            cell_import%get_snd_leids(),&
                                            cell_ggids, cell_ggids )
#else  
  call this%not_enabled_error()
#endif  
end subroutine p4est_base_triangulation_comm_cell_ggids

subroutine p4est_base_triangulation_update_cell_myparts ( this )
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  integer(ip) :: i
  class(environment_t), pointer :: environment
  integer(ip), pointer :: global_myparts(:), P(:)
  environment => this%get_environment()
#ifdef ENABLE_P4EST  
  ! Update the cell global identifiers of local cells
  call this%cell_myparts%resize(0)
  call this%cell_myparts%resize(this%get_num_local_cells()+this%get_num_ghost_cells(),-1)
  do i=1, this%get_num_local_cells()
    call this%cell_myparts%set(i,environment%get_l1_rank()+1)
  end do
  global_myparts => this%cell_myparts%get_pointer()
  P              => global_myparts(this%get_num_local_cells()+1:this%get_num_local_cells()+this%get_num_ghost_cells())
  if ( this%get_num_dims() == 2 ) then
    if (size(global_myparts)>this%get_num_local_cells()) then 
      call F90_p4est_fill_ghost_procs(this%p4est_ghost,&                           
                                      P)
    end if 
  else if ( this%get_num_dims() == 3 ) then
    if (size(global_myparts)>this%get_num_local_cells()) then
      call F90_p8est_fill_ghost_procs(this%p4est_ghost,&
                                      P)    
    end if
  end if
#else  
  call this%not_enabled_error()
#endif  
end subroutine p4est_base_triangulation_update_cell_myparts 


subroutine p4est_base_triangulation_comm_cell_myparts ( this )
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  class(environment_t), pointer :: environment
  class(cell_import_t), pointer :: cell_import 
  integer(ip), pointer :: cell_myparts(:)
#ifdef ENABLE_P4EST  
  environment => this%get_environment()
  cell_myparts => this%cell_myparts%get_pointer()
  cell_import => this%get_cell_import()
  call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_rcv_ptrs(),&
                                            cell_import%get_rcv_leids(),&
                                            cell_import%get_num_neighbours(), &
                                            cell_import%get_neighbours_ids(),&
                                            cell_import%get_snd_ptrs(),&
                                            cell_import%get_snd_leids(),&
                                            cell_myparts,&
                                            cell_myparts)
#else  
  call this%not_enabled_error()
#endif  
 
end subroutine p4est_base_triangulation_comm_cell_myparts

subroutine p4est_bt_comm_cell_wise_vef_set_ids ( this, cell_wise_vef_set_ids )
  implicit none
  class(p4est_base_triangulation_t), intent(inout) :: this
  type(std_vector_integer_ip_t)    , intent(inout) :: cell_wise_vef_set_ids
  class(environment_t), pointer :: environment
  class(cell_import_t), pointer :: cell_import 
  integer(ip), pointer :: p_cell_wise_vef_set_ids(:)
  integer(ip) :: num_vefs 
#ifdef ENABLE_P4EST  
  environment => this%get_environment()
  num_vefs = this%get_ptr_vefs_x_cell(2)-this%get_ptr_vefs_x_cell(1)
  call cell_wise_vef_set_ids%resize(this%get_num_cells()*num_vefs)
  p_cell_wise_vef_set_ids => cell_wise_vef_set_ids%get_pointer()
  cell_import => this%get_cell_import()
  call environment%l1_neighbours_exchange ( cell_import%get_num_neighbours(), &
                                           cell_import%get_neighbours_ids(),&
                                           cell_import%get_rcv_ptrs(),&
                                           cell_import%get_rcv_leids(),&
                                           cell_import%get_num_neighbours(), &
                                           cell_import%get_neighbours_ids(),&
                                           cell_import%get_snd_ptrs(),&
                                           cell_import%get_snd_leids(),&
                                           p_cell_wise_vef_set_ids, p_cell_wise_vef_set_ids, num_vefs )
#else  
  call this%not_enabled_error()
#endif  
end subroutine p4est_bt_comm_cell_wise_vef_set_ids

subroutine p4est_create_cell_iterator ( this, cell )
  implicit none
  class(p4est_base_triangulation_t) , intent(in)    :: this
  class(cell_iterator_t), allocatable, intent(inout) :: cell
  integer(ip) :: istat
  call this%free_cell_iterator(cell)
  allocate(p4est_cell_iterator_t :: cell, stat=istat); check(istat==0)
  call cell%create(this)
end subroutine p4est_create_cell_iterator 

subroutine p4est_free_cell_iterator ( this, cell )
  implicit none
  class(p4est_base_triangulation_t) , intent(in)    :: this
  class(cell_iterator_t), allocatable, intent(inout) :: cell
  integer(ip) :: istat
  if ( allocated(cell) ) then
     call cell%free()
     deallocate(cell, stat=istat); check(istat==0);
  end if
end subroutine p4est_free_cell_iterator 

subroutine p4est_create_vef_iterator ( this, vef )
  implicit none
  class(p4est_base_triangulation_t) , intent(in)    :: this
  class(vef_iterator_t), allocatable , intent(inout) :: vef
  integer(ip) :: istat
  call this%free_vef_iterator(vef)
  allocate(p4est_vef_iterator_t :: vef, stat=istat); check(istat==0)
  call vef%create(this)
end subroutine p4est_create_vef_iterator

subroutine p4est_free_vef_iterator ( this, vef )
  implicit none
  class(p4est_base_triangulation_t) , intent(in)    :: this
  class(vef_iterator_t), allocatable , intent(inout) :: vef
  integer(ip) :: istat
  if ( allocated(vef) ) then
     call vef%free()
     deallocate(vef, stat=istat); check(istat==0);
  end if
end subroutine p4est_free_vef_iterator

function p4est_bt_get_migration_num_snd(this)
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip) :: p4est_bt_get_migration_num_snd
  mcheck(.false.,'This subroutine can only be called by some descendent classes')
end function p4est_bt_get_migration_num_snd

function p4est_bt_get_migration_lst_snd(this)
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip), pointer :: p4est_bt_get_migration_lst_snd(:)
  mcheck(.false.,'This subroutine can only be called by some descendent classes')
end function p4est_bt_get_migration_lst_snd

function p4est_bt_get_migration_snd_ptrs(this)
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip), pointer :: p4est_bt_get_migration_snd_ptrs(:)
  mcheck(.false.,'This subroutine can only be called by some descendent classes')
end function p4est_bt_get_migration_snd_ptrs

function p4est_bt_get_migration_pack_idx(this)
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip), pointer :: p4est_bt_get_migration_pack_idx(:)
  mcheck(.false.,'This subroutine can only be called by some descendent classes')
end function p4est_bt_get_migration_pack_idx

function p4est_bt_get_migration_num_rcv(this)
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip) :: p4est_bt_get_migration_num_rcv
  mcheck(.false.,'This subroutine can only be called by some descendent classes')
end function p4est_bt_get_migration_num_rcv

function p4est_bt_get_migration_lst_rcv(this)
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip), pointer :: p4est_bt_get_migration_lst_rcv(:)
  mcheck(.false.,'This subroutine can only be called by some descendent classes')
end function p4est_bt_get_migration_lst_rcv

function p4est_bt_get_migration_rcv_ptrs(this)
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip), pointer :: p4est_bt_get_migration_rcv_ptrs(:)
  mcheck(.false.,'This subroutine can only be called by some descendent classes')
end function p4est_bt_get_migration_rcv_ptrs

function p4est_bt_get_migration_unpack_idx(this)
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip), pointer :: p4est_bt_get_migration_unpack_idx(:)
  mcheck(.false.,'This subroutine can only be called by some descendent classes')
end function p4est_bt_get_migration_unpack_idx

function p4est_bt_get_migration_new2old(this)
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip), pointer :: p4est_bt_get_migration_new2old(:)
  mcheck(.false.,'This subroutine can only be called by some descendent classes')
end function p4est_bt_get_migration_new2old

function p4est_bt_get_migration_old2new(this)
  implicit none
  class(p4est_base_triangulation_t), intent(in) :: this
  integer(ip), pointer :: p4est_bt_get_migration_old2new(:)
  mcheck(.false.,'This subroutine can only be called by some descendent classes') 
end function p4est_bt_get_migration_old2new

SUBROUTINE p4est_eval_connectivity(Conn,nbSide,Flip,Mortar)
  IMPLICIT NONE
  INTEGER(P4EST_F90_QLEVEL),INTENT(IN)   :: Conn   ! p4est Side,Flip,Mortar encoding
  INTEGER(ip)              ,INTENT(OUT)  :: nbSide ! Neighbour side in p4est convention: 1..4
  INTEGER(ip)              ,INTENT(OUT)  :: Flip   ! Flip in p4est convention: 1..2
  INTEGER(ip)              ,INTENT(OUT)  :: Mortar ! Mortar in p4est convention: 1..2,
                                                   ! -1 if conformal, 3 if half-size neighbour
  INTEGER(ip) :: tmp
  !------------------------------------------------------------------------------------------
  ! The quad_to_quad list stores one value for each local quadrant's face.
  ! This value is in 0..local_num_quadrants-1 for local quadrants, or in
  ! local_num_quadrants + (0..ghost_num_quadrants-1) for ghost quadrants.
  ! The quad_to_face list has equally many entries which are either:
  ! 1. A value of v = 0..7 indicates one same-size neighbor.
  !    This value is decoded as v = r * 4 + nf, where nf = 0..3 is the
  !    neigbbor's connecting face num and r = 0..1 is the relative
  !    orientation of the neighbor's face, see p4est_connectivity.h.
  ! 2. A value of v = 8..23 indicates a double-size neighbor.
  !    This value is decoded as v = 8 + h * 8 + r * 4 + nf, where
  !    r and nf are as above and h = 0..1 is the num of the subface.
  ! 3. A value of v = -8..-1 indicates two half-size neighbors.
  !    In this case the corresponding quad_to_quad index points into the
  !    quad_to_half array which stores two quadrant nums per index,
  !    and the orientation of the smaller faces follows from 8 + v.
  !    The entries of quad_to_half encode between local and ghost quadrant
  !    in the same way as the quad_to_quad values described above.
  ! A quadrant on the boundary of the forest sees itself and its face num.

  SELECT CASE(Conn)
  CASE(0:7)   ! 1. conformal neighbour
    nbSide = MOD(Conn,4)+1     ! 1..4
    Flip   = Conn/4+1          ! 1..2
    Mortar = -1
  CASE(8:23) ! 2. double-size neighbour
    tmp    = MOD(Conn,8)       ! 0..7
    nbSide = MOD(tmp,4)+1      ! 1..4 
    Flip   = tmp/4+1           ! 1..2
    Mortar = (Conn-tmp-8)/8+1  ! 1..2 
  CASE(-8:-1) ! 3. half-size neighbour
    tmp    = Conn+8
    nbSide = MOD(tmp,4)+1     ! 1..4
    Flip   = tmp/4+1          ! 1..2
    Mortar = 3 
  CASE DEFAULT
    ! This type of face connectivity does not exist
    assert(.false.)
  END SELECT

END SUBROUTINE p4est_eval_connectivity

SUBROUTINE p8est_eval_connectivity(Conn,nbSide,Flip,Mortar)
! MODULES
! IMPLICIT VARIABLE HANDLING
IMPLICIT NONE
!-----------------------------------------------------------------------------------------------------------------------------------
! INPUT VARIABLES
INTEGER(KIND=1),INTENT(IN)   :: Conn   ! p4est Side,Flip,Mortar encoding
!-----------------------------------------------------------------------------------------------------------------------------------
! OUTPUT VARIABLES
INTEGER,INTENT(OUT)          :: nbSide ! Neighbour side in p4est convention: 1..6
INTEGER,INTENT(OUT)          :: Flip   ! Flip in p4est convention: 1..4
INTEGER,INTENT(OUT)          :: Mortar ! Mortar in p4est convention: 1..4,
                                       ! -1 if conformal, 5 if half-size neighbour
!-----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
INTEGER                      :: tmp
!-----------------------------------------------------------------------------------------------------------------------------------
! The quad_to_quad list stores one value for each local quadrant's face.
! This value is in 0..local_num_quadrants-1 for local quadrants, or in
! local_num_quadrants + (0..ghost_num_quadrants-1) for ghost quadrants.
! The quad_to_face list has equally many entries which are either:
! 1. A value of v = 0..23 indicates one same-size neighbor.
!    This value is decoded as v = r * 6 + nf, where nf = 0..5 is the
!    neigbbor's connecting face num and r = 0..3 is the relative
!    orientation of the neighbor's face, see p8est_connectivity.h.
! 2. A value of v = 24..119 indicates a double-size neighbor.
!    This value is decoded as v = 24 + h * 24 + r * 6 + nf, where
!    r and nf are as above and h = 0..3 is the num of the subface.
! 3. A value of v = -24..-1 indicates four half-size neighbors.
!    In this case the corresponding quad_to_quad index points into the
!    quad_to_half array which stores four quadrant nums per index,
!    and the orientation of the smaller faces follows from 24 + v.
!    The entries of quad_to_half encode between local and ghost quadrant
!    in the same way as the quad_to_quad values described above.
! A quadrant on the boundary of the forest sees itself and its face num.

SELECT CASE(Conn)
CASE(0:23)   ! 1. conformal neighbour
  nbSide = MOD(Conn,6)       ! 0..5
  Flip   = (Conn-nbSide)/6   ! 0..3
  Mortar = -1
CASE(24:119) ! 2. double-size neighbour
  tmp    = MOD(Conn,24)      ! 0..3
  nbSide = MOD(tmp,6)        ! 0..5  
  Flip   = (tmp-nbSide)/6    ! 0..3
  Mortar = (Conn-tmp-24)/24  ! 0..3
  Mortar = Mortar + 1        ! 1..4
CASE(-24:-1) ! 3. half-size neighbour
  tmp    = Conn+24
  nbSide = MOD(tmp,6)       ! 0..5
  Flip   = (tmp-nbSide)/6   ! 0..3
  Mortar = 5
CASE DEFAULT
  massert(.false., 'This type of face connectivity does not exist, has to be -24<f<23')
END SELECT
  nbSide = nbSide +1  ! 1 .. 6
  Flip   = Flip +  1  ! 1 .. 4
END SUBROUTINE p8est_eval_connectivity



SUBROUTINE p8est_eval_edge_connectivity(Conn,nbSide,Flip,Mortar)
! MODULES
! IMPLICIT VARIABLE HANDLING
IMPLICIT NONE
!-----------------------------------------------------------------------------------------------------------------------------------
! INPUT VARIABLES
INTEGER(KIND=1),INTENT(IN)   :: Conn   ! p4est Side,Flip,Mortar encoding
!-----------------------------------------------------------------------------------------------------------------------------------
! OUTPUT VARIABLES
INTEGER,INTENT(OUT)          :: nbSide ! Neighbour side in p4est convention: 1..12
INTEGER,INTENT(OUT)          :: Flip   ! Flip in p4est convention: 1..2
INTEGER,INTENT(OUT)          :: Mortar ! Mortar in p4est convention: 1..2,
                                       ! -1 if conformal, 3 if half-size neighbour
!-----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
INTEGER                      :: tmp
!-----------------------------------------------------------------------------------------------------------------------------------
! The quad_to_quad_by_edge list stores one value for each local quadrant's edge.
! This value is in 0..local_num_quadrants-1 for local quadrants, or in
! local_num_quadrants + (0..ghost_num_quadrants-1) for ghost quadrants.
! The quad_to_edge list has equally many entries which are either:
! 1. A value of v = 0..23 indicates one same-size neighbor.
!    This value is decoded as v = r * 12 + ne, where ne = 0..11 is the
!    neighbor's connecting edge number and r = 0..1 is the relative
!    orientation of the neighbor's edge.
! 2. A value of v = 24..71 indicates a double-size neighbor.
!    This value is decoded as v = 24 + h * 24 + r * 12 + ne, where
!    r and nf are as above and h = 0..1 is the number of the subedge.
! 3. A value of v = -24..-1 indicates two half-size neighbors.
!    In this case the corresponding quad_to_quad_by_edge index points into the
!    quad_to_half_by_edge array which stores two quadrant numbers per index,
!    and the orientation of the smaller edges follows from 24 + v.
!    The entries of quad_to_half encode between local and ghost quadrant
!    in the same way as the quad_to_quad values described above.
! A quadrant on the boundary of the forest sees itself and its face number.*/

SELECT CASE(Conn)
CASE(0:23)   ! 1. conformal neighbour
  nbSide = MOD(Conn,12)       ! 0..11
  Flip   = (Conn-nbSide)/12   ! 0..1
  Mortar = -1
CASE(24:71) ! 2. double-size neighbour
  tmp    = MOD(Conn,24)      ! 0..23
  nbSide = MOD(tmp,12)       ! 0..11  
  Flip   = (tmp-nbSide)/12   ! 0..3
  Mortar = (Conn-tmp-24)/24  ! 0..1
  Mortar = Mortar + 1        ! 1..2
CASE(-24:-1) ! 3. half-size neighbour
  tmp    = Conn+24
  nbSide = MOD(tmp,12)       ! 0..11
  Flip   = (tmp-nbSide)/12   ! 0..1
  Mortar = 3
CASE DEFAULT
  massert(.false., 'This type of edge connectivity does not exist, has to be -24<f<23')
END SELECT
  nbSide = nbSide +1  ! 1 .. 12
  Flip   = Flip +  1  ! 1 .. 2
END SUBROUTINE p8est_eval_edge_connectivity



function p4est_get_jcell_icorner(icell_iface,jcell_iface,icell_icorner,corner_and_face_2_corner_in_face,face_2_corners)
  implicit none
  integer(ip), intent(in) :: icell_iface 
  integer(ip), intent(in) :: jcell_iface 
  integer(ip), intent(in) :: icell_icorner 
  integer(ip), intent(in) :: corner_and_face_2_corner_in_face(:,:)
  integer(ip), intent(in) :: face_2_corners(:,:)
  integer(ip) :: p4est_get_jcell_icorner
  integer(ip) :: corner_in_face
  corner_in_face = corner_and_face_2_corner_in_face(icell_iface,icell_icorner)
  assert(corner_in_face/=-1)
  p4est_get_jcell_icorner = face_2_corners(corner_in_face,jcell_iface)
end function p4est_get_jcell_icorner

#ifndef ENABLE_P4EST
  subroutine p4est_base_triangulation_not_enabled_error(this)
    class(p4est_base_triangulation_t), intent(in) :: this
    write (stderr,*) 'Error: FEMPAR was not compiled with -DENABLE_P4EST.'
    write (stderr,*) "Error: You must activate this CPP macro in order to use P4EST"
    check(.false.)
  end subroutine p4est_base_triangulation_not_enabled_error
#endif

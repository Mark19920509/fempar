! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
module mesh_names
  use types_names
  use memor_names
  use sort_names
  use list_types_names
  use hash_table_names
  use stdio_names
  use reference_fe_names
  use mesh_distribution_names
  use mesh_parameters_names
  use mesh_partitioner_parameters_names
  use metis_names
  use rcm_renumbering_names
  use FPL
  use environment_names

  implicit none
# include "debug.i90"
  private

  integer(ip), target :: permu_2DP1(3) = (/ 1, 2, 3/)
  integer(ip), target :: permu_2DQ1(4) = (/ 1, 2, 4, 3/)
  integer(ip), target :: permu_3DP1(4) = (/ 1, 2, 3, 4/)
  integer(ip), target :: permu_3DPR(6) = (/ 1, 2, 3, 4, 5, 6/)
  integer(ip), target :: permu_3DQ1(8) = (/ 1, 2, 4, 3, 5, 6, 8, 7/)
  integer(ip), target :: permu_id  (8) = (/ 1, 2, 3, 4, 5, 6, 7, 8/)

  !> This data type is though to hold the mesh data files generated by a sequential
  !> unstructured mesh generator (e.g. GiD). At present, it only supports the mesh data files 
  !> generated by FEMPAR's GiD problem type (also available at the FEMPAR's project 
  !> source directory). Using this data type, one may also write the mesh into GiD's postprocess
  !> file format for visualization purposes using GiD.
  type mesh_t
     private
     ! Sizes
     integer(ip)                :: &
          order,                   &         ! GiD element order
          nelty,                   &         ! Number of element types
          ndime,                   &         ! Number of space dimensions
          npoin,                   &         ! Number of vertices
          nelem,                   &         ! Number of elements
          nnode,                   &         ! Maximum number of vertices per element
          nnodb                              ! Maximum number of vertices per boundary element

     ! Elements
     integer(ip), allocatable ::  &
          pnods(:),               &         ! pointers to the lnods
          lnods(:),               &         ! list of vefs of each element
          legeo(:),               &         ! List of geometry (volume) each element lies in
          leset(:)                          ! List of sets associated to each element

     ! List of vefs over which a definition of a set and/or a geometry is relevant. Tipically used
     ! to set boundary conditions but also useful for other purposes, e.g. an internal interface 
     ! separating materials over which a force has to be computed.
     type(list_t)             ::  &
          given_vefs                        ! boundary elements (vefs)      
     integer(ip), allocatable ::  &
          lst_vefs_geo(:),        &         ! List of geometric entities (volume, surface, point) each vef lies in
          lst_vefs_set(:)                   ! List of sets associated to each boundary
          
     real(rp), allocatable ::     &
          coord(:,:)                         ! Vertex coordinates
    
    contains
     ! Sizes getters
      procedure, non_overridable                   :: get_element_order     ! order
      procedure, non_overridable                   :: get_num_element_types ! nelty
      procedure, non_overridable                   :: get_num_dims     ! ndime
      procedure, non_overridable                   :: get_num_vertices ! npoin
      procedure, non_overridable                   :: get_num_cells    ! nelem


     ! Cell getters
      procedure, non_overridable                   :: get_vertices_x_cell_pointers  ! pnods
      procedure, non_overridable                   :: get_vertices_x_cell           ! lnods
      procedure, non_overridable                   :: get_cells_geometry_id         ! legeo
      procedure, non_overridable                   :: get_cells_set                 ! leset

     ! Vef getters
      procedure, non_overridable                   :: get_boundary_vefs             ! given_vefs
      procedure, non_overridable                   :: get_boundary_vefs_geometry_id ! lst_vefs_geo
      procedure, non_overridable                   :: get_boundary_vefs_set         ! lst_vefs_set

     ! Coords getters
      procedure, non_overridable                   :: get_vertex_coordinates                ! coord
      
      procedure, non_overridable                   :: create => mesh_create

      procedure, non_overridable                   :: read_fempar_gid_problem_type_format_dir_path_prefix
      procedure, non_overridable                   :: read_fempar_gid_problem_type_format_pl
      procedure, non_overridable                   :: read_fempar_gid_problem_type_format_file_unit
      procedure, non_overridable,          nopass  :: get_dir_path_and_prefix_from_pl
      procedure, non_overridable         , nopass  :: mesh_fempar_gid_problem_type_format_compose_name
      generic                                      :: read_fempar_gid_problem_type_format => read_fempar_gid_problem_type_format_dir_path_prefix, &
                                                                                             read_fempar_gid_problem_type_format_pl  , & 
                                                                                             read_fempar_gid_problem_type_format_file_unit
      
      procedure, non_overridable                   :: write_fempar_gid_problem_type_format_dir_path_prefix
      procedure, non_overridable                   :: write_fempar_gid_problem_type_format_pl
      procedure, non_overridable                   :: write_fempar_gid_problem_type_format_file_unit
      generic                                      :: write_fempar_gid_problem_type_format => write_fempar_gid_problem_type_format_dir_path_prefix, &
                                                                                    write_fempar_gid_problem_type_format_pl, &
                                                                                    write_fempar_gid_problem_type_format_file_unit
      
      procedure, non_overridable                   :: write_gid_postprocess_format_dir_path_prefix
      procedure, non_overridable                   :: write_gid_postprocess_format_pl
      procedure, non_overridable                   :: write_gid_postprocess_format_file_unit
      procedure, non_overridable,         nopass   :: mesh_gid_postprocess_format_compose_name
      generic                                      :: write_gid_postprocess_format => write_gid_postprocess_format_dir_path_prefix, &
                                                                                    write_gid_postprocess_format_pl, &
                                                                                    write_gid_postprocess_format_file_unit
      procedure, non_overridable :: build_dual_mesh    => mesh_build_dual_mesh
      procedure, non_overridable :: build_dual_graph   => mesh_build_dual_graph
      procedure, non_overridable :: free               => mesh_free      
  end type mesh_t

  ! Types
  public :: mesh_t

contains

   !=============================================================================
    function get_element_order(this) result(order)
        class(mesh_t), intent(in) :: this
        integer(ip)               :: order
        order = this%order
    end function get_element_order

  !=============================================================================
    function get_num_element_types(this) result(nelty)
        class(mesh_t), intent(in) :: this
        integer(ip)               :: nelty
        nelty = this%nelty
    end function get_num_element_types

  !=============================================================================
    pure function get_num_dims(this) result(ndime)
        class(mesh_t), intent(in) :: this
        integer(ip)               :: ndime
        ndime = this%ndime
    end function get_num_dims

  !=============================================================================
    pure function get_num_vertices(this) result(npoin)
        class(mesh_t), intent(in) :: this
        integer(ip)               :: npoin
        npoin = this%npoin
    end function get_num_vertices

  !=============================================================================
    pure function get_num_cells(this) result(nelem)
        class(mesh_t), intent(in) :: this
        integer(ip)               :: nelem
        nelem = this%nelem
    end function get_num_cells

  !=============================================================================
    function get_vertices_x_cell_pointers(this) result(pnods)
        class(mesh_t), target, intent(in) :: this
        integer(ip),   pointer            :: pnods(:)
        pnods => this%pnods
    end function get_vertices_x_cell_pointers

  !=============================================================================
    function get_vertices_x_cell(this) result(lnods)
        class(mesh_t), target, intent(in) :: this
        integer(ip),   pointer            :: lnods(:)
        lnods => this%lnods
    end function get_vertices_x_cell

  !=============================================================================
    function get_cells_geometry_id(this) result(legeo)
        class(mesh_t), target, intent(in) :: this
        integer(ip),   pointer            :: legeo(:)
        legeo => this%legeo
    end function get_cells_geometry_id

  !=============================================================================
    function get_cells_set(this) result(leset)
        class(mesh_t), target, intent(in) :: this
        integer(ip),   pointer            :: leset(:)
        leset => this%leset
    end function get_cells_set

  !=============================================================================
    function get_boundary_vefs(this) result(given_vefs)
        class(mesh_t), target, intent(in) :: this
        type(list_t),  pointer            :: given_vefs
        given_vefs => this%given_vefs
    end function get_boundary_vefs

  !=============================================================================
    function get_boundary_vefs_geometry_id(this) result(lst_vefs_geo)
        class(mesh_t), target, intent(in) :: this
        integer(ip),   pointer            :: lst_vefs_geo(:)
        lst_vefs_geo => this%lst_vefs_geo
    end function get_boundary_vefs_geometry_id

  !=============================================================================
    function get_boundary_vefs_set(this) result(lst_vefs_set)
        class(mesh_t), target, intent(in) :: this
        integer(ip),   pointer            :: lst_vefs_set(:)
        lst_vefs_set => this%lst_vefs_set
    end function get_boundary_vefs_set


  !=============================================================================
    function get_vertex_coordinates(this) result(coord)
        class(mesh_t), target, intent(in) :: this
        real(rp),      pointer            :: coord(:,:)
        coord => this%coord
    end function get_vertex_coordinates

  !=============================================================================  
    subroutine mesh_create(this, &
                           order, &
                           nelty, &
                           ndime, &
                           npoin, &
                           nelem, &
                           pnods, &
                           lnods, &
                           legeo, &
                           leset, &
                           given_vefs, &
                           lst_vefs_geo, &
                           lst_vefs_set, &
                           coord)
      implicit none
      class(mesh_t), intent(inout) :: this
      ! Sizes
      integer(ip), intent(in) :: order 
      integer(ip), intent(in) :: nelty
      integer(ip), intent(in) :: ndime
      integer(ip), intent(in) :: npoin
      integer(ip), intent(in) :: nelem
      ! Elements
      integer(ip), intent(in)  :: pnods(nelem+1)
      integer(ip), intent(in)  :: lnods(pnods(nelem+1)-1)
      integer(ip), intent(in)  :: legeo(nelem)
      integer(ip), intent(in)  :: leset(nelem)
      
      ! Boundary vefs-related data
      type(list_t), intent(in) :: given_vefs
      integer(ip),  intent(in) :: lst_vefs_geo(:)
      integer(ip),  intent(in) :: lst_vefs_set(:)    
      
      ! Vertex coordinates
      real(rp)   ,  intent(in) :: coord(:,:)
      
      integer(ip) :: ielem, iboun
      
      call this%free()
      
      assert ( order == z_order .or. order == c_order ) 
      this%order = order
      this%nelty = nelty
      this%ndime = ndime
      this%npoin = npoin
      this%nelem = nelem
      call memalloc(size(pnods), this%pnods,__FILE__,__LINE__)
      this%pnods = pnods
      call memalloc(size(lnods), this%lnods,__FILE__,__LINE__)
      this%lnods = lnods
      call memalloc(size(legeo), this%legeo,__FILE__,__LINE__)
      this%legeo = legeo
      call memalloc(size(leset), this%leset,__FILE__,__LINE__)
      this%leset = leset
      call memalloc(size(lst_vefs_geo), this%lst_vefs_geo,__FILE__,__LINE__)
      this%lst_vefs_geo = lst_vefs_geo
      call memalloc(size(lst_vefs_set), this%lst_vefs_set,__FILE__,__LINE__)
      this%lst_vefs_set = lst_vefs_set
      call memalloc(size(coord,1), size(coord,2), this%coord,__FILE__,__LINE__)
      this%coord = coord
      this%given_vefs = given_vefs
      
      this%nnode = 0
      do ielem = 2, this%nelem+1
       this%nnode = max(this%nnode,this%pnods(ielem)-this%pnods(ielem-1))
      end do
      
       this%nnodb    = 0
       do iboun = 1, this%given_vefs%get_num_pointers()
         this%nnodb = max(this%nnodb,this%given_vefs%get_sublist_size(iboun))
       end do
    end subroutine mesh_create
    
  !=============================================================================
   subroutine read_fempar_gid_problem_type_format_pl(this, parameter_list)
     implicit none 
     class(mesh_t)        , intent(out) :: this
     type(ParameterList_t), intent(in)    :: parameter_list
     ! Locals
     character(len=:), allocatable   :: dir_path
     character(len=:), allocatable   :: prefix
     character(len=:), allocatable   :: name
     integer(ip)                     :: lunio

     ! Mandatory parameters
     call this%get_dir_path_and_prefix_from_pl(parameter_list, dir_path, prefix)

     ! Read mesh
     call this%mesh_fempar_gid_problem_type_format_compose_name ( prefix, name )
     lunio = io_open( trim(dir_path)//'/'//trim(name), 'read', status='old' ); check(lunio>0)
     call this%read_fempar_gid_problem_type_format(lunio)
     call io_close(lunio)
   end subroutine read_fempar_gid_problem_type_format_pl
   
  !=============================================================================
  subroutine read_fempar_gid_problem_type_format_file_unit(this,lunio)
    !------------------------------------------------------------------------
    !
    ! This routine reads a mesh writen by GiD according to fempar problem type.
    !
    !------------------------------------------------------------------------
    implicit none
    class(mesh_t)     , intent(inout) :: this
    integer(ip)       , intent(in)    :: lunio
    
    integer(ip) :: idime,ipoin,inode,ielem,nboun,iboun,vbound,nnode,nnodb
    character(14) :: dum1
    character(7)  :: dum2
    character(7) :: dum3
    character(10) :: dum4
    character(10) :: dum5
    character(6) :: dum6
    character(1000) :: tel
    integer(ip), allocatable :: lnods_aux(:)
    integer(ip), allocatable :: bound_list_aux(:)
    type(list_iterator_t)    :: bound_iterator
    integer(ip), pointer     :: permu(:)

    call this%free()
    
    ! Read first line: "MESH dimension  2  order  0  types  1  cells          1  vertices          4  vefs          8
    read(lunio,'(a14,1x,i2, a7,1x,i2, a7,1x,i2, a10,1x,i10, a10,1x,i10, a6,1x,i10)') &
         & dum1,this%ndime,dum2,this%order,dum3,this%nelty,dum4,this%nelem, dum5,this%npoin,dum6,nboun


    ! Read vertices
    call memalloc(SPACE_DIM,this%npoin,this%coord,__FILE__,__LINE__)
    ! In case of 2D domains (num_dims=2) when SPACE_DIM is used, it is necessary to initialize the
    ! coordinates array to zero in order to guarantee that the third component is initialized to zero.
    ! The use of SPACE_DIM instead num_dims is based on the fact that this variable is known in
    ! compilation time, allowing the compiler to perform additional optimizations.
    this%coord = 0.0_rp
    do while(tel(1:5).ne.'coord')
       read(lunio,'(a)') tel
    end do
    read(lunio,'(a)') tel
    do while(tel(1:5).ne.'end c')
       read(tel,*) ipoin,(this%coord(idime,ipoin),idime=1,this%ndime)
       read(lunio,'(a)') tel
    end do

    ! Read cells' size (pnods)
    call memalloc(this%nelem+1,this%pnods,__FILE__,__LINE__)
    do while(tel(1:5).ne.'eleme')
       read(lunio,'(a)') tel
    end do
    read(lunio,'(a)') tel
    do while(tel(1:5).ne.'end e')
       read(tel,*) ielem,this%pnods(ielem+1)
       read(lunio,'(a)') tel
    end do
    ! Transform length to header and get mesh%nnode
    this%pnods(1) = 1
    this%nnode    = 0
    do ielem = 2, this%nelem+1
       this%nnode = max(this%nnode,this%pnods(ielem))
       this%pnods(ielem) = this%pnods(ielem)+this%pnods(ielem-1)
    end do

    ! Read cells
    call memalloc(this%pnods(this%nelem+1)-1,this%lnods,__FILE__,__LINE__)
    call memalloc(this%nelem,this%legeo,__FILE__,__LINE__)
    call memalloc(this%nelem,this%leset,__FILE__,__LINE__)
    call io_rewind(lunio)
    do while(tel(1:5).ne.'eleme')
       read(lunio,'(a)') tel
    end do
    read(lunio,'(a)') tel
    do while(tel(1:5).ne.'end e')
       read(tel,*) ielem,nnode,(this%lnods(this%pnods(ielem)-1+inode),inode=1,nnode),this%leset(ielem),this%legeo(ielem)
       read(lunio,'(a)') tel
    end do

    ! Read boundary cells' size (pnodb)
    !write(*,*) 'Reading boundaries sizes'
    call this%given_vefs%create(nboun)
    do while(tel(1:5).ne.'vefs')
       read(lunio,'(a)') tel
    end do
    read(lunio,'(a)') tel
    do while(tel(1:5).ne.'end v')
       read(tel,*) iboun, vbound
       !write(*,*) 'iboun bound', iboun, vbound
       call this%given_vefs%sum_to_pointer_index(iboun, vbound)
       read(lunio,'(a)') tel
    end do
    ! Transform length to header and get mesh%nnodb
    call this%given_vefs%calculate_header()
    this%nnodb    = 0
    do iboun = 1, this%given_vefs%get_num_pointers()
       this%nnodb = max(this%nnodb,this%given_vefs%get_sublist_size(iboun))
    end do

    ! Read boundary cells
    !write(*,*) 'Reading boundaries'
    call this%given_vefs%allocate_list_from_pointer()
    call memalloc(this%given_vefs%get_num_pointers(),this%lst_vefs_geo,__FILE__,__LINE__)
    call memalloc(this%given_vefs%get_num_pointers(),this%lst_vefs_set,__FILE__,__LINE__)
    call io_rewind(lunio)
    do while(tel(1:5).ne.'vefs')
       read(lunio,'(a)') tel
    end do
    read(lunio,'(a)') tel
    do while(tel(1:5).ne.'end v')
       read(tel,*) iboun,nnodb
       !write(*,*) 'iboun nnodb',iboun, nnodb
       allocate(bound_list_aux(this%given_vefs%get_sublist_size(iboun)))
       read(tel,*) iboun,nnodb, (bound_list_aux(inode),inode=1,nnodb),this%lst_vefs_set(iboun),this%lst_vefs_geo(iboun)
       bound_iterator = this%given_vefs%create_iterator(iboun)
       do inode=1, nnodb
          call bound_iterator%set_current(bound_list_aux(inode))
          call bound_iterator%next()
       enddo
       deallocate(bound_list_aux)
       read(lunio,'(a)') tel
    end do

    ! Reordering (c to z) the vertices of the mesh, if needed
    !if(permute_c2z_) then
    if(this%order==c_order) then
       this%order= z_order
       call memalloc(this%nnode, lnods_aux, __FILE__, __LINE__)
       do ielem = 1,this%nelem
          nnode = this%pnods(ielem+1) - this%pnods(ielem)
          lnods_aux(1:nnode) = this%lnods(this%pnods(ielem):this%pnods(ielem+1)-1)
          if(this%ndime == 2) then
             if(nnode == 3)  then    ! Linear triangles (2DP1)
                permu => permu_2DP1
             elseif(nnode == 4) then ! Linear quadrilaterals(2DQ1)
                permu => permu_2DQ1
             end if
          elseif(this%ndime == 3) then
             if(nnode == 4) then     ! Linear tetrahedra (3DP1)
                permu => permu_3DP1
             elseif(nnode == 8) then ! Linear hexahedra (3DQ1)
                permu => permu_3DQ1
             end if
          end if
          do inode = 1, nnode
             this%lnods(this%pnods(ielem)+inode-1) = lnods_aux(permu(inode))
          end do
       end do
       call memfree(lnods_aux,__FILE__,__LINE__)
    end if
  end subroutine read_fempar_gid_problem_type_format_file_unit  
  
  !=============================================================================
   subroutine read_fempar_gid_problem_type_format_dir_path_prefix (this, dir_path, prefix)
     implicit none 
     class(mesh_t)        , intent(inout) :: this
     character(len=*)     , intent(in)    :: dir_path
     character(len=*)     , intent(in)    :: prefix
     
     ! Locals
     character(len=:), allocatable   :: name
     integer(ip)                     :: lunio

     ! Read mesh
     call this%mesh_fempar_gid_problem_type_format_compose_name ( prefix, name )
     lunio = io_open( trim(dir_path)//'/'//trim(name), 'read', status='old' ); check(lunio>0)
     call this%read_fempar_gid_problem_type_format(lunio) 
     call io_close(lunio)
   end subroutine read_fempar_gid_problem_type_format_dir_path_prefix
   
  !=============================================================================
  subroutine get_dir_path_and_prefix_from_pl( parameter_list, dir_path, prefix ) 
     implicit none
     type(ParameterList_t),         intent(in)    :: parameter_list
     character(len=:), allocatable, intent(inout) :: dir_path
     character(len=:), allocatable, intent(inout) :: prefix
     ! Locals
     integer(ip)                                  :: error

     ! Mandatory parameters
     assert(parameter_list%isAssignable(mesh_dir_path_key, 'string'))
     error = parameter_list%GetAsString(key = mesh_dir_path_key, string = dir_path)
     assert(error==0)

     assert(parameter_list%isAssignable(mesh_prefix_key, 'string'))
     error = parameter_list%GetAsString(key = mesh_prefix_key, string = prefix)
     assert(error==0)
  end subroutine get_dir_path_and_prefix_from_pl
   
  !=============================================================================
  subroutine mesh_fempar_gid_problem_type_format_compose_name ( prefix, name ) 
    implicit none
    character(len=*)             , intent(in)    :: prefix 
    character(len=:), allocatable, intent(inout) :: name
    name = trim(prefix) // '.mesh'
  end subroutine mesh_fempar_gid_problem_type_format_compose_name
  
   !=============================================================================
   subroutine write_fempar_gid_problem_type_format_dir_path_prefix (this, dir_path, prefix)
     implicit none 
     class(mesh_t)        , intent(in) :: this
     character(len=*)     , intent(in) :: dir_path
     character(len=*)     , intent(in) :: prefix
     
     ! Locals
     character(len=:), allocatable   :: name
     integer(ip)                     :: lunio

     ! Read mesh
     call this%mesh_fempar_gid_problem_type_format_compose_name ( prefix, name )
     lunio = io_open( trim(dir_path)//'/'//trim(name), 'write' ); check(lunio>0)
     call this%write_fempar_gid_problem_type_format (lunio) 
     call io_close(lunio)
  end subroutine write_fempar_gid_problem_type_format_dir_path_prefix
   
  !=============================================================================
  subroutine write_fempar_gid_problem_type_format_pl(this, parameter_list)
     implicit none 
     class(mesh_t)        , intent(out) :: this
     type(ParameterList_t), intent(in)    :: parameter_list
      character(len=:), allocatable   :: name
     character(len=:), allocatable   :: dir_path
     character(len=:), allocatable   :: prefix
     call this%get_dir_path_and_prefix_from_pl(parameter_list, dir_path, prefix)
     call this%mesh_fempar_gid_problem_type_format_compose_name ( prefix, name )
     call this%write_fempar_gid_problem_type_format(dir_path,name)
  end subroutine write_fempar_gid_problem_type_format_pl
  
  !=============================================================================
  subroutine write_fempar_gid_problem_type_format_file_unit (this,lunio)
    implicit none
    class(mesh_t) , intent(in)          :: this
    integer(ip)   , intent(in)          :: lunio
   
    integer(ip)                         :: ielem, idime, ipoin, iboun, jboun
    integer(ip), allocatable            :: bound_list_aux(:)
    type(list_iterator_t)               :: bound_iterator

    ! Read first line: "MESH dimension  2  order  0  types  1  elements          1  vertices          4  vefs          8
    write(lunio,'(a14,1x,i2, a7,1x,i2, a7,1x,i2, a10,1x,i10, a10,1x,i10, a6,1x,i10)') &
         & 'MESH dimension',this%ndime,'  order',this%order,'  types',this%nelty,'  elements', &
         & this%nelem,'  vertices',this%npoin,'  vefs',this%given_vefs%get_num_pointers()
         
    ! Coordinates
    write(lunio,'(a)')'coordinates'
    assert(allocated(this%coord))
    do ipoin=1,this%npoin
       write(lunio,'(i10,3(1x,e16.8e3))') ipoin,(this%coord(idime,ipoin),idime=1,this%ndime)
    end do
    write(lunio,'(a)')'end coordinates'

    ! Elements
    write(lunio,'(a)')'elements'
    do ielem=1,this%nelem
       write(lunio,'(i10,65(1x,i10))') ielem, this%pnods(ielem+1)-this%pnods(ielem),&
            &  this%lnods(this%pnods(ielem):this%pnods(ielem+1)-1),this%leset(ielem),this%legeo(ielem)
    end do
    write(lunio,'(a)') 'end elements'

    ! Boundary elements
    write(lunio,'(a)')'vefs'
    do iboun=1,this%given_vefs%get_num_pointers()
       allocate(bound_list_aux(this%given_vefs%get_sublist_size(iboun)))
       bound_iterator = this%given_vefs%create_iterator(iboun)
       do jboun=1, this%given_vefs%get_sublist_size(iboun)
          bound_list_aux(jboun) = bound_iterator%get_current()
          call bound_iterator%next()
       enddo
       write(lunio,'(i10,65(1x,i10))') iboun, bound_iterator%get_size(), &
            &  bound_list_aux ,this%lst_vefs_set(iboun),this%lst_vefs_geo(iboun)
       deallocate(bound_list_aux)
    end do
    write(lunio,'(a)') 'end v'

  end subroutine write_fempar_gid_problem_type_format_file_unit
    
  !=============================================================================
  subroutine mesh_gid_postprocess_format_compose_name ( prefix, name )
    implicit none
    character(len=*)             , intent(in)    :: prefix 
    character(len=:), allocatable, intent(inout) :: name
    name = trim(prefix) // '.post.msh'
  end subroutine mesh_gid_postprocess_format_compose_name
   
  !=============================================================================
  subroutine write_gid_postprocess_format_file_unit (this,lunio,title)
    !------------------------------------------------------------------------
    !
    ! This routine writes a mesh in GiD format (only works for linear elements).
    !
    !------------------------------------------------------------------------
    implicit none
    class(mesh_t)    , intent(in)           :: this
    integer(ip)      , intent(in)           :: lunio
    character(*)     , intent(in), optional :: title

    integer(ip)                    :: ielem, idime, ipoin, inode, nnode
    character(13)                  :: elemt
    character(len=:), allocatable  :: title_

    integer(ip)     , pointer      :: permu(:)

    permu => permu_id
    if(this%ndime==2) then
       if(this%nnode==3) then
          elemt='Triangle' 
          if(this%order==z_order) permu => permu_2DP1
       else
          elemt='Quadrilateral'
          if(this%order==z_order) permu => permu_2DQ1
       end if
    else
       if(this%nnode==4) then 
          elemt='Tetrahedra'
          if(this%order==z_order) permu => permu_3DP1
       else if(this%nnode==6) then 
          elemt='Prism'
          if(this%order==z_order) permu => permu_3DPR
       else if(this%nnode==8) then 
          elemt='Hexahedra'
          if(this%order==z_order) permu => permu_3DQ1
       end if
    end if

    ! Header
    title_ = 'TITLE'
    if(present(title)) title_=title
    write(lunio,1) adjustl(trim(title_)),this%ndime,adjustl(trim(elemt)),this%nnode

    ! Coordinates
    write(lunio,2)'coordinates'
    if (allocated(this%coord)) then
       do ipoin=1,this%npoin
          write(lunio,3) ipoin,(this%coord(idime,ipoin),idime=1,this%ndime)
       end do
    end if
    write(lunio,2)'end coordinates'

    ! Connectivity
    if(this%nelty==1) then
       write(lunio,2)'elements'
       do ielem=1,this%nelem
          nnode = this%pnods(ielem+1)-this%pnods(ielem)
          write(lunio,4) ielem, (this%lnods(this%pnods(ielem)-1+permu(inode)),inode=1,nnode),1
       end do
       write(lunio,2) 'end elements'
    else
       ! Write hexahedra or prismas (3D) or quads(2)
       write(lunio,2)'elements'
       do ielem=1,this%nelem
          nnode = this%pnods(ielem+1)-this%pnods(ielem)
          if(nnode == this%nnode) &
               write(lunio,4) ielem, (this%lnods(this%pnods(ielem)-1+permu(inode)),inode=1,nnode),1
       end do
       write(lunio,2) 'end elements'
       ! Now write tetrahedra (3D) or triangles (2D)
       if(this%ndime==2) then
          nnode = 3
          elemt = 'Triangle' 
          if(this%order==z_order) permu => permu_2DP1
       else if(this%ndime==3) then
          nnode = 4
          elemt='Tetrahedra'
          if(this%order==z_order) permu => permu_3DP1
       end if
       write(lunio,1) adjustl(trim(title_)),this%ndime,adjustl(trim(elemt)),nnode
       write(lunio,2)'coordinates'
       write(lunio,2)'end coordinates'
       write(lunio,2)'elements'
       do ielem=1,this%nelem
          if(this%pnods(ielem+1)-this%pnods(ielem) == nnode) &
               write(lunio,4) ielem, (this%lnods(this%pnods(ielem)-1+permu(inode)),inode=1,nnode),1
       end do
       write(lunio,2) 'end elements'
       ! Eventually write prismas (3D)
       if(this%ndime==3.and.this%nnode==8) then
          nnode = 4
          elemt='Prism'
          if(this%order==z_order) permu => permu_3DPR
          write(lunio,1) adjustl(trim(title_)),this%ndime,adjustl(trim(elemt)),nnode
          write(lunio,2)'coordinates'
          write(lunio,2)'end coordinates'
          write(lunio,2)'elements'
          do ielem=1,this%nelem
             if(this%pnods(ielem+1)-this%pnods(ielem) == nnode) &
                  write(lunio,4) ielem, (this%lnods(this%pnods(ielem)-1+permu(inode)),inode=1,nnode),1
          end do
          write(lunio,2) 'end elements'
       end if
    end if

1   format('MESH ',a,' dimension ',i1,' Elemtype ',a,' Nnode ',i2)
2   format(a)
3   format(i10, 3(1x,e16.8e3))
4   format(i10,65(1x,i10))
5   format('BOUNDARY ',a,' Nnodb ',i2)
6   format(i6,10(1x,i6))

  end subroutine write_gid_postprocess_format_file_unit

   !=============================================================================
   subroutine write_gid_postprocess_format_pl ( f_mesh, parameter_list)
     implicit none 
     class(mesh_t)        , intent(in) :: f_mesh
     type(ParameterList_t), intent(in) :: parameter_list
     character(len=:), allocatable   :: dir_path
     character(len=:), allocatable   :: prefix
     character(len=:), allocatable   :: name
     integer(ip)                     :: lunio
     call get_dir_path_and_prefix_from_pl(parameter_list, dir_path, prefix)
     call f_mesh%mesh_gid_postprocess_format_compose_name ( prefix, name )
     call f_mesh%write_gid_postprocess_format(dir_path,name)
   end subroutine write_gid_postprocess_format_pl
   
   !=============================================================================
   subroutine write_gid_postprocess_format_dir_path_prefix (f_mesh, dir_path, prefix)
     implicit none 
     class(mesh_t)   , intent(in) :: f_mesh
     character(len=*), intent(in) :: dir_path
     character(len=*), intent(in) :: prefix
     
     character(len=:), allocatable   :: name
     integer(ip) :: lunio

     call mesh_gid_postprocess_format_compose_name ( prefix, name )
     lunio = io_open( trim(dir_path)//'/'//trim(name), 'write' ); check(lunio>0)
     call f_mesh%write_gid_postprocess_format(lunio)
     call io_close(lunio)
   end subroutine write_gid_postprocess_format_dir_path_prefix
   
   
  !=============================================================================
  subroutine mesh_free (msh)
    !-----------------------------------------------------------------------
    ! This routine generates deallocates a mesh
    !-----------------------------------------------------------------------
    implicit none
    class(mesh_t), intent(inout)  :: msh
    if (allocated(msh%pnods)) call memfree (msh%pnods,__FILE__,__LINE__)
    if (allocated(msh%lnods)) call memfree (msh%lnods,__FILE__,__LINE__)
    if (allocated(msh%legeo)) call memfree (msh%legeo,__FILE__,__LINE__)
    if (allocated(msh%leset)) call memfree (msh%leset,__FILE__,__LINE__)
    if (allocated(msh%coord))    call memfree (msh%coord,__FILE__,__LINE__)
    msh%ndime=0
    msh%npoin=0
    msh%nelem=0
    msh%nnode=0
    msh%order=c_order
    msh%nelty=1
    call msh%given_vefs%free()
    if (allocated(msh%lst_vefs_geo)) call memfree (msh%lst_vefs_geo,__FILE__,__LINE__)
    if (allocated(msh%lst_vefs_set)) call memfree (msh%lst_vefs_set,__FILE__,__LINE__)
    msh%nnodb=0
  end subroutine mesh_free
  
  subroutine mesh_build_dual_mesh(this, pelpo, lelpo)
    implicit none
    class(mesh_t)            , intent(in)    :: this
    integer(ip),  allocatable, intent(inout) :: pelpo(:)
    integer(ip),  allocatable, intent(inout) :: lelpo(:)
    ! Local variables
    integer(ip)              :: inode, ipoin, ielem, size_lnods
    
    if ( allocated(pelpo) ) call memfree (pelpo, __FILE__, __LINE__)
    if ( allocated(lelpo) ) call memfree (lelpo, __FILE__, __LINE__)

    call memalloc (this%npoin+1, pelpo, __FILE__,__LINE__)
    size_lnods = this%pnods(this%nelem+1)-1 
    
    ! Compute the number of elements around each vertex
    pelpo=0
    do inode=1, size_lnods
       ipoin=this%lnods(inode)
       pelpo(ipoin+1)=pelpo(ipoin+1)+1
    end do
    
    ! Compute pointers to the starting position of the list
    ! of elements around each point
    pelpo(1)=1
    do ipoin=1,this%npoin
       pelpo(ipoin+1)=pelpo(ipoin+1)+pelpo(ipoin)
    end do

    ! Allocate lelpo and fill it
    call memalloc (pelpo(this%npoin+1), lelpo, __FILE__,__LINE__)

    ! Compute the list of elements around each point.
    ! pelpo is used instead of auxiliary work space.
    do ielem=1,this%nelem 
       do inode=this%pnods(ielem),this%pnods(ielem+1)-1
          ipoin=this%lnods(inode)
          lelpo(pelpo(ipoin))=ielem
          pelpo(ipoin)=pelpo(ipoin)+1
       end do
    end do
    
    ! Recover pelpo
    do ipoin=this%npoin+1, 2, -1
       pelpo(ipoin)=pelpo(ipoin-1)
    end do
    pelpo(1) = 1
  end subroutine mesh_build_dual_mesh
  
  !================================================================================================
  subroutine mesh_build_dual_graph(this,pelpo,lelpo,graph)
    implicit none
    ! Parameters
    class(mesh_t) , intent(in)    :: this                           ! Mesh
    integer(ip)   , intent(in)    :: pelpo(this%npoin+1)            ! Dual mesh
    integer(ip)   , intent(in)    :: lelpo(pelpo(this%npoin+1)-1)   
    type(list_t)  , intent(inout) :: graph                          ! Dual graph
    
    ! Locals
    integer(ip), allocatable :: lelem(:)
    integer(ip), allocatable :: keadj(:)
    integer(ip) :: i, max_num_cells_around

    call graph%free()
    
    ! Compute max num cells around any vertex
    max_num_cells_around=0
    do i=1,this%npoin
      max_num_cells_around=max(max_num_cells_around,pelpo(i+1)-pelpo(i))
    end do 
    
    call memalloc(                     this%nelem, lelem, __FILE__, __LINE__)
    call memalloc(max_num_cells_around*this%nnode, keadj, __FILE__, __LINE__)
    lelem=0

    call count_elemental_graph(this%ndime,this%npoin,this%nelem, &
         &                     this%pnods,this%lnods,this%nnode,max_num_cells_around, &
         &                     pelpo,lelpo,lelem,keadj,graph)

    call graph%allocate_list_from_pointer()

    call list_elemental_graph(this%ndime,this%npoin,this%nelem, &
         &                    this%pnods,this%lnods,this%nnode,max_num_cells_around, &
         &                    pelpo,lelpo,lelem,keadj,graph)

    call memfree(lelem,__FILE__,__LINE__)
    call memfree(keadj,__FILE__,__LINE__)
  end subroutine mesh_build_dual_graph

  !-----------------------------------------------------------------------
  subroutine count_elemental_graph(ncomm,npoin,nelem,pnods,lnods,nnode, &
       &                           nelpo,pelpo,lelpo,lelem,keadj,graph)
    implicit none
    integer(ip),  intent(in)    :: ncomm,npoin,nelem
    integer(ip),  intent(in)    :: pnods(nelem+1),lnods(pnods(nelem+1))
    integer(ip),  intent(in)    :: nnode             ! Number of vertices of each element (max.)
    integer(ip),  intent(in)    :: nelpo             ! Number of elements around points (max.)
    integer(ip),  intent(in)    :: pelpo(npoin+1)    ! Number of elements around points
    integer(ip),  intent(in)    :: lelpo(pelpo(npoin+1))    ! List of elements around points
    type(list_t), intent(inout) :: graph                    ! Number of edges on each element (list_t)
    integer(ip),  intent(out)   :: lelem(nelem)             ! Auxiliar array
    integer(ip),  intent(out)   :: keadj(nelpo*nnode)       ! Auxiliar array
    integer(ip)                 :: ielem,jelem,inode,knode  ! Indices
    integer(ip)                 :: ipoin,ielpo,index        ! Indices
    integer(ip)                 :: neadj,ielel,jelel,nelel  ! Indices

    lelem=0
    knode=nnode
    call graph%create(nelem)
    do ielem=1,nelem
       !call graph%sum_to_pointer_index(ielem-1, neadj)
       ! Loop over vertices and their surrounding elements and count
       ! how many times they are repeated as neighbors of ielem
       nelel=0
       keadj=0
       index=pnods(ielem)-1
       knode=pnods(ielem+1)-pnods(ielem)
       do inode=1,knode
          ipoin=lnods(index+inode)
          do ielpo=pelpo(ipoin),pelpo(ipoin+1)-1
             jelem=lelpo(ielpo)
             if(lelem(jelem)==0) then
                nelel=nelel+1
                keadj(nelel)=jelem
             end if
             lelem(jelem)=lelem(jelem)+1
          end do
       end do

       ! Now we loop over the elements around ielem and define neighbors
       ! as those sharing ncomm vertices. The smaller this number is the
       ! higher the connectivity of elemental graph is. Note that prisms,
       ! for example, could share 3 or 4 vertices depending on the face, so
       ! ndime (the number of space dimensions) is a good choice.
       jelel=0
       do ielel=1,nelel
          jelem=keadj(ielel)
          if(lelem(jelem)>=ncomm) jelel=jelel+1
       end do
       call graph%sum_to_pointer_index(ielem, jelel)

       ! Reset lelem
       do ielel=1,nelel
          jelem=keadj(ielel)
          lelem(jelem)=0
       end do
    end do
    
    call graph%calculate_header()

  end subroutine count_elemental_graph
  !-----------------------------------------------------------------------
  subroutine list_elemental_graph(ncomm,npoin,nelem,pnods,lnods,nnode, &
       &                          nelpo,pelpo,lelpo,lelem,keadj,graph)
    implicit none
    integer(ip),  intent(in)    :: ncomm,npoin,nelem
    integer(ip),  intent(in)    :: pnods(nelem+1),lnods(pnods(nelem+1))
    integer(ip),  intent(in)    :: nnode             ! Number of vertices of each element (max.)
    integer(ip),  intent(in)    :: nelpo             ! Number of elements around points (max.)
    integer(ip),  intent(in)    :: pelpo(npoin+1)    ! Number of elements around points
    integer(ip),  intent(in)    :: lelpo(pelpo(npoin+1))    ! List of elements around points
    type(list_t), intent(inout) :: graph                    ! List of edges on each element (list_t)
    integer(ip),  intent(out)   :: lelem(nelem)             ! Auxiliar array
    integer(ip),  intent(out)   :: keadj(nelpo*nnode)       ! Auxiliar array
    integer(ip)                 :: ielem,jelem,inode,knode  ! Indices
    integer(ip)                 :: ipoin,ielpo,index        ! Indices
    integer(ip)                 :: neadj,ielel,jelel,nelel  ! Indices
    type(list_iterator_t)       :: graph_iterator

    lelem=0
    knode=nnode
    do ielem=1,nelem
       ! Loop over vertices and their surrounding elements and count
       ! how many times they are repeated as neighbors of ielem
       nelel=0
       keadj=0
       index=pnods(ielem)-1
       knode=pnods(ielem+1)-pnods(ielem)
       do inode=1,knode
          ipoin=lnods(index+inode)
          do ielpo=pelpo(ipoin),pelpo(ipoin+1)-1
             jelem=lelpo(ielpo)
             if(lelem(jelem)==0) then
                nelel=nelel+1
                keadj(nelel)=jelem
             end if
             lelem(jelem)=lelem(jelem)+1
          end do
       end do

       ! Now we loop over the elements around ielem and define neighbors
       graph_iterator = graph%create_iterator(ielem)
       do ielel=1,nelel
          jelem=keadj(ielel)
          if(lelem(jelem)>=ncomm) then
             call graph_iterator%set_current(jelem)
             call graph_iterator%next()
          end if
       end do

       ! Reset lelem
       do ielel=1,nelel
          jelem=keadj(ielel)
          lelem(jelem)=0
       end do
    end do

  end subroutine list_elemental_graph

  ! Inspired on http://en.wikipedia.org/wiki/Breadth-first_search.
  ! Given a mesh (m) and its dual graph (g), it computes the list 
  ! of vertices (lconn) of each connected component in m. Can be very
  ! useful as a tool to determine whether the mesh partitioning process
  ! leads to disconnected subdomains or not.
  subroutine mesh_graph_compute_connected_components (m, g, lconn)
    implicit none

    ! Parameters
    type(mesh_t) , intent(in)   :: m   
    type(list_t),  intent(in)   :: g
    type(list_t),  intent(out)  :: lconn

    ! Locals
    integer(ip), allocatable :: auxv(:), auxe(:), e(:)
    integer(ip), allocatable :: emarked(:), vmarked(:)
    integer(ip), allocatable :: q(:)
    integer(ip)              :: head, tail, i, esize, vsize, current, & 
         j, l, k, inods1d, inods2d, p_ipoin, ipoin, graph_num_rows, lconnn
    type(list_iterator_t)    :: graph_column_iterator
    type(list_iterator_t)    :: lconn_iterator

    graph_num_rows = g%get_num_pointers()
    call memalloc ( graph_num_rows   , auxe     , __FILE__,__LINE__)
    call memalloc ( graph_num_rows   , auxv     , __FILE__,__LINE__)
    call memalloc ( graph_num_rows   , q        , __FILE__,__LINE__)
    call memalloc ( graph_num_rows   , emarked  , __FILE__,__LINE__)
    call memalloc ( m%npoin          , vmarked  , __FILE__,__LINE__)
    call memalloc ( graph_num_rows   ,  e       , __FILE__,__LINE__)

    lconnn  = 0
    emarked  = 0
    current  = 1 

    do i=1, graph_num_rows
       if (emarked(i) == 0) then
          ! New connected component
          lconnn = lconnn +1
          esize   = 0
          vsize   = 0
          vmarked = 0 
!!$1  procedure BFS(G,v):
!!$2      create a queue Q
          head=1
          tail=1
!!$3      enqueue v onto Q
          q(tail)=i
          tail=tail+1
!!$4      mark v
          emarked(i)=1
          e(current)=i
          esize  = esize + 1
          current = current + 1  

!!$5      while Q is not empty:
          do while (head/=tail)
!!$6         t ‚Üê Q.dequeue()
             j=q(head)
             head = head + 1

             ! Traverse the vertices of the element number j
             inods1d = m%pnods(j)
             inods2d = m%pnods(j+1)-1

             do p_ipoin = inods1d, inods2d
                ipoin = m%lnods(p_ipoin)
                if (vmarked(ipoin)==0) then
                   vmarked(ipoin)=1
                   vsize = vsize+1
                end if
             end do

!!$9         for all edges e in G.adjacentEdges(t) do
             graph_column_iterator = g%create_iterator(j)
             do while(.not. graph_column_iterator%is_upper_bound())
!!$12           u ‚Üê G.adjacentVertex(t,e)
                l=graph_column_iterator%get_current()
!!$13           if u is not emarked:
                if (emarked(l)==0) then
!!$14              mark u
                   emarked(l)=1
                   e(current)=l
                   esize  = esize + 1
                   current = current + 1  

!!$15              enqueue u onto Q
                   q(tail)=l
                   tail=tail+1
                end if
                call graph_column_iterator%next()
             end do
          end do
          auxe(lconnn) = esize
          auxv(lconnn) = vsize
       end if
    end do

    call lconn%create(lconnn)

    do i=1, lconnn
       call lconn%sum_to_pointer_index(i, auxv(i))
    end do

    call memfree( auxv   ,__FILE__,__LINE__)
    call memfree( q      ,__FILE__,__LINE__)
    call memfree( emarked,__FILE__,__LINE__)

    call lconn%calculate_header()
    call lconn%allocate_list_from_pointer()

    current=1
    lconn_iterator = lconn%create_iterator()
    do i=1, lconn_iterator%get_size()
       vmarked = 0
       ! Traverse elements of current connected component  
       do current=current,current+auxe(i)-1
          j=e(current)

          ! Traverse the vertices of the element number j
          inods1d = m%pnods(j)
          inods2d = m%pnods(j+1)-1

          do p_ipoin = inods1d, inods2d
             ipoin = m%lnods(p_ipoin)
             if (vmarked(ipoin)==0) then
                vmarked(ipoin)=1
                call lconn_iterator%set_current(ipoin)
                call lconn_iterator%next()
             end if
          end do

       end do
    end do

    call memfree( auxe,__FILE__,__LINE__)
    call memfree( e,__FILE__,__LINE__)
    call memfree( vmarked,__FILE__,__LINE__)
  end subroutine mesh_graph_compute_connected_components
end module mesh_names

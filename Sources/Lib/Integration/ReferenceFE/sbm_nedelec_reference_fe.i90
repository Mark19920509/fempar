! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!==================================================================================================
function nedelec_get_num_subcells(this, num_refinements) result(num_subcells)
  class(nedelec_reference_fe_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: num_refinements
  integer(ip)                                  :: num_subcells
  check(.false.)
end function nedelec_get_num_subcells

!==================================================================================================
subroutine nedelec_get_subcells_connectivity(this, num_refinements, connectivity)
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: num_refinements
  integer(ip)                  , intent(inout) :: connectivity(:,:)
  check(.false.)
end subroutine nedelec_get_subcells_connectivity


!==================================================================================================
function nedelec_reference_fe_get_component_node( this, node )
  implicit none
  class(nedelec_reference_fe_t), intent(in) :: this 
  integer(ip)                     , intent(in) :: node
  integer(ip) :: nedelec_reference_fe_get_component_node
  check(.false.)
end function nedelec_reference_fe_get_component_node

!==================================================================================================
function nedelec_reference_fe_get_scalar_from_vector_node( this, node )
  implicit none
  class(nedelec_reference_fe_t), intent(in) :: this 
  integer(ip)                     , intent(in) :: node
  integer(ip) :: nedelec_reference_fe_get_scalar_from_vector_node
  check(.false.)
end function nedelec_reference_fe_get_scalar_from_vector_node

!==================================================================================================
subroutine nedelec_reference_fe_interpolate_nodal_values_on_subcell ( this,                   &
                                                                      subcell_id,             &
                                                                      nodal_values_on_parent, & 
                                                                      nodal_values_on_child )
  implicit none 
  class(nedelec_reference_fe_t), intent(in)    :: this              
  integer(ip)                  , intent(in)    :: subcell_id
  real(rp)                     , intent(in)    :: nodal_values_on_parent(:)
  real(rp)                     , intent(inout) :: nodal_values_on_child(:)
  massert(.false.,'Note: you are calling interpolate_nodal_values_on_subcell on a type extension of reference_fe_t where it is not implemented.')
end subroutine nedelec_reference_fe_interpolate_nodal_values_on_subcell

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************
!==================================================================================================
subroutine nedelec_create_interpolation ( this, quadrature, interpolation, & 
     &                                    interpolation_duties)
  implicit none 
  class(nedelec_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)           , intent(in)    :: quadrature
  type(interpolation_t)        , intent(inout) :: interpolation
  type(interpolation_duties_t), optional , intent(in)    :: interpolation_duties

  call interpolation%create( this%num_dims, this%num_shape_functions, &
                             quadrature%num_quadrature_points, interpolation_duties )

  call this%fill_interpolation( quadrature, interpolation )

end subroutine nedelec_create_interpolation

!==================================================================================================
! This routine creates the interpolation corresponding to the evaluation of the shape functions on
! integration points given by local_quadrature either on the face 'facet_lid' of the element or
! in all the faces of the element.
subroutine nedelec_create_interpolation_restricted_to_facet( this, facet_lid, &
     & subfacet_lid, local_quadrature, facet_interpolation)
  implicit none 
  class(nedelec_reference_fe_t)   , intent(in)    :: this 
  integer(ip)                     , intent(in)    :: facet_lid
  integer(ip)                     , intent(in)    :: subfacet_lid
  type(quadrature_t)              , intent(in)    :: local_quadrature
  type(interpolation_t)           , intent(inout) :: facet_interpolation

  ! Allocate the arrays of the interpolation
  call facet_interpolation%create(this%num_dims, &
                                 this%num_shape_functions, &
                                 local_quadrature%num_quadrature_points)

  ! Fill the values of the shape functions
  call this%fill_interp_restricted_to_facet(local_quadrature, &
                                    facet_lid, &
                                    subfacet_lid, &
                                    facet_interpolation)

end subroutine nedelec_create_interpolation_restricted_to_facet

!==================================================================================================
! This routine creates the interpolation corresponding to the evaluation of the shape functions on
! integration points given by local_quadrature on the edge 'local_edge_id' of the element
subroutine nedelec_create_interpolation_restricted_to_edget( this, edget_lid, local_quadrature, edget_interpolation)
  implicit none 
  class(nedelec_reference_fe_t)   , intent(in)    :: this 
  integer(ip)                     , intent(in)    :: edget_lid
  type(quadrature_t)              , intent(in)    :: local_quadrature
  type(interpolation_t)           , intent(inout) :: edget_interpolation
  
  ! Allocate the arrays of the interpolation
  call edget_interpolation%create(this%num_dims, &
                                 this%num_shape_functions, &
                                 local_quadrature%num_quadrature_points)

  ! Fill the values of the shape functions, gradients, etc.
  call this%fill_interp_restricted_to_edget(edget_lid, &
                                            local_quadrature, &
                                            edget_interpolation)

end subroutine nedelec_create_interpolation_restricted_to_edget

!==================================================================================================
subroutine nedelec_fill_nodal_quadrature ( this, quadrature ) 
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)           , intent(inout) :: quadrature
  write(0,*) 'The concept of nodal_quadrature does not apply to Nedelec Ref FEs'
  check(.false.)
end subroutine nedelec_fill_nodal_quadrature

!==================================================================================================
subroutine nedelec_create ( this, topology, num_dims, order, field_type, & 
     &  conformity, continuity )
  implicit none 
  class(nedelec_reference_fe_t)   , intent(inout) :: this
  character(*)                    , intent(in)    :: topology
  integer(ip)                     , intent(in)    :: num_dims
  integer(ip)                     , intent(in)    :: order
  character(*)                    , intent(in)    :: field_type
  logical                         , intent(in)    :: conformity
  logical              , optional , intent(in)    :: continuity
  
  call this%free()
  call this%set_common_data(num_dims,order,field_type,conformity,continuity)
  call this%set_topology ( topology )
  call this%set_fe_type( fe_type_nedelec )
  call this%fill()
  if ( this%conformity .and. this%continuity ) then
    call this%change_basis()
  end if  
end subroutine nedelec_create

!==================================================================================================
subroutine nedelec_free ( this )
  implicit none 
  class(nedelec_reference_fe_t), intent(inout) :: this
  integer(ip) :: i
  
  if ( allocated(this%inverse_change_basis_matrix_h_refinement) ) &
     call memfree ( this%inverse_change_basis_matrix_h_refinement, __FILE__, __LINE__ ) 

  do i=1, size(this%node_array_vector)
    call this%node_array_vector(i)%free()
  end do
  
  ! Free member variables of lagrangian_reference_fe_t
  ! (and those of its ancestors)
  call lagrangian_reference_fe_free ( this )  
end subroutine nedelec_free

!==================================================================================================

subroutine nedelec_fill_vector (this)
  implicit none
  class(nedelec_reference_fe_t), intent(inout)    :: this 
  type(node_iterator_t) :: node_iterator
  type(facet_iterator_t) :: facet_iterator
  type(list_iterator_t) :: list_iterator
  integer(ip) :: topology, i, n_face_dim, node, children,num_n_faces, ones_dim(SPACE_DIM), idime, perm(SPACE_DIM), offset(SPACE_DIM+1)

  ! Change topology definition to these numbers from the very beginning (not parameter, dim independent)
  if ( this%topology == topology_hex) then
     topology = 2**this%num_dims-1
  elseif ( this%topology == topology_tet ) then
     topology = 0
  end if 
  
  call this%polytope%create( this%num_dims, topology )  

  this%num_shape_functions = 0
  offset(1) = 0
  do idime = 1,this%num_dims
     perm = [ (i, i=1,SPACE_DIM) ]
     perm(idime) = 1
     perm(1) = idime
     call this%node_array_vector(idime)%create( this%polytope, this%order_vector(perm) ) 
     ! Number nodes
     this%num_shape_functions = this%num_shape_functions + this%node_array_vector(idime)%get_num_nodes()
     offset(idime+1) = offset(idime) + this%node_array_vector(idime)%get_num_nodes()
  end do 

  ! Add Shape functions corresponding to homogeneous polynomials S_k basis in the tetrahedral case 
  if ( this%topology == topology_tet ) then  
    if (this%num_dims == 2) then 
      this%num_shape_functions = this%num_shape_functions + this%order 
    else 
      this%num_shape_functions = this%num_shape_functions + this%order*(this%order+2)
    end if 
  end if
  
  num_n_faces = this%polytope%get_num_n_faces()
  ! Number n-faces ( I don't like it, not volume included...)
  this%num_n_faces = num_n_faces-1
  ! num_n-faces_dim
  this%ptr_n_faces_x_dim = 0
  this%ptr_n_faces_x_dim(1) = 1
  do i = 1,num_n_faces
     n_face_dim = this%polytope%get_n_face_dim(i)
     this%ptr_n_faces_x_dim( n_face_dim+2 ) = this%ptr_n_faces_x_dim( n_face_dim+2 ) + 1
  end do
  do i = 1,this%num_dims+1
     this%ptr_n_faces_x_dim(i+1) = this%ptr_n_faces_x_dim(i+1) + this%ptr_n_faces_x_dim(i)
  end do
  
  ! vertices_n-face
  call this%vertices_n_face%create(num_n_faces)
  ones_dim = 1
  call this%vertex_array%create( this%polytope, order = ones_dim )
  do i = 1,num_n_faces
     node_iterator = this%vertex_array%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        call this%vertices_n_face%sum_to_pointer_index(i,1)
        call node_iterator%next()
     end do
  end do
  call this%vertices_n_face%calculate_header()
  call this%vertices_n_face%allocate_list_from_pointer()
  list_iterator = this%vertices_n_face%create_iterator()
  do i = 1,num_n_faces
     node_iterator = this%vertex_array%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        node = node_iterator%current()
        call list_iterator%set_current(node)
        call node_iterator%next()
        call list_iterator%next()
     end do
  end do
  call this%facets_n_face%create(num_n_faces)
  do i = 1,num_n_faces
     facet_iterator = this%polytope%create_facet_iterator( this%polytope%get_n_face(i) )
     do while (.not. facet_iterator%has_finished() )
        call this%facets_n_face%sum_to_pointer_index(i,1)
        call facet_iterator%next()
     end do
  end do
  call this%facets_n_face%calculate_header()
  call this%facets_n_face%allocate_list_from_pointer()
  list_iterator = this%facets_n_face%create_iterator()
  do i = 1,num_n_faces
     facet_iterator = this%polytope%create_facet_iterator( this%polytope%get_n_face(i) )
     do while (.not. facet_iterator%has_finished() )
        children = facet_iterator%current()
        call list_iterator%set_current(children)
        call facet_iterator%next()
        call list_iterator%next()
     end do
  end do
  ! orientation
  call this%orientation%create(num_n_faces)
  do i = 1,num_n_faces
     if ( compute_n_face_dim( this%polytope%get_n_face(i), this%num_dims ) == this%num_dims-1 ) then
        this%orientation%a(i) = facet_orientation( this%polytope%get_n_face(i), this%num_dims )
     end if
  end do

end subroutine nedelec_fill_vector

subroutine nedelec_create_facet_interpolation ( this, quadrature, &
     & facet_interpolation)
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: facet_interpolation

  write(0,*) 'Nedelec FEs cannot be used for geometry mapping'
  check(.false.)
end subroutine nedelec_create_facet_interpolation

subroutine nedelec_create_edget_interpolation ( this, quadrature, edget_interpolation)
  implicit none
  class(nedelec_reference_fe_t)   , intent(in)    :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: edget_interpolation

  write(0,*) 'Nedelec FEs cannot be used for geometry mapping'
  check(.false.)
end subroutine nedelec_create_edget_interpolation

function nedelec_has_nodal_quadrature(this)
  implicit none
  class(nedelec_reference_fe_t), intent(in) :: this
  logical :: nedelec_has_nodal_quadrature
  nedelec_has_nodal_quadrature = .false.
end function nedelec_has_nodal_quadrature

function nedelec_get_nodal_quadrature(this)
  implicit none
  class(nedelec_reference_fe_t), target, intent(in) :: this
  type(quadrature_t), pointer :: nedelec_get_nodal_quadrature
  assert ( .false. )
end function nedelec_get_nodal_quadrature

!==================================================================================================
subroutine nedelec_get_value_scalar( this, actual_cell_interpolation, ishape, qpoint, scalar_field )
  implicit none
  class(nedelec_reference_fe_t)   , intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  real(rp)                        , intent(inout) :: scalar_field
  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for vector-based FE spaces'
  check( .false. )
end subroutine nedelec_get_value_scalar

!==================================================================================================
subroutine nedelec_get_values_scalar( this, actual_cell_interpolation, values, qpoints_perm )
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation 
  real(rp), allocatable               , intent(inout) :: values(:,:)
  integer(ip)          , optional   , intent(in)    :: qpoints_perm(:)
  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for vector-based FE spaces'
  check( .false. )
end subroutine nedelec_get_values_scalar

!==================================================================================================
subroutine nedelec_get_value_vector( this, actual_cell_interpolation, & 
     & ishape, qpoint, vector_field )
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(vector_field_t)            , intent(inout) :: vector_field
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%num_shape_functions )
  assert( qpoint >= 1 )
  call vector_field%init(actual_cell_interpolation%shape_functions(:,ishape,qpoint))
end subroutine nedelec_get_value_vector

!==================================================================================================
subroutine nedelec_get_values_vector( this, actual_cell_interpolation, values, qpoints_perm)
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation 
  type(vector_field_t), allocatable   , intent(inout) :: values(:,:)
  integer(ip)          , optional   , intent(in)    :: qpoints_perm(:)
  integer(ip) :: idime, ishape, qpoint, istat, actual_qpoint
  logical     :: reallocate
  assert( this%field_type == field_type_vector )
  
  reallocate = .false.
  if (allocated(values)) reallocate = (size(values,1) < this%num_shape_functions) .or. &
                                      (size(values,2) < actual_cell_interpolation%num_quadrature_points)                                  
  if ((.not. allocated(values)) .or. reallocate) then
     if (allocated(values)) then 
        deallocate(values, stat=istat); 
        check(istat==0);
     end if
     ! This allocate inherently invokes default initialization of member variables of type(vector_field_t)
     ! (i.e., no need to explicitly initialize)
     allocate(values(this%num_shape_functions, &
              actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
  end if
  do qpoint=1, actual_cell_interpolation%num_quadrature_points
     if (present(qpoints_perm)) then
       actual_qpoint = qpoints_perm(qpoint)
     else
       actual_qpoint = qpoint
     end if
     do ishape=1, this%num_shape_functions
        call values(ishape,qpoint)%init(actual_cell_interpolation%shape_functions(:,ishape,actual_qpoint))
     end do
  end do  
end subroutine nedelec_get_values_vector

!!==================================================================================================
subroutine nedelec_get_gradient_scalar( this, actual_cell_interpolation, & 
     & ishape, qpoint, vector_field )
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(vector_field_t)            , intent(inout) :: vector_field
  integer(ip) :: idime
  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for vector-based FE spaces'
  check( .false. )
end subroutine nedelec_get_gradient_scalar

!==================================================================================================
subroutine nedelec_get_gradients_scalar( this, actual_cell_interpolation, gradients, qpoints_perm )
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation
  type(vector_field_t), allocatable   , intent(inout) :: gradients(:,:)
  integer(ip)          , optional   , intent(in)    :: qpoints_perm(:)
  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for vector-based FE spaces'
  check( .false. )
end subroutine nedelec_get_gradients_scalar

!==================================================================================================
subroutine nedelec_get_gradient_vector( this, actual_cell_interpolation, & 
     & ishape, qpoint, tensor_field )
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(tensor_field_t)            , intent(inout) :: tensor_field
  integer(ip) :: i, j
  
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%num_shape_functions )
  assert( qpoint >= 1 )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'Nedelec reference FE get gradient vector requires cell interpolation to compute derivaties ')

  do i=1, this%num_dims
    do j=1, this%num_dims
     call tensor_field%set(i,j,actual_cell_interpolation%shape_derivatives(j,i,ishape,qpoint))
    end do
  end do
end subroutine nedelec_get_gradient_vector

subroutine nedelec_get_gradients_vector( this, actual_cell_interpolation, gradients, qpoints_perm )
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation 
  type(tensor_field_t), allocatable   , intent(inout) :: gradients(:,:)
  integer(ip)          , optional   , intent(in)    :: qpoints_perm(:)
  integer(ip) :: i,j,ishape,qpoint,istat,actual_qpoint
  logical     :: reallocate
  
  assert( this%field_type == field_type_vector )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'Nedelec reference FE get gradients vector requires cell interpolation to compute derivaties ')

  reallocate = .false.
  if (allocated(gradients)) reallocate = (size(gradients,1) < this%num_shape_functions) .or. &
                                          (size(gradients,2) < actual_cell_interpolation%num_quadrature_points)                                  
  if ((.not. allocated(gradients)) .or. reallocate) then
     if (allocated(gradients)) then 
        deallocate(gradients, stat=istat); 
        check(istat==0);
     end if
     ! This allocate inherently invokes default initialization of member variables of type(vector_field_t)
     ! (i.e., no need to explicitly initialize)
     allocate(gradients(this%num_shape_functions, &
                        actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);      
  end if
  do qpoint=1, actual_cell_interpolation%num_quadrature_points
     if (present(qpoints_perm)) then
       actual_qpoint = qpoints_perm(qpoint)
     else
       actual_qpoint = qpoint
     end if
     do ishape=1, this%num_shape_functions
        do i=1, this%num_dims
          do j=1, this%num_dims
            call gradients(ishape,qpoint)%set(i,j,actual_cell_interpolation%shape_derivatives(j,i,ishape,actual_qpoint))
          end do
        end do
     end do
  end do
end subroutine nedelec_get_gradients_vector

!==================================================================================================
subroutine nedelec_get_divergence_vector( this, actual_cell_interpolation, & 
     & ishape, qpoint, scalar_field )
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  real(rp)                        , intent(inout) :: scalar_field

  ! Locals 
  integer(ip) :: idime

  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%num_shape_functions )
  assert( qpoint >= 1 )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'Nedelec reference FE get divergence vector requires cell interpolation to compute derivaties ')

  scalar_field = 0.0_rp
  do idime = 1, this%num_dims
     scalar_field = scalar_field + actual_cell_interpolation%shape_derivatives(idime,idime,ishape,qpoint)
  end do

end subroutine nedelec_get_divergence_vector

subroutine nedelec_get_divergences_vector( this, actual_cell_interpolation, divergences, qpoints_perm )
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation 
  real(rp), allocatable               , intent(inout) :: divergences(:,:)
  integer(ip)          , optional   , intent(in)    :: qpoints_perm(:)
  ! Locals 
  integer(ip) :: idime, ishape, qpoint, actual_qpoint
  logical     :: reallocate
  assert( this%field_type == field_type_vector )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'Nedelec reference FE get divergences vector requires cell interpolation to compute derivaties ')

  reallocate = .false.
  if (allocated(divergences)) reallocate = (size(divergences,1) < this%num_shape_functions) .or. &
                                           (size(divergences,2) < actual_cell_interpolation%num_quadrature_points)
                                          
  if ((.not. allocated(divergences)) .or. reallocate) then
     if (allocated(divergences)) then 
        call memfree(divergences, __FILE__,__LINE__); 
     end if
     call memalloc(this%num_shape_functions, &
                   actual_cell_interpolation%num_quadrature_points, &
                   divergences, __FILE__,__LINE__);
  end if
  do qpoint=1, actual_cell_interpolation%num_quadrature_points
     if (present(qpoints_perm)) then
       actual_qpoint = qpoints_perm(qpoint)
     else
       actual_qpoint = qpoint
     end if
     do ishape=1, this%num_shape_functions
        divergences(ishape,qpoint) = 0.0_rp
        do idime = 1, this%num_dims
           divergences(ishape,qpoint) = divergences(ishape,qpoint) + actual_cell_interpolation%shape_derivatives(idime,idime,ishape,actual_qpoint)
        end do
     end do
  end do
end subroutine nedelec_get_divergences_vector

!==================================================================================================
subroutine nedelec_get_curl_vector( this, actual_cell_interpolation, &
     &                              ishape, qpoint, vector_field )
  implicit none
  class(nedelec_reference_fe_t)   , intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(vector_field_t)            , intent(inout) :: vector_field

  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%num_shape_functions )
  assert( qpoint >= 1 )  
  assert( SPACE_DIM == 3 )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'Nedelec reference FE get curl vector requires cell interpolation to compute derivaties ')

  call vector_field%init(0.0_rp)
  if (this%num_dims == 2) then 
                             ! d_x u_y - d_y u_x
    call vector_field%set(3, actual_cell_interpolation%shape_derivatives(2,1,ishape,qpoint)- &
                             actual_cell_interpolation%shape_derivatives(1,2,ishape,qpoint) )
  else if ( this%num_dims == 3) then
                             ! d_y u_z - d_z u_y
    call vector_field%set(1, actual_cell_interpolation%shape_derivatives(3,2,ishape,qpoint)- &
                             actual_cell_interpolation%shape_derivatives(2,3,ishape,qpoint) )
    
                             ! d_z u_x - d_x u_z
    call vector_field%set(2, actual_cell_interpolation%shape_derivatives(1,3,ishape,qpoint)- &
                             actual_cell_interpolation%shape_derivatives(3,1,ishape,qpoint) )
    
                             ! d_x u_y - d_y u_x
    call vector_field%set(3, actual_cell_interpolation%shape_derivatives(2,1,ishape,qpoint)- &
                             actual_cell_interpolation%shape_derivatives(1,2,ishape,qpoint) )
  end if
end subroutine nedelec_get_curl_vector

!==================================================================================================
subroutine nedelec_get_curls_vector( this, actual_cell_interpolation, curls, qpoints_perm )
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation
  type(vector_field_t), allocatable   , intent(inout) :: curls(:,:)
  integer(ip)          , optional   , intent(in)    :: qpoints_perm(:)
  integer(ip) :: idime, ishape, qpoint, istat, actual_qpoint
  logical     :: reallocate
  integer(ip)   :: icomp, ishape_scalar 
  assert( this%field_type == field_type_vector )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'Nedelec reference FE get curls vector requires cell interpolation to compute derivaties ')

  reallocate = .false.
  if (allocated(curls)) reallocate = (size(curls,1) < this%num_shape_functions) .or. &
                                      (size(curls,2) < actual_cell_interpolation%num_quadrature_points)                                  
  if ((.not. allocated(curls)) .or. reallocate) then
     if (allocated(curls)) then 
        deallocate(curls, stat=istat); 
        check(istat==0);
     end if
     ! This allocate inherently invokes default initialization of member variables of type(vector_field_t)
     ! (i.e., no need to explicitly initialize)
     allocate(curls(this%num_shape_functions, &
                    actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
  end if
  do qpoint=1, actual_cell_interpolation%num_quadrature_points
     if (present(qpoints_perm)) then
       actual_qpoint = qpoints_perm(qpoint)
     else
       actual_qpoint = qpoint
     end if
     do ishape=1, this%num_shape_functions   
        call curls(ishape,qpoint)%init(0.0_rp)
        if (this%num_dims == 2) then 
           ! d_x u_y - d_y u_x
           call curls(ishape,qpoint)%set(3, actual_cell_interpolation%shape_derivatives(2,1,ishape,actual_qpoint)- &
                actual_cell_interpolation%shape_derivatives(1,2,ishape,actual_qpoint) )
        else if ( this%num_dims == 3) then
           ! d_y u_z - d_z u_y
           call curls(ishape,qpoint)%set(1, actual_cell_interpolation%shape_derivatives(3,2,ishape,actual_qpoint)- &
                actual_cell_interpolation%shape_derivatives(2,3,ishape,actual_qpoint) )
           ! d_z u_x - d_x u_z
           call curls(ishape,qpoint)%set(2, actual_cell_interpolation%shape_derivatives(1,3,ishape,actual_qpoint)- &
                actual_cell_interpolation%shape_derivatives(3,1,ishape,actual_qpoint) )
           ! d_x u_y - d_y u_x
           call curls(ishape,qpoint)%set(3, actual_cell_interpolation%shape_derivatives(2,1,ishape,actual_qpoint)- &
                actual_cell_interpolation%shape_derivatives(1,2,ishape,actual_qpoint) )
        end if
     end do
  end do
end subroutine nedelec_get_curls_vector

!==================================================================================================
subroutine nedelec_evaluate_fe_function_scalar( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(nedelec_reference_fe_t)   , intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  real(rp)                        , intent(in)    :: nodal_values(:)
  real(rp), allocatable           , intent(inout) :: quadrature_points_values(:)
  integer(ip) :: qpoint, ishape

  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for vector field unknowns '
  check( .false. )

end subroutine nedelec_evaluate_fe_function_scalar

!==================================================================================================
subroutine nedelec_evaluate_fe_function_vector( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(nedelec_reference_fe_t)    , intent(in)    :: this 
  type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(vector_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
  integer(ip) :: qpoint, inode, icomp, inode_scalar, istat

  if ( allocated(quadrature_points_values) ) then
    if ( size(quadrature_points_values) < actual_cell_interpolation%num_quadrature_points ) then
      deallocate(quadrature_points_values, stat=istat); check(istat==0);
      allocate(quadrature_points_values(actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
    end if
  else
    allocate(quadrature_points_values(actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
  end if
  
  do qpoint = 1, actual_cell_interpolation%num_quadrature_points
     call quadrature_points_values(qpoint)%init(0.0_rp)
     do inode = 1, this%num_shape_functions
        call quadrature_points_values(qpoint)%add( & 
             actual_cell_interpolation%shape_functions(:,inode,qpoint)*nodal_values(inode) )
     end do
  end do

end subroutine nedelec_evaluate_fe_function_vector

!==================================================================================================
subroutine nedelec_evaluate_fe_function_tensor( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(nedelec_reference_fe_t)    , intent(in)    :: this 
  type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(tensor_field_t), allocatable, intent(inout) :: quadrature_points_values(:)

  write(0,*) ' ERROR in: ',__FILE__,__LINE__
  write(0,*) ' Subroutine not implemented for tensor field unknowns '
  check( .false. )

end subroutine nedelec_evaluate_fe_function_tensor

subroutine nedelec_create_data_out_quadrature ( this, num_refinements, quadrature )
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: num_refinements
  type(quadrature_t)           , intent(inout) :: quadrature
  write(0,*) 'Nedelec Reference FE cannot create a quadrature for data_out visualization purposes'
  check(.false.)
end subroutine nedelec_create_data_out_quadrature 

subroutine nedelec_get_subelements_connectivity(this, connectivity)
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(inout) :: connectivity(:,:)
  write(0,*) 'Nedelec Reference FE cannot create a quadrature for data_out visualization purposes'
  check(.false.)
end subroutine nedelec_get_subelements_connectivity

!**************************************************************************************************
! Concrete TBPs of this derived data type
!**************************************************************************************************
!==================================================================================================
subroutine nedelec_assign_cell_map_duties (this, interpolation_duties,cell_map_duties)
  class(nedelec_reference_fe_t), intent(in)  :: this 
  type(interpolation_duties_t) , intent(in)  :: interpolation_duties
  type(cell_map_duties_t)      , intent(inout) :: cell_map_duties

  call cell_map_duties%assign_compute_jacobian_inverse(.true.)
  !call cell_map_duties%assign_compute_jacobian_derivative(.false.)
  massert(.not.interpolation_duties%compute_second_derivatives_is_assigned(),'Hessian not implemented for Nedelec')

end subroutine nedelec_assign_cell_map_duties

!==================================================================================================
subroutine nedelec_apply_cell_map_to_interpolation(this,cell_ressemblance,map,ref,phy,scaling_factor)
  implicit none
  class(nedelec_reference_fe_t)   , intent(in)    :: this 
  integer(ip)                     , intent(in)    :: cell_ressemblance
  type(cell_map_t)                , intent(in)    :: map
  type(interpolation_t)           , intent(in)    :: ref
  type(interpolation_t)           , intent(inout) :: phy
  real(rp), optional              , intent(in)    :: scaling_factor
  real(rp), allocatable :: wmat1(:,:,:)
  real(rp), allocatable :: wmat2(:,:,:), wvec1(:)
  integer(ip) :: ndime,nlocs,ntens
  integer(ip) :: ilocs,inode,idime,jdime,kdime,ldime

  ndime = ref%num_dims
  ntens = ref%num_entries_symmetric_tensor
  nlocs = ref%num_quadrature_points

  if ( cell_ressemblance == no_ressemblance ) then
     ! Contra-Piola map for shape functions
     ! \phi(x_g) = \phi(F(X_g))= inv(J^t)* \phi(X_g)
     phy%shape_functions=0.0_rp
     do ilocs=1,phy%num_quadrature_points
        do inode=1,this%num_shape_functions
           do idime=1,SPACE_DIM
              do jdime=1,SPACE_DIM
                 phy%shape_functions(idime,inode,ilocs) = phy%shape_functions(idime,inode,ilocs) &
                      + map%inv_jacobian(jdime,idime,ilocs)*ref%shape_functions(jdime,inode,ilocs)
              end do
           end do
        end do
     end do
    
     ! Contra-Piola map for shape derivatives
     ! \phi(x_g) = \phi(F(X_g))=  inv(J)^t (phi(X_g)) inv(J)
     if(phy%my_duties%compute_first_derivatives_is_assigned()) then
        phy%shape_derivatives=0.0_rp
        do ilocs=1,phy%num_quadrature_points
           do inode=1,this%num_shape_functions
              do idime=1,SPACE_DIM
                 do jdime=1,SPACE_DIM
                    do kdime=1,SPACE_DIM
                       do ldime=1,SPACE_DIM
                          phy%shape_derivatives(jdime,idime,inode,ilocs) = phy%shape_derivatives(jdime,idime,inode,ilocs) &
                               + map%inv_jacobian(ldime,jdime,ilocs)*ref%shape_derivatives(ldime,kdime,inode,ilocs)*map%inv_jacobian(kdime,idime,ilocs)
                       end do
                    end do
                 end do
              end do
           end do
        end do
     end if
  else if ( cell_ressemblance == is_scaled_and_translated ) then
     massert ( present(scaling_factor), 'Optional "scaling_factor" dummy argument MUST BE provided if cell_ressemblance == is_scaled_and_translated')
     phy%shape_functions(:,:,:) =  (1.0_rp/scaling_factor)*phy%shape_functions(:,:,:)
     
     ! Contra-Piola map for shape derivatives
     ! \phi(x_g) = \phi(F(X_g))=  inv(J)^t (phi(X_g)) inv(J)
     if(phy%my_duties%compute_first_derivatives_is_assigned()) then
        phy%shape_derivatives(:,:,:,:) = (1.0_rp/scaling_factor)*phy%shape_derivatives(:,:,:,:)*(1.0_rp/scaling_factor)
     end if
  end if
  massert(.not.phy%my_duties%compute_second_derivatives_is_assigned(),'Hessian not implemented for Nedelec')
end subroutine nedelec_apply_cell_map_to_interpolation

subroutine nedelec_apply_change_basis_matrix_to_nodal_values ( this, nodal_values_rt, nodal_values_pre_basis )
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this 
  real(rp)                            , intent(in)    :: nodal_values_rt(:)
  real(rp)                            , intent(out)   :: nodal_values_pre_basis(:)

  assert ( size(nodal_values_rt) == size(nodal_values_pre_basis) )
  assert ( size(nodal_values_rt) == this%num_shape_functions )
  
  nodal_values_pre_basis = 0.0_rp
  
#ifdef ENABLE_BLAS
  call DGEMV( 'N', & 
              this%num_shape_functions, &
              this%num_shape_functions, &
              1.0_rp, &
              this%change_basis_matrix, &
              this%num_shape_functions, &
              nodal_values_rt, &
              1, &
              0.0_rp, & 
              nodal_values_pre_basis, & 
              1)
#else
  write (0,*) 'Error: reference_fe.f90 was not compiled with -DENABLE_BLAS.'
  write (0,*) 'Error: You must activate this cpp macro in order to use the BLAS'
  check(.false.)
#endif 
  
end subroutine  nedelec_apply_change_basis_matrix_to_nodal_values 
  

subroutine nedelec_apply_change_basis_matrix_to_interpolation(this, interpolation_pre_basis, interpolation)
  implicit none
  class(nedelec_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: interpolation_pre_basis
  type(interpolation_t)               , intent(inout) :: interpolation
  
  integer(ip)           :: i, j, idime, jdime, qpoint

  ! Compute shape functions
  interpolation%shape_functions   = 0.0_rp
  do qpoint = 1, interpolation%num_quadrature_points
     do i=1, this%num_shape_functions
        do j=1, this%num_shape_functions
           do idime=1, SPACE_DIM
              interpolation%shape_functions(idime, i, qpoint) = interpolation%shape_functions(idime, i, qpoint) + &
                   this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_functions(idime, j, qpoint)
           end do
        end do
     end do
  end do
   
  if(interpolation%my_duties%compute_first_derivatives_is_assigned()) then
     ! Compute shape derivatives
     interpolation%shape_derivatives = 0.0_rp
    do qpoint = 1, interpolation%num_quadrature_points
        do i=1, this%num_shape_functions
           do j=1, this%num_shape_functions
              do idime=1, SPACE_DIM
                 do jdime=1, SPACE_DIM
                    interpolation%shape_derivatives(idime, jdime, i, qpoint) = interpolation%shape_derivatives(idime, jdime, i, qpoint) + &
                         this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_derivatives(idime, jdime, j, qpoint)
                 end do
              end do
           end do
        end do
     end do
  end if
end subroutine nedelec_apply_change_basis_matrix_to_interpolation

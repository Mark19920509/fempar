! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************
!==================================================================================================
subroutine tet_lagrangian_reference_fe_create( this, topology, num_dims, order, field_type, & 
     &  conformity, continuity )
  implicit none 
  class(tet_lagrangian_reference_fe_t), intent(inout) :: this
  character(*)                            , intent(in)    :: topology
  integer(ip)                             , intent(in)    :: num_dims
  integer(ip)                             , intent(in)    :: order
  character(*)                            , intent(in)    :: field_type
  logical                                 , intent(in)    :: conformity
  logical                      , optional , intent(in)    :: continuity

  assert ( order >= 0 )

  call this%free()
  call this%set_common_data(num_dims,order,field_type,conformity,continuity)
  call this%set_topology ( topology )
  call this%set_fe_type( fe_type_lagrangian )
  call this%fill()
end subroutine tet_lagrangian_reference_fe_create

!==================================================================================================
function tet_lagrangian_reference_fe_check_compatibility_of_n_faces                   &
     &                      (target_reference_fe,source_reference_fe, source_n_face_id,target_n_face_id)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)  :: target_reference_fe
  class(reference_fe_t)               , intent(in)  :: source_reference_fe
  integer(ip)                         , intent(in)  :: source_n_face_id ! Local n-face ID
  integer(ip)                         , intent(in)  :: target_n_face_id ! Local n-face ID
  logical :: tet_lagrangian_reference_fe_check_compatibility_of_n_faces 
  integer(ip) :: idime

  select type(source_reference_fe)
     class is(tet_lagrangian_reference_fe_t)
        ! Get number nodes per dimension
     assert (target_reference_fe%num_dims == source_reference_fe%num_dims)
     do idime = 1, target_reference_fe%num_dims
        assert (target_reference_fe%order_vector(idime) == source_reference_fe%order_vector(idime))
     end do
     assert (target_reference_fe%get_n_face_dim(target_n_face_id) ==  source_reference_fe%get_n_face_dim(source_n_face_id))
     assert (target_reference_fe%get_n_face_dim(target_n_face_id) < 3)
     assert (target_reference_fe%num_field_components == source_reference_fe%num_field_components)
     assert (target_reference_fe%get_num_own_dofs_n_face(target_n_face_id) == source_reference_fe%get_num_own_dofs_n_face(source_n_face_id))
     tet_lagrangian_reference_fe_check_compatibility_of_n_faces = .true.
     class default
     tet_lagrangian_reference_fe_check_compatibility_of_n_faces = .false.
  end select

end function tet_lagrangian_reference_fe_check_compatibility_of_n_faces

!=================================================================================================
function tet_lagrangian_reference_fe_get_characteristic_length ( this )
  implicit none 
  class(tet_lagrangian_reference_fe_t), intent(in) :: this 
  real(rp)  :: tet_lagrangian_reference_fe_get_characteristic_length 
  tet_lagrangian_reference_fe_get_characteristic_length =   &
       &   real(get_factorial(this%num_dims),rp)**(-1.0_rp/real(this%num_dims,rp))
end function tet_lagrangian_reference_fe_get_characteristic_length

!==================================================================================================
function tet_lagrangian_reference_fe_get_num_subcells(this, num_refinements) result(num_subcells)
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  integer(ip)                                         :: num_subcells
  num_subcells = (num_refinements+1)**this%num_dims
end function tet_lagrangian_reference_fe_get_num_subcells

!==================================================================================================
subroutine tet_lagrangian_reference_fe_get_subcells_connectivity(this, num_refinements, connectivity)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  integer(ip)                         , intent(inout) :: connectivity(:,:)
  integer(ip) :: order_vector(SPACE_DIM)
  integer(ip) :: num_subelems
  integer(ip) :: subelem
  integer(ip) :: geo_nnodes
  integer(ip) :: local_node
  integer(ip) :: first_coord(this%num_dims)
  integer(ip) :: local_coord(this%num_dims)
  integer(ip) :: global_coord(this%num_dims)
  integer(ip) :: ones_dim(this%num_dims)

  if(num_refinements > 0) then
    if ( num_refinements==1 .and. this%num_dims == 2 ) then
      assert(size(connectivity,1) == 3)
      assert(size(connectivity,2) == 4)
      connectivity(:,1) = [1,2,4]
      connectivity(:,2) = [5,4,2]
      connectivity(:,3) = [2,3,5]
      connectivity(:,4) = [4,5,6]
      return
    else if ( num_refinements==1 .and. this%num_dims == 3 ) then
      assert(size(connectivity,1) == 4)
      assert(size(connectivity,2) == 8)
      connectivity(:,1) = [ 2, 8, 3, 5]
      connectivity(:,2) = [ 6, 9, 4, 5]
      connectivity(:,3) = [10, 7, 9, 8]
      connectivity(:,4) = [ 4, 9, 2, 5]
      connectivity(:,5) = [ 2, 9, 8, 5]
      connectivity(:,6) = [ 2, 9, 7, 8]
      connectivity(:,7) = [ 4, 9, 7, 2]
      connectivity(:,8) = [ 4, 7, 1, 2]
      return
    end if
     ! this subroutine is not implemented for tet_lagrangrian
     ! but magically wors for order 1 tets
     check(.false.) !Not working
  endif
  ones_dim = 1
  num_subelems = this%get_num_subcells(num_refinements=num_refinements)
  geo_nnodes = this%get_num_vertices()
  assert(size(connectivity,1) == geo_nnodes)
  assert(size(connectivity,2) == num_subelems)
  order_vector = num_refinements+1


  do subelem = 1, num_subelems
     !call this%get_node_local_coordinates(first_coord,subelem, & 
     !                                      & this%num_dims,this%order(1)-1)
     call index_to_ijk( subelem, this%num_dims, order_vector, first_coord )

     do local_node = 1, geo_nnodes
        !call this%get_node_local_coordinates(local_coord,local_node,this%num_dims,1)
        call index_to_ijk( local_node, this%num_dims, 2*ones_dim, local_coord )

        global_coord = first_coord + local_coord 
        !connectivity(local_node, subelem) = this%get_node_local_id(global_coord, &
        !                                                   & this%num_dims,this%order(1)) ! 
        connectivity(local_node, subelem) = ijk_to_index(global_coord, order_vector,this%num_dims)+1
     end do
  end do
end subroutine tet_lagrangian_reference_fe_get_subcells_connectivity

!==================================================================================================
subroutine tet_lagrangian_reference_fe_get_subelements_connectivity ( this, connectivity )
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip),                          intent(inout) :: connectivity(:,:)
  integer(ip) :: num_subelems
  integer(ip) :: subelem
  integer(ip) :: geo_nnodes
  integer(ip) :: local_node
  integer(ip) :: first_coord(this%num_dims)
  integer(ip) :: local_coord(this%num_dims)
  integer(ip) :: global_coord(this%num_dims)

  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for triangles/tetrahedra '
  check( .false. )

end subroutine tet_lagrangian_reference_fe_get_subelements_connectivity

!==================================================================================================
subroutine tet_lagrangian_reference_fe_generate_own_dofs_cell_permutations (this)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(inout) :: this
  integer(ip) :: idime
  ! Create emtpy permutation table, we do not want to fill own node permutations for tets since 
  ! meshes are ordered.
  do idime=1,this%num_dims-1
     this%own_dof_permutations(idime)%nd1 = 0
     this%own_dof_permutations(idime)%nd2 = 0
  end do
end subroutine tet_lagrangian_reference_fe_generate_own_dofs_cell_permutations

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_qpoints_permutations (this, quadrature, qpoints_perm)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(in)    :: quadrature
  type(allocatable_array_ip2_t)       , intent(inout) :: qpoints_perm
  integer(ip)    :: ndime, n_q_points, i

  ndime      = quadrature%get_num_dims()
  n_q_points = quadrature%get_num_quadrature_points()


  call qpoints_perm%create(n_q_points, &    ! Number of quadrature points
       &                ndime*2**ndime)  ! Number of possible permutations x possible rotations
  forall (i = 1:qpoints_perm%nd1) qpoints_perm%a(i,:) = i

end subroutine tet_lagrangian_reference_fe_fill_qpoints_permutations

!**************************************************************************************************
! Deferred TBP implementors from lagrangian_reference_fe_t
!**************************************************************************************************

!==================================================================================================
subroutine tet_lagrangian_create_data_out_quadrature ( this, num_refinements, quadrature )
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  type(quadrature_t)                  , intent(inout) :: quadrature
  integer(ip)                                         :: order_vector(SPACE_DIM)
  type(node_array_t)                                  :: node_array 
  integer(ip)                                         :: i

  if(num_refinements > 0) then
     ! this subroutine is not tested yet for tet_lagrangrian
     check(.false.) !Not working
  endif

  assert ( num_refinements >= 0 )

  call quadrature%free()

  order_vector = num_refinements+1
  call node_array%create( this%polytope, order_vector ) 
  call quadrature%create( this%num_dims, node_array%num_nodes )

  do i=1,this%num_dims
     quadrature%coordinates(i,:) = node_array%coordinates(i,:)*(1.0_rp/order_vector(i))
  end do
  quadrature%weight = 1.0_rp
  call node_array%free()
end subroutine tet_lagrangian_create_data_out_quadrature

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_quadrature ( this, quadrature ) 
  !-----------------------------------------------------------------------
  ! 
  !     This routine sets up the integration constants of open rules for
  !     triangles and tetrahedra mapping hexahedra quadratures
  !
  !-----------------------------------------------------------------------
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(inout) :: quadrature
  call quadrature%fill_tet_gauss_legendre()
end subroutine tet_lagrangian_reference_fe_fill_quadrature

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_nodal_quadrature( this, quadrature )
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)                  , intent(inout) :: quadrature
  integer(ip) :: i

  do i=1,this%num_dims
     if ( this%order_vector(i) > 0 ) then 
        quadrature%coordinates(i,:) = this%node_array%coordinates(i,:)*(1.0_rp/this%order_vector(i))
     else 
        quadrature%coordinates(i,:) = this%node_array%coordinates(i,:)
     end if
  end do
  quadrature%weight = 1.0_rp
end subroutine tet_lagrangian_reference_fe_fill_nodal_quadrature

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_interpolation( this, quadrature, interpolation, order_vector )
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in) :: this
  type(quadrature_t)                      , intent(in)         :: quadrature
  type(interpolation_t)                   , intent(inout)      :: interpolation    
  integer(ip)                  , optional , intent(in)         :: order_vector(SPACE_DIM)

  type(interpolation_t) :: interpolation_pre_basis

  if ( .not. this%basis_changed ) then
     call this%fill_interpolation_pre_basis ( quadrature, interpolation, order_vector )
  else
     call interpolation_pre_basis%clone(interpolation)
     call this%fill_interpolation_pre_basis ( quadrature, interpolation_pre_basis, order_vector ) 
     call this%apply_change_basis_matrix_to_interpolation ( interpolation_pre_basis, interpolation )
     call interpolation_pre_basis%free()
  end if
end subroutine tet_lagrangian_reference_fe_fill_interpolation

!==================================================================================================

subroutine tet_lagrangian_reference_fe_fill_interp_restricted_to_facet (this, local_quadrature, &
     & facet_lid, subfacet_lid, facet_interpolation)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                      , intent(in)    :: local_quadrature
  integer(ip)                             , intent(in)    :: facet_lid
  integer(ip)                             , intent(in)    :: subfacet_lid
  type(interpolation_t)                   , intent(inout) :: facet_interpolation
  type(quadrature_t) :: aux_quadrature
  integer(ip) :: c,idime,iface,n_face_index
  
  ! Exit if attempts to fill the interpolation of a subface
  if ( subfacet_lid >= 0 ) return
  
  ! Add offset to have same numbering as in polytope
  n_face_index = facet_lid+this%get_first_facet_id()-1

  ! Create a d-dimensional quadrature as follows
  call aux_quadrature%create( this%num_dims, local_quadrature%num_quadrature_points )
  c = 0
  do idime = 0,this%num_dims-1
     if ( this%polytope%n_face_dir_is_fixed( n_face_index, idime ) == 1 ) then
        c = c+1
        aux_quadrature%coordinates(idime+1,:) = local_quadrature%coordinates(c,:)
     else if ( this%polytope%n_face_dir_coordinate( n_face_index, idime ) == 0 ) then
        aux_quadrature%coordinates(idime+1,:) = 0.0_rp
     else 
        aux_quadrature%coordinates(idime+1,:) = 1 - sum(local_quadrature%coordinates(:,:),1)
     end if
  end do

  !if ( .not. this%basis_changed ) call this%fill_interpolation_pre_basis ( aux_quadrature, facet_interpolation ) !( aux_quadrature, facet_interpolation ) 
  call this%fill_interpolation( aux_quadrature, facet_interpolation ) 
  call aux_quadrature%free()

end subroutine tet_lagrangian_reference_fe_fill_interp_restricted_to_facet

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_interp_restricted_to_edget( this, local_edge_id, local_quadrature, edget_interpolation )
  implicit none
  class(tet_lagrangian_reference_fe_t)    , intent(in)    :: this
  integer(ip)                             , intent(in)    :: local_edge_id
  type(quadrature_t)                      , intent(in)    :: local_quadrature
  type(interpolation_t)                   , intent(inout) :: edget_interpolation
  type(quadrature_t) :: aux_quadrature
  integer(ip) :: c, idime, n_face_index, qpoin

  ! Add offset to have same numbering as in polytope
  n_face_index = local_edge_id+this%get_first_n_face_id_of_dim(1)-1

  ! Create a d-dimensional quadrature as follows: 
  ! Non-orthogonal directions are taken into account with the (1-d) factor for the free and anchor node dimension 
  call aux_quadrature%create( this%num_dims, local_quadrature%num_quadrature_points )

  do idime = 0,this%num_dims-1
     if ( (this%polytope%n_face_dir_is_fixed( n_face_index, idime )==1) .and. (this%polytope%n_face_dir_coordinate( n_face_index, idime )==0) ) then
        aux_quadrature%coordinates(idime+1,:) = local_quadrature%coordinates(1,:)  
     elseif  ( (this%polytope%n_face_dir_is_fixed( n_face_index, idime )==0) .and. (this%polytope%n_face_dir_coordinate( n_face_index, idime )==1) ) then 
        do qpoin = 1, local_quadrature%num_quadrature_points
           aux_quadrature%coordinates(idime+1, qpoin) = 1.0_rp - local_quadrature%coordinates(1,qpoin)
        end do
     else 
        aux_quadrature%coordinates(idime+1,:) = 0.0_rp
     end if
  end do

  call this%fill_interpolation( aux_quadrature, edget_interpolation ) 
  call aux_quadrature%free()

end subroutine tet_lagrangian_reference_fe_fill_interp_restricted_to_edget

!=================================================================================================
function tet_lagrangian_reference_fe_compute_num_quadrature_points( this, degree, dimension )
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                             , intent(in)    :: degree
  integer(ip)                             , intent(in)    :: dimension
  integer(ip) :: tet_lagrangian_reference_fe_compute_num_quadrature_points

  if( dimension == 1 ) then
     tet_lagrangian_reference_fe_compute_num_quadrature_points = int(ceiling(real(degree,rp)/2.0_rp),ip)+1
  elseif( dimension == 2 ) then
     !*************************************************************************
     ! Using efficent symmetrical gaussian quadrature rules (when available). 
     if( degree <= 2 ) then
        tet_lagrangian_reference_fe_compute_num_quadrature_points = 3
     elseif( degree <= 4 ) then
        tet_lagrangian_reference_fe_compute_num_quadrature_points = 6
     elseif( degree <= 6 ) then
        tet_lagrangian_reference_fe_compute_num_quadrature_points = 13
     elseif( degree <= 8 ) then
        tet_lagrangian_reference_fe_compute_num_quadrature_points = 19
     elseif( degree <= 10 ) then
        tet_lagrangian_reference_fe_compute_num_quadrature_points = 28
     else ! Quadratures based on brick quadratures transformation
        tet_lagrangian_reference_fe_compute_num_quadrature_points = int((ceiling(real(degree,rp)/2.0_rp) + 1.0_rp )**2.0_rp,ip)
     end if
  elseif( dimension == 3 ) then
     !*************************************************************************
     ! Using efficent symmetrical gaussian quadrature rules (when available). 
     if( degree <= 2 ) then
        tet_lagrangian_reference_fe_compute_num_quadrature_points = 4
     elseif( degree <= 4) then
        tet_lagrangian_reference_fe_compute_num_quadrature_points = 11
     else ! Quadratures based on brick quadratures transformation
        tet_lagrangian_reference_fe_compute_num_quadrature_points = int((ceiling(real(degree,rp)/2.0_rp) + 2.0_rp )**3.0_rp,ip)
     end if
  end if

end function tet_lagrangian_reference_fe_compute_num_quadrature_points

!==================================================================================================
function tet_lagrangian_reference_fe_get_node_local_id (this, local_coordinates, & 
     & num_dims, order)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: local_coordinates(:)
  integer(ip)                         , intent(in)    :: num_dims
  integer(ip)                         , intent(in)    :: order
  integer(ip) :: tet_lagrangian_reference_fe_get_node_local_id
  integer(ip) :: k,q

  if (sum(local_coordinates)>order) then
     write(*,*) 'ijk', local_coordinates
     write(*,*) 'tets_setting:: gijk:: ERROR i+j+k<=p'
     check(.false.)
  end if

  tet_lagrangian_reference_fe_get_node_local_id = 1
  do k =1,num_dims-1
     q = order-local_coordinates(k+1)
     tet_lagrangian_reference_fe_get_node_local_id =   & 
          & tet_lagrangian_reference_fe_get_node_local_id + & 
          & this%compute_sum_of_dofs_in_simplices(k,q-local_coordinates(k)+1,q)
  end do
  tet_lagrangian_reference_fe_get_node_local_id =   & 
       & tet_lagrangian_reference_fe_get_node_local_id + & 
       & this%compute_sum_of_dofs_in_simplices(k,order-local_coordinates(num_dims)+1,order)

end function tet_lagrangian_reference_fe_get_node_local_id

!=================================================================================================
subroutine tet_lagrangian_reference_fe_set_permutation_2D( this, permutation, num_nodes_x_dim, &
     & orientation, rotation )
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(inout) :: permutation(:)
  integer(ip)                         , intent(in)    :: num_nodes_x_dim,orientation,rotation
  integer(ip) :: o_r,i,j,ij_t(3)     ! ij_t = (i,j,p-i-j)
  integer(ip) :: ij_n(2),go,gn
  integer(ip) :: ij_perm_tet(2,6) = reshape((/ 1, 2, 2, 3, 3, 1, 2, 1, 3, 2, 1, 3/), (/2,6/) )

  ! Generic loop+rotation identifier  
  o_r = 3*(orientation-1)+rotation
  do j = 0,num_nodes_x_dim-1
     ij_t(2) = j
     do i = 0,num_nodes_x_dim-j-1
        ij_t(1) = i
        ij_t(3) = num_nodes_x_dim-i-j-1
        ! Get the global numbering of node (i,j)
        go = this%get_node_local_id(ij_t(1:2),2,num_nodes_x_dim-1)
        ! i,j coordinates for the o_r permutation
        ij_n(1:2) = ij_t(ij_perm_tet(1:2,o_r)) 
        ! Store the global numbering of node ij_n 
        permutation(go) = this%get_node_local_id(ij_n,2,num_nodes_x_dim-1)
     end do
  end do

end subroutine tet_lagrangian_reference_fe_set_permutation_2D

!=================================================================================================
recursive function tet_lagrangian_reference_fe_compute_num_nodes_scalar(this, order, dimension)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this 
  integer(ip)                         , intent(in)    :: dimension
  integer(ip)                         , intent(in)    :: order
  integer(ip) :: tet_lagrangian_reference_fe_compute_num_nodes_scalar
  integer(ip) :: q
  if (dimension == 0) then
     tet_lagrangian_reference_fe_compute_num_nodes_scalar = 1
  elseif (order == 0) then
     tet_lagrangian_reference_fe_compute_num_nodes_scalar = 1
  elseif (dimension == 1) then
     tet_lagrangian_reference_fe_compute_num_nodes_scalar = order+1
  elseif (dimension == 2) then
     tet_lagrangian_reference_fe_compute_num_nodes_scalar = int((order+1)*(order+2)/2)
  else
     tet_lagrangian_reference_fe_compute_num_nodes_scalar = & 
          & this%compute_num_nodes_scalar(dimension-1,0)
     do q=1,order
        tet_lagrangian_reference_fe_compute_num_nodes_scalar = & 
             & tet_lagrangian_reference_fe_compute_num_nodes_scalar + & 
             & this%compute_num_nodes_scalar(dimension-1,q)
     end do
  end if
end function tet_lagrangian_reference_fe_compute_num_nodes_scalar

!**************************************************************************************************
! Concrete TBPs of this derived data type
!**************************************************************************************************

!==================================================================================================
recursive subroutine tet_lagrangian_reference_fe_fill_nodes_n_face(this,ntxob,c3,ini,end, &
     & i,idm,nd,k,p,objec,nt)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: ini,end,nd,k,p,objec(nd,nd+1),nt,i
  integer(ip)                         , intent(inout) :: ntxob(nt),c3,idm(nd)
  integer(ip) :: j,ijk(nd),m

  if (k==0) then
     ! Dimension 0: objec gives the coordinates of the corner
     ijk = p*objec(:,1)
     ntxob(c3) = this%get_node_local_id(ijk,nd,p)
     c3 = c3 + 1
  else
     ! Loop over the possible values of the i-th factor
     do j=ini,end
        ! Assign value of the i-th factor
        idm(i) = j
        if (i<k) then
           ! Assign values of the i+1-th factor
           call this%fill_nodes_n_face(ntxob,c3,ini,end-j,i+1,idm,nd,k,p,objec,nt)
        else
           ! Compute the coordinate of the c3-th node: objec(:,1)+idm*objec(:,2:k)
           ijk = p*objec(:,1)
           do m=1,k
              ijk = ijk+idm(k-m+1)*objec(:,m+1)
           end do
           ! Store in ntxob the corresponding identifier of the node
           ntxob(c3) = this%get_node_local_id(ijk,nd,p)
           c3 = c3 + 1
        end if
     end do
  end if

end subroutine tet_lagrangian_reference_fe_fill_nodes_n_face

!==================================================================================================
recursive subroutine tet_lagrangian_reference_fe_fill_n_face_dim_and_vertices (this,       &
     n_face_dim,        &
     vertex_position,      &
     num_dims, &
     initial_vertex,       &
     num_n_faces,       &
     n_face_id,               &
     vertices_of_n_faces,      &
     n_face_dim_and_vertices)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: n_face_dim
  integer(ip)                         , intent(in)    :: vertex_position
  integer(ip)                         , intent(in)    :: num_dims
  integer(ip)                         , intent(in)    :: initial_vertex
  integer(ip)                         , intent(in)    :: num_n_faces
  integer(ip)                         , intent(inout) :: n_face_dim_and_vertices(:,:)
  integer(ip)                         , intent(inout) :: vertices_of_n_faces(:)
  integer(ip)                         , intent(inout) :: n_face_id
  integer(ip) :: vertex_id

  do vertex_id=initial_vertex,num_dims+1
     vertices_of_n_faces(vertex_position) = vertex_id
     if(vertex_position+1<n_face_dim+2) then
        call this%fill_n_face_dim_and_vertices(n_face_dim,                      &
             vertex_position+1,                  &
             num_dims,               &
             vertices_of_n_faces(vertex_position)+1, &
             num_n_faces,                     &
             n_face_id,                             &
             vertices_of_n_faces,                    &
             n_face_dim_and_vertices)
     else
        n_face_dim_and_vertices(1,n_face_id) = n_face_dim
        n_face_dim_and_vertices(2:n_face_dim+2,n_face_id) = vertices_of_n_faces(1:n_face_dim+1)
        n_face_id = n_face_id + 1
     end if
  end do

end subroutine tet_lagrangian_reference_fe_fill_n_face_dim_and_vertices

!=================================================================================================
recursive function tet_lagrangian_reference_fe_compute_num_interior_dofs(this,dimension,order)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this  
  integer(ip)                         , intent(in)    :: dimension, order
  integer(ip) :: tet_lagrangian_reference_fe_compute_num_interior_dofs
  integer(ip) :: q
  if (dimension == 0) then
     tet_lagrangian_reference_fe_compute_num_interior_dofs = 1
  elseif (order == 1) then
     tet_lagrangian_reference_fe_compute_num_interior_dofs = 0
  elseif (dimension == 1) then
     tet_lagrangian_reference_fe_compute_num_interior_dofs = order-1
  elseif (dimension == 2) then
     tet_lagrangian_reference_fe_compute_num_interior_dofs = int((order-2)*(order-1)/2)
  else
     tet_lagrangian_reference_fe_compute_num_interior_dofs = & 
          & this%compute_num_interior_dofs(dimension-1,1)
     do q=2,order-1
        tet_lagrangian_reference_fe_compute_num_interior_dofs =    & 
             & tet_lagrangian_reference_fe_compute_num_interior_dofs + & 
             & this%compute_num_interior_dofs(dimension-1,q)
     end do
  end if
end function tet_lagrangian_reference_fe_compute_num_interior_dofs

!=================================================================================================
function tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices(this,dimension, & 
     & ini_order,end_order)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: dimension, ini_order, end_order
  integer(ip) :: tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices
  integer(ip) :: q
  if (dimension == 0) then
     tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices = 1
  elseif (ini_order > end_order) then
     tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices = 0
  else
     tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices = & 
          & this%compute_num_nodes_scalar(dimension-1,ini_order)
     do q = ini_order+1,end_order
        tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices =   & 
             & tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices + &
             & this%compute_num_nodes_scalar(dimension-1,q)
     end do
  end if
end function tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices

!==================================================================================================
subroutine tet_lagrangian_reference_fe_get_n_face_orientation(this,o,od,nd,io)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(inout) :: o
  integer(ip)                         , intent(in)    :: od
  integer(ip)                         , intent(in)    :: nd
  integer(ip)                         , intent(in)    :: io  ! io=numbering of the n-face in the od dimension
  if (nd == 3 .and. od == 2) then
     o = modulo(io+1,2)
  elseif (nd>3) then
     write(*,*) __FILE__,__LINE__,'WARNING!! the orientation is not defined for dimension >3'
  else
     o = 0
  end if
end subroutine tet_lagrangian_reference_fe_get_n_face_orientation

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_interpolation_pre_basis ( this, quadrature, interpolation, order_vector ) 
  implicit none 
  class(tet_lagrangian_reference_fe_t), intent(in) :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation
  integer(ip) , optional          , intent(in)    :: order_vector(SPACE_DIM)

  type(truncated_tensor_product_polynomial_space_t)        :: tet_polynomial_prebase
  type(polynomial_basis_t)  :: monomial_1D_basis(SPACE_DIM)
  type(monomial_t)                      :: monomial_1D

  real(rp), allocatable :: values(:)
  real(rp), allocatable :: gradients(:,:)
  real(rp), allocatable :: second_derivatives(:,:)
  integer(ip) :: idime, q_point

  do idime=1,interpolation%num_dims
     call monomial_1D%generate_basis(this%order_vector(idime), monomial_1D_basis(idime) )
  end do

  call tet_polynomial_prebase%create(interpolation%num_dims,monomial_1D_basis)
  call tet_polynomial_prebase%fill( quadrature%get_pointer_coordinates() )

  call memalloc(tet_polynomial_prebase%get_num_polynomials(),values,__FILE__,__LINE__)
  do q_point=1, quadrature%get_num_quadrature_points()
     call tet_polynomial_prebase%evaluate_values( q_point, values )
     interpolation%shape_functions(1,:,q_point) = values(:)
  end do
  call memfree(values,__FILE__,__LINE__)
  
  if(interpolation%my_duties%compute_first_derivatives_is_assigned()) then
     call memalloc(SPACE_DIM,tet_polynomial_prebase%get_num_polynomials(),gradients,__FILE__,__LINE__)
     do q_point=1, quadrature%get_num_quadrature_points()
        call tet_polynomial_prebase%evaluate_gradients( q_point, gradients )
        interpolation%shape_derivatives(1,:,:,q_point) = gradients(:,:)
     end do
     call memfree(gradients,__FILE__,__LINE__)
  end if
  
  if(interpolation%my_duties%compute_second_derivatives_is_assigned()) then
     call memalloc(interpolation%num_entries_symmetric_tensor,   &
                   tet_polynomial_prebase%get_num_polynomials(), &
                   second_derivatives,__FILE__,__LINE__)
     do q_point=1, quadrature%get_num_quadrature_points()
        call tet_polynomial_prebase%evaluate_second_derivatives( q_point, second_derivatives )
        interpolation%hessian(1,:,:,q_point) = second_derivatives(:,:)
     end do
     call memfree(second_derivatives,__FILE__,__LINE__)
  end if

  do idime=1,interpolation%num_dims
     call monomial_1D_basis(idime)%free()
  end do
  call monomial_1D%free()
  call tet_polynomial_prebase%free()
end subroutine tet_lagrangian_reference_fe_fill_interpolation_pre_basis

!==================================================================================================
subroutine tet_lagrangian_reference_fe_change_basis(this) 
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(inout) ::  this

  type(interpolation_t)   :: interpolation
  integer(ip)             :: i, j, num_shape_functions_x_component

  num_shape_functions_x_component = this%num_shape_functions
  call memalloc(num_shape_functions_x_component,num_shape_functions_x_component,this%change_basis_matrix,__FILE__,__LINE__)
  call this%create_interpolation(this%nodal_quadrature,interpolation)
  do i=1,num_shape_functions_x_component
     do j=1,num_shape_functions_x_component
        !write(*,*) 'Shape',j,'point',i
        !write(*,*) interpolation%shape_functions(1,j,i)
        this%change_basis_matrix(i,j) = interpolation%shape_functions(1,j,i)
     end do
  end do
  call interpolation%free()
  call this%invert_change_basis_matrix()
  this%basis_changed = .true.
end subroutine tet_lagrangian_reference_fe_change_basis

!==================================================================================================
subroutine tet_lagrangian_ref_fe_apply_change_basis_to_interpolation(this, interpolation_pre_basis, interpolation)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)                   , intent(in)    :: interpolation_pre_basis
  type(interpolation_t)                   , intent(inout) :: interpolation

  integer(ip)           :: i, j, jdime, jtens, qpoint, num_shape_functions_x_component

  ! Initialize both shape functions and derivatives to zero.
  interpolation%shape_functions   = 0.0_rp
  num_shape_functions_x_component = this%num_shape_functions/this%num_field_components

  ! Compute shape functions
  do qpoint = 1, interpolation%num_quadrature_points
     do i=1, num_shape_functions_x_component
        do j=1, num_shape_functions_x_component
           interpolation%shape_functions(1, i, qpoint) = interpolation%shape_functions(1, i, qpoint) + &
                this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_functions(1, j, qpoint)
        end do
     end do
  end do

  if(interpolation%my_duties%compute_first_derivatives_is_assigned()) then
     ! Compute shape derivatives
     interpolation%shape_derivatives = 0.0_rp
     do qpoint = 1, interpolation%num_quadrature_points
        do i=1, num_shape_functions_x_component
           do j=1, num_shape_functions_x_component
              do jdime=1, this%num_dims
                 interpolation%shape_derivatives(1, jdime, i, qpoint) = interpolation%shape_derivatives(1, jdime, i, qpoint) + &
                      this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_derivatives(1, jdime, j, qpoint)
              end do
           end do
        end do
     end do
  end if

  if(interpolation%my_duties%compute_second_derivatives_is_assigned()) then
     ! Compute shape functions hessian
     interpolation%hessian = 0.0_rp
     do qpoint = 1, interpolation%num_quadrature_points
        do i=1, num_shape_functions_x_component
           do j=1, num_shape_functions_x_component
              do jtens=1, interpolation%num_entries_symmetric_tensor
                 interpolation%hessian(1, jtens, i, qpoint) = interpolation%hessian(1, jtens, i, qpoint) + &
                      this%change_basis_matrix(j,i) * interpolation_pre_basis%hessian(1, jtens, j, qpoint)
              end do
           end do
        end do
     end do
  end if

end subroutine tet_lagrangian_ref_fe_apply_change_basis_to_interpolation

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_h_refinement_interpolation(this)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(inout)    :: this 
  ! To be implemented ...
end subroutine tet_lagrangian_reference_fe_fill_h_refinement_interpolation

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_h_refinement_permutations(this)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(inout)    :: this 
  ! To be implemented ...
end subroutine tet_lagrangian_reference_fe_fill_h_refinement_permutations

!==================================================================================================
subroutine tlrf_fill_scalar_coarsening_projection_operator(this)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(inout)    :: this 
  ! To be implemented ... 
end subroutine tlrf_fill_scalar_coarsening_projection_operator

!==================================================================================================
subroutine tlrf_scalar_to_multicomp_coarsening_projection_operator(this)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(inout)    :: this 
  ! To be implemented ... 
end subroutine tlrf_scalar_to_multicomp_coarsening_projection_operator

!==================================================================================================
function tet_lagrangian_reference_fe_compute_permutation_index(source_reference_fe, target_reference_fe,          &
     &                                          source_n_face_id, target_n_face_id,         &
     &                                          source_n_faces, target_n_faces)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)  :: source_reference_fe
  class(reference_fe_t)               , intent(in)  :: target_reference_fe
  integer(ip)                         , intent(in)  :: source_n_face_id ! Local n-face ID
  integer(ip)                         , intent(in)  :: target_n_face_id ! Local n-face ID
  integer(ip)                         , intent(in)  :: source_n_faces(:)
  integer(ip)                         , intent(in)  :: target_n_faces(:) 
  integer(ip) :: tet_lagrangian_reference_fe_compute_permutation_index
  tet_lagrangian_reference_fe_compute_permutation_index = 1
end function tet_lagrangian_reference_fe_compute_permutation_index

!==================================================================================================
function tet_lagrangian_reference_fe_permute_dof_LID_n_face(this,source_dof_lid_n_face,n_face_dim,permutation_index)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)  :: this
  integer(ip)                         , intent(in)  :: source_dof_lid_n_face
  integer(ip)                         , intent(in)  :: n_face_dim
  integer(ip)                         , intent(in)  :: permutation_index
  integer(ip) :: tet_lagrangian_reference_fe_permute_dof_LID_n_face
  tet_lagrangian_reference_fe_permute_dof_LID_n_face = source_dof_lid_n_face
end function tet_lagrangian_reference_fe_permute_dof_LID_n_face



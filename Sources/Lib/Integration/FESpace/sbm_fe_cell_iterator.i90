! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
subroutine fe_cell_iterator_create ( this, fe_space, fe_cell_predicate)
  implicit none
  class(fe_cell_iterator_t)                            ,  intent(inout) :: this
  class(serial_fe_space_t)                     , target,  intent(in)    :: fe_space
  class(fe_cell_predicate_t),     optional     , target,  intent(in)    :: fe_cell_predicate
  integer(ip) :: istat, field_id
  call this%free()
  call aux_create(this, fe_space, fe_cell_predicate)
  call this%set_integration_updated(.false.)
  this%cell_integration_is_set_up = fe_space%cell_integration_was_set_up()
  if (   this%cell_integration_is_set_up .and. &
       & this%fe_space%cell_quadratures%size() == 1 .and. &
       & this%fe_space%cell_integrators%size() == this%fe_space%get_num_fields() ) then
    this%single_quad_cell_map_cell_integs = .true.
    this%quadrature => this%fe_space%cell_quadratures%get_pointer(1)
    assert ( this%fe_space%cell_maps%size() == 1 ) 
    this%cell_map => this%fe_space%cell_maps%get_pointer(1)
    do field_id = 1, this%fe_space%get_num_fields()
      this%cell_integrators(field_id)%p => this%fe_space%cell_integrators%get_pointer(field_id)
    end do
  else 
    this%single_quad_cell_map_cell_integs = .false.
    nullify(this%quadrature)
    nullify(this%cell_map)
    do field_id = 1, this%fe_space%get_num_fields()
      nullify(this%cell_integrators(field_id)%p)
    end do
  end if 
  
end subroutine fe_cell_iterator_create

subroutine aux_create(this, fe_space, fe_cell_predicate)
  implicit none
  class(fe_cell_iterator_t),                     intent(inout) :: this
  class(serial_fe_space_t) ,            target,  intent(in)    :: fe_space
  class(fe_cell_predicate_t), optional, target,  intent(in)    :: fe_cell_predicate
  class(triangulation_t),               pointer                :: triangulation
  call this%set_fe_space(fe_space)
  call this%create_cell(fe_space%triangulation)
  call this%allocate_assembly_scratch_data()
  call this%allocate_performance_scratch_data()
  call this%init_performance_scratch_data()
  if (present(fe_cell_predicate)) then
     this%fe_cell_predicate => fe_cell_predicate
  end if
  call aux_first(this) 
  triangulation => fe_space%get_triangulation()
  call this%set_single_octree_mesh(triangulation%is_single_octree_mesh())
end subroutine aux_create

subroutine fe_cell_iterator_create_cell ( this, triangulation )
  implicit none
  class(fe_cell_iterator_t)              , intent(inout) :: this
  class(triangulation_t), intent(in)    :: triangulation
  call triangulation%create_cell_iterator(this%cell)
end subroutine fe_cell_iterator_create_cell

subroutine fe_cell_iterator_free_cell ( this, triangulation )
  implicit none
  class(fe_cell_iterator_t)              , intent(inout) :: this
  class(triangulation_t), intent(in)    :: triangulation
  call triangulation%free_cell_iterator(this%cell)
end subroutine fe_cell_iterator_free_cell

subroutine fe_cell_iterator_free (this)
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat
  call aux_free(this)
  call this%set_integration_updated(.false.)
  call this%set_single_octree_mesh(.false.)
  this%cell_integration_is_set_up = .false. 
  nullify(this%fe_cell_predicate)
end subroutine fe_cell_iterator_free

subroutine aux_free (this) 
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat 
  if ( associated(this%fe_space) ) then
    if ( associated(this%fe_space%triangulation) ) then
      call this%free_cell(this%fe_space%triangulation)
    end if
  end if
  call this%free_assembly_scratch_data()
  call this%free_performance_scratch_data()
  call this%nullify_fe_space()
  nullify(this%cell_map)
  nullify(this%quadrature)
  this%single_quad_cell_map_cell_integs = .false.
end subroutine aux_free   
  
 
subroutine fe_cell_iterator_allocate_assembly_scratch_data ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat, iblock
  assert( associated(this%fe_space) )
  call memalloc ( this%fe_space%num_fields, this%num_cell_dofs_x_field, __FILE__, __LINE__ )
  allocate( this%fe_dofs(this%fe_space%num_fields), stat=istat); check(istat==0);
  allocate ( this%cell_integrators(this%fe_space%num_fields), stat=istat ); check(istat==0);
  allocate( this%extended_fe_dofs(this%fe_space%num_fields), stat=istat); check(istat==0);
  call this%extended_elmat%create(0,0)
  call this%extended_elvec%create(0) 
  allocate ( this%gid_to_lid_map(this%fe_space%get_num_blocks()), stat=istat); check(istat==0);
  do iblock = 1, this%fe_space%get_num_blocks()
    call this%gid_to_lid_map(iblock)%create(this%fe_space%get_block_num_dofs(iblock))
    this%gid_to_lid_map(iblock)%a = 0
  end do  
end subroutine fe_cell_iterator_allocate_assembly_scratch_data

subroutine fe_cell_iterator_free_assembly_scratch_data ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat, iblock, ifield
  if ( allocated(this%num_cell_dofs_x_field) ) then
    call memfree ( this%num_cell_dofs_x_field, __FILE__, __LINE__ )
  end if
  if ( allocated(this%fe_dofs) ) then
    deallocate ( this%fe_dofs, stat=istat ); check(istat==0);
  end if
  if ( allocated(this%cell_integrators) ) then
    deallocate ( this%cell_integrators, stat=istat ); check(istat==0);
  end if
  if ( allocated(this%gid_to_lid_map) ) then
    do iblock = 1, this%fe_space%get_num_blocks()
       call this%gid_to_lid_map(iblock)%free()
    end do   
    deallocate( this%gid_to_lid_map, stat=istat); check(istat==0);
  end if  
  if ( allocated(this%extended_fe_dofs) ) then
    do ifield = 1, this%get_num_fields()
       call this%extended_fe_dofs(ifield)%free()
    end do
    deallocate( this%extended_fe_dofs, stat=istat); check(istat==0);
  end if
  call this%extended_elmat%free()
  call this%extended_elvec%free()
end subroutine fe_cell_iterator_free_assembly_scratch_data

subroutine fe_cell_iterator_allocate_performance_scratch_data ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat
  allocate ( this%reference_fes(this%fe_space%num_fields), stat=istat)
  check(istat == 0)
end subroutine fe_cell_iterator_allocate_performance_scratch_data

subroutine fe_cell_iterator_init_performance_scratch_data ( this ) 
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat, i
  ! If (same) set of reference FEs on top of all cells ...
  if ( this%fe_space%same_reference_fes_on_all_cells ) then 
    do i=1, this%fe_space%num_fields
      this%reference_fes(i)%p => this%fe_space%reference_fes(i)%p
    end do   
  end if 
end subroutine fe_cell_iterator_init_performance_scratch_data 

subroutine fe_cell_iterator_update_performance_scratch_data ( this ) 
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat, i
  ! If (potentially) different set of reference FEs on top of all cells ...
  if ( .not. this%fe_space%same_reference_fes_on_all_cells ) then 
    do i=1, this%fe_space%num_fields
      this%reference_fes(i)%p => this%fe_space%reference_fes(this%fe_space%field_cell_to_ref_fes(i)%get(this%get_gid()))%p
    end do   
  end if
end subroutine fe_cell_iterator_update_performance_scratch_data 

subroutine fe_cell_iterator_free_performance_scratch_data ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat
  if ( allocated(this%reference_fes) ) then
    deallocate ( this%reference_fes, stat=istat)
    check(istat == 0)
  end if
end subroutine fe_cell_iterator_free_performance_scratch_data

subroutine fe_cell_iterator_free_final(this)
  implicit none
  type(fe_cell_iterator_t), intent(inout) :: this
  assert ( .not. allocated(this%cell) )
  assert ( .not. associated(this%fe_space))
  assert ( .not. associated(this%cell_map))
end subroutine fe_cell_iterator_free_final

subroutine fe_cell_iterator_next(this)
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this 
  call base_fe_cell_iterator_next(this)
  call jump_cells(this)
  if ( .not. this%has_finished() ) then
    call this%update_performance_scratch_data()
  end if 
  call this%set_integration_updated(.false.)
end subroutine fe_cell_iterator_next

subroutine fe_cell_iterator_first(this)
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this 
  call aux_first(this)
  call this%set_integration_updated(.false.)
end subroutine fe_cell_iterator_first

subroutine aux_first(this) 
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  call base_fe_cell_iterator_first(this)
  call jump_cells(this)
  if ( .not. this%has_finished() ) then
    call this%update_performance_scratch_data()
  end if
end subroutine aux_first

subroutine jump_cells(this)
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  if ( associated(this%fe_cell_predicate) ) then
    ! Jump those cells not to be visited accordingly to
    ! this%fe_cell_predicate
    do while ( .not. this%has_finished())
     if (this%fe_cell_predicate%visit_fe_cell(this)) then
      exit
     end if
     call this%next()
    end do
  end if
end subroutine jump_cells

subroutine fe_cell_iterator_set_gid(this, lid)
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)        , intent(in)    :: lid
  if ( associated(this%fe_cell_predicate) ) then
    massert(.false., "ERROR: not possible to call this subroutine when iterator is associated to a predicate")
  end if
  call aux_set_gid(this,lid)
  call this%set_integration_updated(.false.)
end subroutine fe_cell_iterator_set_gid

subroutine aux_set_gid(this, gid)
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)              , intent(in)    :: gid
  call base_fe_cell_iterator_set_gid(this,gid)
  if ( .not. this%has_finished() ) then
    call this%update_performance_scratch_data()
  end if
end subroutine aux_set_gid

subroutine fe_cell_iterator_set_fe_space(this,fe_space)
  implicit none
  class(fe_cell_iterator_t)             , intent(inout) :: this
  class(serial_fe_space_t), target, intent(in)    :: fe_space
  this%fe_space => fe_space
end subroutine fe_cell_iterator_set_fe_space

subroutine fe_cell_iterator_nullify_fe_space(this)
  implicit none
  class(fe_cell_iterator_t)             , intent(inout) :: this
  nullify(this%fe_space)
end subroutine fe_cell_iterator_nullify_fe_space

function fe_cell_iterator_count_own_dofs_cell ( this, field_id )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(in)   :: this
  integer(ip)              , intent(in)   :: field_id
  integer(ip) :: fe_cell_iterator_count_own_dofs_cell
  
  if ( this%fe_space%same_reference_fe_or_void_x_field(field_id) ) then
    fe_cell_iterator_count_own_dofs_cell  = this%count_own_dofs_cell_w_scratch_data(field_id)
  else
    fe_cell_iterator_count_own_dofs_cell =  this%count_own_dofs_cell_general(field_id)
  end if 
  
end function fe_cell_iterator_count_own_dofs_cell


function fe_cell_iterator_count_own_dofs_cell_general ( this, field_id )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(in)   :: this
  integer(ip)         , intent(in)   :: field_id
  integer(ip) :: fe_cell_iterator_count_own_dofs_cell_general
  
  ! Local variables
  integer(ip) :: ivef
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  
  assert ( field_id>= 1 .and. field_id <= this%fe_space%num_fields )
  
  reference_fe => this%get_reference_fe(field_id)
  ivef = this%get_num_vefs()+1
  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
  fe_cell_iterator_count_own_dofs_cell_general = own_dofs_on_vef_iterator%get_size() 
end function fe_cell_iterator_count_own_dofs_cell_general

function fe_cell_iterator_count_own_dofs_cell_w_scratch_data ( this, field_id )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(in)   :: this
  integer(ip)         , intent(in)   :: field_id
  integer(ip) :: fe_cell_iterator_count_own_dofs_cell_w_scratch_data 
  
  ! Local variables
  integer(ip) :: ivef, spos, epos
  
  assert ( field_id>= 1 .and. field_id <= this%fe_space%num_fields )
  assert ( .not. this%is_void(field_id) ) 
  ivef = size(this%fe_space%ptr_own_dofs_n_face(field_id)%a)-1
  spos = this%fe_space%ptr_own_dofs_n_face(field_id)%a(ivef)
  epos = this%fe_space%ptr_own_dofs_n_face(field_id)%a(ivef+1)
  fe_cell_iterator_count_own_dofs_cell_w_scratch_data = epos-spos
end function fe_cell_iterator_count_own_dofs_cell_w_scratch_data



subroutine fe_cell_iterator_generate_own_dofs_cell ( this, field_id, current_dof, are_free_dofs )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(inout)   :: this
  integer(ip)         , intent(in)      :: field_id
  integer(ip)         , intent(inout)   :: current_dof
  logical, optional   , intent(in)      :: are_free_dofs
  if ( this%fe_space%same_reference_fe_or_void_x_field(field_id) ) then
     call this%generate_own_dofs_cell_w_scratch_data(field_id, current_dof, are_free_dofs)
  else
     call this%generate_own_dofs_cell_general(field_id, current_dof, are_free_dofs)
  end if 
end subroutine fe_cell_iterator_generate_own_dofs_cell

subroutine fe_cell_iterator_generate_own_dofs_cell_general ( this, field_id, current_dof, are_free_dofs )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(inout)   :: this
  integer(ip)         , intent(in)      :: field_id
  integer(ip)         , intent(inout)   :: current_dof
  logical, optional   , intent(in)      :: are_free_dofs

  ! Local variables
  integer(ip) :: ivef
  integer(ip) :: base_pos_lst_dofs_gids
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  logical  :: are_free

  if (present(are_free_dofs)) then
    are_free = are_free_dofs
  else
    are_free = .true.
  end if
  
  assert ( field_id>= 1 .and. field_id <= this%fe_space%num_fields )
  ivef = this%get_num_vefs()+1
  
  reference_fe => this%get_reference_fe(field_id)
  
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1
  
  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within current fe
  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
  do while (.not. own_dofs_on_vef_iterator%is_upper_bound())
    current_dof = current_dof + 1
    if (are_free) then
      call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current(),current_dof)
    else
      call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current(),-current_dof)
    end if
    call own_dofs_on_vef_iterator%next()
  end do
end subroutine fe_cell_iterator_generate_own_dofs_cell_general

subroutine fe_cell_iterator_generate_own_dofs_cell_w_scratch_data ( this, field_id, current_dof, are_free_dofs )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(inout)   :: this
  integer(ip)         , intent(in)      :: field_id
  integer(ip)         , intent(inout)   :: current_dof
  logical, optional   , intent(in)      :: are_free_dofs

  ! Local variables
  integer(ip) :: spos, epos, ivef, i 
  integer(ip) :: base_pos_lst_dofs_gids
  logical     :: are_free
  integer(ip) :: dof_lid
  integer(ip), pointer :: p_lst_dofs_gids(:)

  assert ( .not. this%is_void(field_id) ) 

  if (present(are_free_dofs)) then
    are_free = are_free_dofs
  else
    are_free = .true.
  end if
  
  assert ( field_id>= 1 .and. field_id <= this%fe_space%num_fields )
  ivef = size(this%fe_space%ptr_own_dofs_n_face(field_id)%a)-1
  
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1

  spos = this%fe_space%ptr_own_dofs_n_face(field_id)%a(ivef)
  epos = this%fe_space%ptr_own_dofs_n_face(field_id)%a(ivef+1)-1
  p_lst_dofs_gids => this%fe_space%lst_dofs_gids%get_pointer()
  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within current fe
  do i=spos,epos 
    current_dof = current_dof + 1
    dof_lid     = this%fe_space%lst_own_dofs_n_face(field_id)%a(i)
    if (are_free) then
      p_lst_dofs_gids(base_pos_lst_dofs_gids+dof_lid) = current_dof
    else
      p_lst_dofs_gids(base_pos_lst_dofs_gids+dof_lid) = -current_dof
    end if
  end do
end subroutine fe_cell_iterator_generate_own_dofs_cell_w_scratch_data

subroutine fe_cell_iterator_generate_own_dofs_vef ( this, ivef, field_id, current_dof, free_dofs_loop )
  implicit none
  class(fe_cell_iterator_t) , intent(inout) :: this
  integer(ip)               , intent(in)    :: ivef
  integer(ip)               , intent(in)    :: field_id
  integer(ip)               , intent(inout) :: current_dof
  logical              , intent(in)    :: free_dofs_loop
  if ( this%fe_space%same_reference_fe_or_void_x_field(field_id) ) then
   call this%generate_own_dofs_vef_w_scratch_data(ivef,field_id, current_dof, free_dofs_loop)
  else
   call this%generate_own_dofs_vef_general(ivef,field_id, current_dof, free_dofs_loop)
  end if 
end subroutine fe_cell_iterator_generate_own_dofs_vef

subroutine fe_cell_iterator_generate_own_dofs_vef_general ( this, ivef, field_id, current_dof, free_dofs_loop )
  implicit none
  class(fe_cell_iterator_t) , intent(inout) :: this
  integer(ip)          , intent(in)    :: ivef
  integer(ip)          , intent(in)    :: field_id
  integer(ip)          , intent(inout) :: current_dof
  logical              , intent(in)    :: free_dofs_loop

  integer(ip) :: base_pos_lst_dofs_gids
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  
  assert ( ivef >=1 .and. ivef <= this%get_num_vefs() )
  assert ( field_id >= 1 .and. field_id <= this%fe_space%num_fields )
  
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1
  
  reference_fe => this%get_reference_fe(field_id)
  
  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within current fe
  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
  do while (.not. own_dofs_on_vef_iterator%is_upper_bound())
    if ( this%fe_space%lst_dofs_gids%get(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current()) >= 0 ) then
      current_dof = current_dof + 1
      if ( free_dofs_loop ) then ! A free dofs loop is surrounding this call 
        call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current(),current_dof)
      else                       ! A fixed dofs loop is surrounding this call 
        call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current(),-current_dof)
      end if
    end if
    call own_dofs_on_vef_iterator%next()
  end do
end subroutine fe_cell_iterator_generate_own_dofs_vef_general

subroutine fe_cell_iterator_generate_own_dofs_vef_w_scratch_data ( this, ivef, field_id, current_dof, free_dofs_loop )
  implicit none
  class(fe_cell_iterator_t) , intent(inout) :: this
  integer(ip)          , intent(in)    :: ivef
  integer(ip)          , intent(in)    :: field_id
  integer(ip)          , intent(inout) :: current_dof
  logical              , intent(in)    :: free_dofs_loop

  integer(ip) :: base_pos_lst_dofs_gids
  integer(ip), pointer :: p_lst_dofs_gids(:)
  integer(ip) :: dof_lid, i, spos, epos 
 
  assert ( ivef >=1 .and. ivef <= this%get_num_vefs() )
  assert ( field_id >= 1 .and. field_id <= this%fe_space%num_fields )
  assert ( .not. this%is_void(field_id) ) 
  
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1
  
  spos = this%fe_space%ptr_own_dofs_n_face(field_id)%a(ivef)
  epos = this%fe_space%ptr_own_dofs_n_face(field_id)%a(ivef+1)-1
  p_lst_dofs_gids => this%fe_space%lst_dofs_gids%get_pointer()
 
  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within current fe
  do i=spos,epos 
    dof_lid = this%fe_space%lst_own_dofs_n_face(field_id)%a(i)
    if ( p_lst_dofs_gids(base_pos_lst_dofs_gids+dof_lid) >= 0 ) then
      current_dof = current_dof + 1
      if ( free_dofs_loop ) then ! A free dofs loop is surrounding this call 
        p_lst_dofs_gids(base_pos_lst_dofs_gids+dof_lid) = current_dof
      else                       ! A fixed dofs loop is surrounding this call 
        p_lst_dofs_gids(base_pos_lst_dofs_gids+dof_lid) = -current_dof
      end if
    end if
  end do
end subroutine fe_cell_iterator_generate_own_dofs_vef_w_scratch_data

function fe_cell_iterator_count_own_dofs_vef ( this, ivef, field_id )
  implicit none
  class(fe_cell_iterator_t) , intent(in) :: this
  integer(ip)          , intent(in) :: ivef
  integer(ip)          , intent(in) :: field_id
  integer(ip) :: fe_cell_iterator_count_own_dofs_vef
  if ( this%fe_space%same_reference_fe_or_void_x_field(field_id) ) then
    fe_cell_iterator_count_own_dofs_vef = this%count_own_dofs_vef_w_scratch_data(ivef,field_id)
  else
    fe_cell_iterator_count_own_dofs_vef = this%count_own_dofs_vef_general(ivef,field_id)
  end if 
end function fe_cell_iterator_count_own_dofs_vef

function fe_cell_iterator_count_own_dofs_vef_general ( this, ivef, field_id )
  implicit none
  class(fe_cell_iterator_t) , intent(in) :: this
  integer(ip)          , intent(in) :: ivef
  integer(ip)          , intent(in) :: field_id
  integer(ip) :: fe_cell_iterator_count_own_dofs_vef_general

  integer(ip) :: base_pos_lst_dofs_gids
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  
  assert ( ivef >=1 .and. ivef <= this%get_num_vefs() )
  assert ( field_id >= 1 .and. field_id <= this%fe_space%num_fields )
  
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1
  
  reference_fe => this%get_reference_fe(field_id)
  
  fe_cell_iterator_count_own_dofs_vef_general = 0
  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
  do while (.not. own_dofs_on_vef_iterator%is_upper_bound())
    if ( this%fe_space%lst_dofs_gids%get(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current()) >= 0 ) then
      fe_cell_iterator_count_own_dofs_vef_general = fe_cell_iterator_count_own_dofs_vef_general + 1
    end if
    call own_dofs_on_vef_iterator%next()
  end do
end function fe_cell_iterator_count_own_dofs_vef_general

function fe_cell_iterator_count_own_dofs_vef_w_scratch_data ( this, ivef, field_id )
  implicit none
  class(fe_cell_iterator_t) , intent(in) :: this
  integer(ip)          , intent(in) :: ivef
  integer(ip)          , intent(in) :: field_id
  integer(ip) :: fe_cell_iterator_count_own_dofs_vef_w_scratch_data
  integer(ip) :: base_pos_lst_dofs_gids
  integer(ip) :: i, spos, epos, dof_lid
  integer(ip), pointer  :: p_lst_dofs_gids(:)
  
  assert ( ivef >=1 .and. ivef <= this%get_num_vefs() )
  assert ( field_id >= 1 .and. field_id <= this%fe_space%num_fields )
  assert ( .not. this%is_void(field_id) ) 
  
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1
 
  spos = this%fe_space%ptr_own_dofs_n_face(field_id)%a(ivef)
  epos = this%fe_space%ptr_own_dofs_n_face(field_id)%a(ivef+1)-1
  p_lst_dofs_gids => this%fe_space%lst_dofs_gids%get_pointer()
  
  fe_cell_iterator_count_own_dofs_vef_w_scratch_data = 0
  do i=spos, epos
    dof_lid = this%fe_space%lst_own_dofs_n_face(field_id)%a(i)
    if ( p_lst_dofs_gids(base_pos_lst_dofs_gids+dof_lid) >= 0 ) then
      fe_cell_iterator_count_own_dofs_vef_w_scratch_data = & 
           fe_cell_iterator_count_own_dofs_vef_w_scratch_data + 1
    end if
  end do
end function fe_cell_iterator_count_own_dofs_vef_w_scratch_data

subroutine fe_cell_iterator_generate_own_dofs_vef_component_wise ( this, &
                                                      ivef, &
                                                      field_id, &
                                                      current_dof, &
                                                      components_code, &
                                                      free_dofs_loop )
  implicit none
  class(fe_cell_iterator_t) , intent(inout) :: this
  integer(ip)          , intent(in)    :: ivef
  integer(ip)          , intent(in)    :: field_id
  integer(ip)          , intent(inout) :: current_dof
  logical              , intent(in)    :: components_code(:)
  logical              , intent(in)    :: free_dofs_loop
  if ( this%fe_space%same_reference_fe_or_void_x_field(field_id) ) then
    call this%generate_own_dofs_vef_component_wise_w_scratch_data(ivef,field_id,current_dof,components_code,free_dofs_loop)
  else
    call this%generate_own_dofs_vef_component_wise_general(ivef,field_id,current_dof,components_code,free_dofs_loop)
  end if 
end subroutine fe_cell_iterator_generate_own_dofs_vef_component_wise


subroutine fci_generate_own_dofs_vef_component_wise_general ( this, ivef, field_id, current_dof, components_code, free_dofs_loop )
  implicit none
  class(fe_cell_iterator_t) , intent(inout) :: this
  integer(ip)          , intent(in)    :: ivef
  integer(ip)          , intent(in)    :: field_id
  integer(ip)          , intent(inout) :: current_dof
  logical              , intent(in)    :: components_code(:)
  logical              , intent(in)    :: free_dofs_loop
  integer(ip) :: base_pos_lst_dofs_gids, component_id, local_within_ref_fe_dof_id
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  
  assert ( ivef >=1 .and. ivef <= this%get_num_vefs() )
  assert ( field_id >= 1 .and. field_id <= this%get_num_fields() )
  assert ( reference_fe%has_nodal_quadrature() )
  
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1

  reference_fe => this%get_reference_fe(field_id)
  
  assert ( size(components_code) == reference_fe%get_num_field_components() )
  
  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within current fe
  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
  do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
    local_within_ref_fe_dof_id  = own_dofs_on_vef_iterator%get_current()
    if ( this%fe_space%lst_dofs_gids%get(base_pos_lst_dofs_gids+local_within_ref_fe_dof_id) >= 0 ) then
      component_id = reference_fe%get_component_node(local_within_ref_fe_dof_id)
      if ( components_code(component_id) ) then 
       current_dof = current_dof +1 
       if ( free_dofs_loop ) then ! A free dofs loop is surrounding this call 
         call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids+local_within_ref_fe_dof_id,current_dof)
       else
         call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids+local_within_ref_fe_dof_id,-current_dof)
       end if
      end if  
    end if
    call own_dofs_on_vef_iterator%next()
  end do
end subroutine fci_generate_own_dofs_vef_component_wise_general

subroutine fci_generate_own_dofs_vef_component_wise_w_scratch_data ( this, ivef, field_id, current_dof, components_code, free_dofs_loop )
  implicit none
  class(fe_cell_iterator_t) , intent(inout) :: this
  integer(ip)          , intent(in)    :: ivef
  integer(ip)          , intent(in)    :: field_id
  integer(ip)          , intent(inout) :: current_dof
  logical              , intent(in)    :: components_code(:)
  logical              , intent(in)    :: free_dofs_loop
  integer(ip) :: base_pos_lst_dofs_gids, component_id, local_within_ref_fe_dof_id
  integer(ip) :: i, spos, epos
  class(reference_fe_t), pointer :: reference_fe
  integer(ip), pointer :: p_lst_dofs_gids(:)
  
  assert ( ivef >=1 .and. ivef <= this%get_num_vefs() )
  assert ( field_id >= 1 .and. field_id <= this%get_num_fields() )
  
#ifdef DEBUG   
  reference_fe => this%get_reference_fe(field_id)
  assert ( size(components_code) == reference_fe%get_num_field_components() )
  assert ( reference_fe%has_nodal_quadrature() )
#endif
    
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1
  
  spos = this%fe_space%ptr_own_dofs_n_face(field_id)%a(ivef)
  epos = this%fe_space%ptr_own_dofs_n_face(field_id)%a(ivef+1)-1
  p_lst_dofs_gids => this%fe_space%lst_dofs_gids%get_pointer()
  
  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within current fe
  do i=spos,epos
    local_within_ref_fe_dof_id = this%fe_space%lst_own_dofs_n_face(field_id)%a(i)
    if ( p_lst_dofs_gids(base_pos_lst_dofs_gids+local_within_ref_fe_dof_id) >= 0 ) then
      component_id = this%fe_space%dofs_component(field_id)%a(local_within_ref_fe_dof_id)
      if ( components_code(component_id) ) then 
       current_dof = current_dof +1 
       if ( free_dofs_loop ) then ! A free dofs loop is surrounding this call 
         p_lst_dofs_gids(base_pos_lst_dofs_gids+local_within_ref_fe_dof_id) = current_dof
       else
         p_lst_dofs_gids(base_pos_lst_dofs_gids+local_within_ref_fe_dof_id) = -current_dof
       end if
      end if  
    end if
  end do
end subroutine fci_generate_own_dofs_vef_component_wise_w_scratch_data



subroutine fe_cell_iterator_fetch_own_dofs_vef_from_source_fe ( this, target_ivef, source_fe, source_ivef, field_id )
  implicit none
  class(fe_cell_iterator_t) , intent(inout) :: this
  integer(ip)               , intent(in)    :: target_ivef
  class(fe_cell_iterator_t) , intent(in)    :: source_fe
  integer(ip)               , intent(in)    :: source_ivef
  integer(ip)               , intent(in)    :: field_id
  if ( this%fe_space%same_reference_fe_or_void_x_field(field_id) ) then
     call this%fetch_own_dofs_vef_from_source_fe_w_scratch_data(target_ivef, source_fe, source_ivef, field_id)
  else
     call this%fetch_own_dofs_vef_from_source_fe_general(target_ivef, source_fe, source_ivef, field_id)
  end if 
end subroutine fe_cell_iterator_fetch_own_dofs_vef_from_source_fe

subroutine fci_fetch_own_dofs_vef_from_source_fe_general ( this, target_ivef, source_fe, source_ivef, field_id )
  implicit none
  class(fe_cell_iterator_t) , intent(inout) :: this
  integer(ip)          , intent(in)    :: target_ivef
  class(fe_cell_iterator_t) , intent(in)    :: source_fe
  integer(ip)          , intent(in)    :: source_ivef
  integer(ip)          , intent(in)    :: field_id

  class(reference_fe_t), pointer :: reference_fe_source 
  integer(ip)                    :: base_pos_lst_dofs_gids_source
  type(list_iterator_t)          :: own_dofs_on_vef_iterator_target
  
  class(reference_fe_t), pointer :: reference_fe_target 
  integer(ip)                    :: base_pos_lst_dofs_gids_target
  
  integer(ip)                    :: source_dof_LID_cell, target_dof_LID_cell
  integer(ip)                    :: target_dof_LID_vef
  integer(ip)                    :: source_dof_LID_vef
  integer(ip)                    :: permutation_index
  integer(ip)                    :: source_ivef_dim

  assert ( target_ivef <= this%get_num_vefs() )
  assert ( source_ivef <= source_fe%get_num_vefs() )
  assert ( field_id <= this%get_num_fields() )
  
  reference_fe_target => this%get_reference_fe(field_id)
  base_pos_lst_dofs_gids_target = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1
  
  reference_fe_source => source_fe%get_reference_fe(field_id)
  base_pos_lst_dofs_gids_source = this%fe_space%ptr_dofs_x_fe(field_id)%get(source_fe%get_gid())-1
  source_ivef_dim = reference_fe_source%get_n_face_dim(source_ivef)
  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within target fe
  own_dofs_on_vef_iterator_target = reference_fe_target%create_own_dofs_on_n_face_iterator(target_ivef)
  if ( own_dofs_on_vef_iterator_target%get_size() > 0 ) then
       assert (reference_fe_source%check_compatibility_of_n_faces(reference_fe_target,target_ivef,source_ivef))
       permutation_index = this%get_permutation_index( source_fe, &
                                                       target_ivef, &
                                                       source_ivef )
      do while (.not. own_dofs_on_vef_iterator_target%is_upper_bound())
        target_dof_LID_vef = own_dofs_on_vef_iterator_target%get_distance_to_lower_bound()
        source_dof_LID_vef = reference_fe_source%permute_dof_LID_n_face(target_dof_LID_vef, &
                                                                    source_ivef_dim, & 
                                                                    permutation_index)
        target_dof_LID_cell = own_dofs_on_vef_iterator_target%get_current()
        source_dof_LID_cell = reference_fe_source%translate_dof_lid_n_face_to_dof_lid_cell(source_dof_LID_vef, source_ivef)
        call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids_target+target_dof_LID_cell, &                                                      
            this%fe_space%lst_dofs_gids%get(base_pos_lst_dofs_gids_source+source_dof_LID_cell) )
        call own_dofs_on_vef_iterator_target%next()
      end do
  end if
end subroutine fci_fetch_own_dofs_vef_from_source_fe_general

subroutine fci_fetch_own_dofs_vef_from_source_fe_w_scratch_data ( this, target_ivef, source_fe, source_ivef, field_id )
  implicit none
  class(fe_cell_iterator_t) , intent(inout) :: this
  integer(ip)          , intent(in)    :: target_ivef
  class(fe_cell_iterator_t) , intent(in)    :: source_fe
  integer(ip)          , intent(in)    :: source_ivef
  integer(ip)          , intent(in)    :: field_id

  integer(ip)                    :: base_pos_lst_dofs_gids_source
  type(list_iterator_t)          :: own_dofs_on_vef_iterator_target
  integer(ip)                    :: base_pos_lst_dofs_gids_target
  
  integer(ip)                    :: source_dof_LID_cell, target_dof_LID_cell
  integer(ip)                    :: target_dof_LID_vef
  integer(ip)                    :: source_dof_LID_vef
  integer(ip)                    :: permutation_index
  integer(ip)                    :: source_ivef_dim
  integer(ip), pointer           :: p_lst_dofs_gids(:)
  integer(ip)                    :: i, spos, epos
  class(reference_fe_t), pointer :: reference_fe_source 

  assert ( target_ivef <= this%get_num_vefs() )
  assert ( source_ivef <= source_fe%get_num_vefs() )
  assert ( field_id <= this%get_num_fields() )
  assert ( .not. this%is_void(field_id) ) 
  
  base_pos_lst_dofs_gids_target = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1
  
  base_pos_lst_dofs_gids_source = this%fe_space%ptr_dofs_x_fe(field_id)%get(source_fe%get_gid())-1
  reference_fe_source => source_fe%reference_fes(field_id)%p
  source_ivef_dim = reference_fe_source%get_n_face_dim(source_ivef)

  spos = this%fe_space%ptr_own_dofs_n_face(field_id)%a(target_ivef)
  epos = this%fe_space%ptr_own_dofs_n_face(field_id)%a(target_ivef+1)-1
  p_lst_dofs_gids => this%fe_space%lst_dofs_gids%get_pointer()

  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within target fe
  if ( epos >= spos ) then 
      permutation_index = this%get_permutation_index( source_fe, &
                                                      target_ivef, &
                                                      source_ivef )
      do i=spos,epos 
        target_dof_LID_vef = i-spos+1 
        source_dof_LID_vef = reference_fe_source%permute_dof_LID_n_face(target_dof_LID_vef, &
                                                                    source_ivef_dim, & 
                                                                    permutation_index)
        target_dof_LID_cell = this%fe_space%lst_own_dofs_n_face(field_id)%a(i)
        source_dof_LID_cell = reference_fe_source%translate_dof_lid_n_face_to_dof_lid_cell(source_dof_LID_vef, source_ivef)
        p_lst_dofs_gids(base_pos_lst_dofs_gids_target+target_dof_LID_cell) = &                                                      
            p_lst_dofs_gids(base_pos_lst_dofs_gids_source+source_dof_LID_cell)
      end do
  end if 
end subroutine fci_fetch_own_dofs_vef_from_source_fe_w_scratch_data

subroutine fe_cell_iterator_generate_dofs_facet_integration_coupling ( this, ivef, field_id, dof_count )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(inout)   :: this
  integer(ip)         , intent(in)      :: ivef
  integer(ip)         , intent(in)      :: field_id
  integer(ip)         , intent(inout)   :: dof_count

  ! Local variables
  integer(ip)                    :: idof, base_pos_lst_dofs_gids
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t)          :: facet_integration_coupling_dofs 
  
  reference_fe => this%get_reference_fe(field_id)
  assert ( reference_fe%get_n_face_dim(ivef) == reference_fe%get_num_dims()-1 )
  
  if ( reference_fe%get_continuity() ) then
    facet_integration_coupling_dofs = reference_fe%create_dofs_on_n_face_iterator(ivef)
    base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())-1
    do while (.not. facet_integration_coupling_dofs%is_upper_bound())
      idof = facet_integration_coupling_dofs%get_current()
      dof_count = dof_count +1 
      call this%fe_space%lst_dofs_gids%set(base_pos_lst_dofs_gids+idof,dof_count)
      call facet_integration_coupling_dofs%next()
    end do
  end if
end subroutine fe_cell_iterator_generate_dofs_facet_integration_coupling

! Renumbers the DoF identifiers corresponding to all fields mapped to block with identifier block_id
subroutine fe_cell_iterator_renum_dofs_block ( this, block_id, perm_old2new )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t)      , intent(inout) :: this
  integer(ip)               , intent(in)    :: block_id
  ! No way to know the size of perm_old2new() within the local scope
  ! of class(fe_cell_iterator_t). This is why I used an assumed-size dummy
  ! argument in this context. This will be solved in the future whenever
  ! class(fe_cell_iterator_t) also has access to the whole mesh-like container.
  integer(ip)               , intent(in)    :: perm_old2new(*)
  integer(ip)                            :: field_id
  assert ( block_id >= 1 .and. block_id <= this%fe_space%get_num_blocks() )
  do field_id=1, this%fe_space%get_num_fields()
    if ( this%fe_space%block_layout%get_block_id(field_id) == block_id ) then
      call this%renum_dofs_field( field_id, perm_old2new )
    end if
  end do 
end subroutine fe_cell_iterator_renum_dofs_block

! Renumbers the DoF identifiers corresponding to field with identifier field_id
subroutine fe_cell_iterator_renum_dofs_field ( this, field_id, perm_old2new )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)         , intent(in) :: field_id
  ! No way to know the size of perm_old2new() within the local scope
  ! of class(fe_cell_iterator_t). This is why I used an assumed-size dummy
  ! argument in this context. This will be solved in the future whenever
  ! class(fe_cell_iterator_t) also has access to the whole mesh-like container.
  integer(ip)         , intent(in) :: perm_old2new(*)
  integer(ip) :: i, start_pos_lst_dofs_gids, end_pos_lst_dofs_gids
  
  start_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())
  
  if ( field_id == this%fe_space%get_num_fields() ) then
    end_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(1)%get(this%get_gid()+1)-1
  else  
    end_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id+1)%get(this%get_gid())-1
  end if  
  
  assert ( field_id >= 1 .and. field_id <= this%fe_space%get_num_fields() )
  do i = start_pos_lst_dofs_gids, end_pos_lst_dofs_gids
    if ( this%fe_space%is_free_dof(this%fe_space%lst_dofs_gids%get(i)) ) then
      call this%fe_space%lst_dofs_gids%set(i,perm_old2new(this%fe_space%lst_dofs_gids%get(i)))
    end if
  end do
end subroutine fe_cell_iterator_renum_dofs_field

subroutine fe_cell_iterator_update_assembly_scratch_data( this)
  implicit none
  class(fe_cell_iterator_t), intent(inout)    :: this 
  integer(ip) :: field_id
  do field_id = 1, this%get_num_fields()-1
    this%num_cell_dofs_x_field(field_id) = this%fe_space%ptr_dofs_x_fe(field_id+1)%get(this%get_gid())- &
                                      this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())
  end do
  this%num_cell_dofs_x_field(field_id) = this%fe_space%ptr_dofs_x_fe(1)%get(this%get_gid()+1)- &
                                    this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())
                                    
  call this%get_fe_dofs(this%fe_dofs)
end subroutine fe_cell_iterator_update_assembly_scratch_data

subroutine fe_cell_iterator_update_integration( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this 
  integer(ip) :: field_id
  type(point_t)            , pointer :: coordinates(:)
  type(quadrature_t)       , pointer :: quadrature
  type(cell_map_t)         , pointer :: cell_map
  type(cell_integrator_t)  , pointer :: cell_integrator
  integer(ip) :: cell_ressemblance
  integer(ip) :: prev_get_lev, this_get_lev
  real(rp) :: scaling_factor
  if ( .not. this%is_integration_updated() ) then
    call this%update_cell_map()
    call this%update_cell_integrators()
    
    ! Cell map update
    cell_map    => this%get_cell_map()
    coordinates => cell_map%get_coordinates()
    call this%get_nodes_coordinates(coordinates)
    quadrature => this%get_quadrature()
    
    ! Decide whether the current cell is either a translation 
    ! or translation + scaling of the previous visited cell
    ! If there is no previous visited cell, then prev_get_lev == -1
    this_get_lev = this%get_level()
    cell_ressemblance = no_ressemblance
    scaling_factor = 1.0_rp
    if ( this%is_single_octree_mesh() ) then 
       prev_get_lev = cell_map%get_last_visited_cell_lev()
       if ( prev_get_lev >= 0 ) then
          if ( this_get_lev == prev_get_lev ) then
             cell_ressemblance = is_only_translated
          else
             cell_ressemblance = is_scaled_and_translated
             scaling_factor = 2.0_rp**(real(prev_get_lev-this_get_lev,rp))
          end if
       end if
    end if
    call cell_map%update(this_get_lev,quadrature, cell_ressemblance, scaling_factor)
    
    ! Cell integrators update
    do field_id = 1, this%get_num_fields()
       cell_integrator => this%get_cell_integrator(field_id)
       cell_ressemblance = no_ressemblance
       scaling_factor = 1.0_rp
       if ( this%is_single_octree_mesh() ) then
         prev_get_lev = cell_integrator%get_last_visited_cell_lev()
         if ( prev_get_lev >= 0 ) then
          if ( this_get_lev == prev_get_lev ) then
             cell_ressemblance = is_only_translated
          else
             cell_ressemblance = is_scaled_and_translated
             scaling_factor = 2.0_rp**(real(prev_get_lev-this_get_lev,rp))
          end if
         end if
       end if 
       call cell_integrator%update(this_get_lev,cell_ressemblance,this%cell_map,scaling_factor)
    end do
    call this%set_integration_updated(.true.)
 end if
end subroutine fe_cell_iterator_update_integration

function fe_cell_iterator_get_fe_space(this)
  implicit none
  class(fe_cell_iterator_t), target, intent(in) :: this
  class(serial_fe_space_t), pointer :: fe_cell_iterator_get_fe_space
  fe_cell_iterator_get_fe_space => this%fe_space
end function fe_cell_iterator_get_fe_space

function fe_cell_iterator_get_num_fields(this)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip) :: fe_cell_iterator_get_num_fields
  fe_cell_iterator_get_num_fields = this%fe_space%num_fields
end function fe_cell_iterator_get_num_fields

function fe_cell_iterator_get_fe_space_type(this, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)         , intent(in) :: field_id
  integer(ip)                      :: fe_cell_iterator_get_fe_space_type
  assert (field_id >= 1 .and. field_id <= this%get_num_fields())
  fe_cell_iterator_get_fe_space_type = this%fe_space%fe_space_type_x_field(field_id)
end function fe_cell_iterator_get_fe_space_type

function fe_cell_iterator_get_field_type(this, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)         , intent(in) :: field_id
  character(:), pointer :: fe_cell_iterator_get_field_type
  class(reference_fe_t), pointer :: reference_fe
  reference_fe => this%get_reference_fe(field_id)
  fe_cell_iterator_get_field_type => reference_fe%get_field_type()
end function fe_cell_iterator_get_field_type

function fe_cell_iterator_get_field_blocks(this)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip), pointer             :: fe_cell_iterator_get_field_blocks(:)
  fe_cell_iterator_get_field_blocks => this%fe_space%block_layout%get_field_id_to_block_id()
end function fe_cell_iterator_get_field_blocks

function fe_cell_iterator_get_field_coupling(this)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  logical, pointer :: fe_cell_iterator_get_field_coupling(:,:)
  fe_cell_iterator_get_field_coupling => this%fe_space%block_layout%get_field_coupling()
end function fe_cell_iterator_get_field_coupling

function fe_cell_iterator_get_num_dofs(this)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip) :: fe_cell_iterator_get_num_dofs
  fe_cell_iterator_get_num_dofs = this%fe_space%ptr_dofs_x_fe(1)%get(this%get_gid()+1)- &
                                this%fe_space%ptr_dofs_x_fe(1)%get(this%get_gid())
end function fe_cell_iterator_get_num_dofs

function fe_cell_iterator_get_num_dofs_field(this, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip), intent(in) :: field_id
  integer(ip) :: fe_cell_iterator_get_num_dofs_field
  
  if ( field_id < this%fe_space%num_fields ) then
     fe_cell_iterator_get_num_dofs_field = this%fe_space%ptr_dofs_x_fe(field_id+1)%get(this%get_gid())- &
                                   this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())
  else                                
     fe_cell_iterator_get_num_dofs_field = this%fe_space%ptr_dofs_x_fe(1)%get(this%get_gid()+1)- &
                                   this%fe_space%ptr_dofs_x_fe(this%fe_space%num_fields)%get(this%get_gid())
  end if
end function fe_cell_iterator_get_num_dofs_field


subroutine fe_cell_iterator_get_field_fe_dofs( this, field_id, fe_dofs )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)         , intent(in)      :: field_id
  integer(ip), pointer, intent(inout)   :: fe_dofs(:)
  integer(ip) :: spos, epos
  ! Always assign an status of the output fe_dofs(:) dummy argument
  ! (i.e., even when there are NO DoFs on the local subdomain)
  nullify(fe_dofs)
  
  ! The code below according to the Fortran2003 handbook returns a zero-sized
  ! pointer array if spos>epos (i.e., when we have a void FE on top of this for
  ! field_id)
  if ( this%fe_space%lst_dofs_gids%size() > 0 ) then
    spos = this%fe_space%ptr_dofs_x_fe(field_id)%get(this%get_gid())
    if ( field_id == this%fe_space%get_num_fields() ) then
       epos = this%fe_space%ptr_dofs_x_fe(1)%get(this%get_gid()+1)-1
    else
       epos = this%fe_space%ptr_dofs_x_fe(field_id+1)%get(this%get_gid())-1
    end if
    fe_dofs => this%fe_space%lst_dofs_gids%get_pointer(spos,epos)
  end if
end subroutine fe_cell_iterator_get_field_fe_dofs

subroutine fe_cell_iterator_get_fe_dofs( this, fe_dofs )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  type(i1p_t)         , intent(inout) :: fe_dofs(:)
  integer(ip) :: field_id
  do field_id = 1, this%get_num_fields()
    call this%get_field_fe_dofs(field_id, fe_dofs(field_id)%p)
  end do 
end subroutine fe_cell_iterator_get_fe_dofs

function fe_cell_iterator_get_order( this, field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)         , intent(in) :: field_id
  integer(ip) :: fe_cell_iterator_get_order
  class(reference_fe_t), pointer :: reference_fe
  reference_fe => this%get_reference_fe(field_id)
  fe_cell_iterator_get_order = reference_fe%get_order()
end function fe_cell_iterator_get_order

function fe_cell_iterator_get_max_order_single_field( this, field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)         , intent(in) :: field_id
  integer(ip) :: fe_cell_iterator_get_max_order_single_field
  class(reference_fe_t), pointer :: reference_fe
  reference_fe => this%get_reference_fe(field_id)
  fe_cell_iterator_get_max_order_single_field = reference_fe%get_max_order()
end function fe_cell_iterator_get_max_order_single_field

function fe_cell_iterator_get_max_order_all_fields( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip) :: fe_cell_iterator_get_max_order_all_fields
  integer(ip) :: field_id
  fe_cell_iterator_get_max_order_all_fields = -1
  do field_id=1, this%get_num_fields()
   if ( fe_cell_iterator_get_max_order_all_fields < this%get_max_order_single_field(field_id) ) then
        fe_cell_iterator_get_max_order_all_fields = this%get_max_order_single_field(field_id)
   end if
  end do
end function fe_cell_iterator_get_max_order_all_fields

function fe_cell_iterator_at_strong_dirichlet_boundary ( this, field_id )
  implicit none
  class(fe_cell_iterator_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: field_id
  logical                             :: fe_cell_iterator_at_strong_dirichlet_boundary
  fe_cell_iterator_at_strong_dirichlet_boundary = this%fe_space%at_strong_dirichlet_boundary_x_fe(field_id)%get(this%get_gid())
end function fe_cell_iterator_at_strong_dirichlet_boundary

function fe_cell_iterator_has_fixed_dofs ( this, field_id )
  implicit none
  class(fe_cell_iterator_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: field_id
  logical                             :: fe_cell_iterator_has_fixed_dofs
  fe_cell_iterator_has_fixed_dofs = this%fe_space%has_fixed_dofs_x_fe(field_id)%get(this%get_gid())
end function fe_cell_iterator_has_fixed_dofs

function fe_cell_iterator_has_hanging_dofs ( this, field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)              , intent(in) :: field_id
  logical                               :: fe_cell_iterator_has_hanging_dofs
  fe_cell_iterator_has_hanging_dofs = this%fe_space%has_hanging_dofs_x_fe(field_id)%get(this%get_gid())
end function fe_cell_iterator_has_hanging_dofs

subroutine fe_cell_iterator_set_at_strong_dirichlet_boundary_single_field ( this, field_id )
  implicit none
  class(fe_cell_iterator_t)   , intent(inout) :: this
  integer(ip)            , intent(in)    :: field_id
  integer(ip), pointer :: fe_dofs(:)
  call this%get_field_fe_dofs(field_id, fe_dofs)
  if ( associated(fe_dofs) ) then 
    if ( any( (fe_dofs(:) < 0) .and. (fe_dofs(:) >= -this%fe_space%num_dirichlet_dofs) ) ) & 
        call this%fe_space%at_strong_dirichlet_boundary_x_fe(field_id)%set(this%get_gid(),.true.)
  end if       
end subroutine fe_cell_iterator_set_at_strong_dirichlet_boundary_single_field

subroutine fe_cell_iterator_set_has_fixed_dofs ( this, field_id )
  implicit none
  class(fe_cell_iterator_t)   , intent(inout) :: this
  integer(ip)            , intent(in)    :: field_id
  integer(ip), pointer :: fe_dofs(:)
  integer(ip) :: i 
  call this%get_field_fe_dofs(field_id, fe_dofs)
  if ( associated(fe_dofs) ) then
    do i=1, size(fe_dofs)
      if ( this%is_fixed_dof(fe_dofs(i)) ) then
        call this%fe_space%has_fixed_dofs_x_fe(field_id)%set(this%get_gid(),.true.)
        exit
      end if  
    end do  
  end if   
end subroutine fe_cell_iterator_set_has_fixed_dofs

subroutine fe_cell_iterator_set_has_hanging_dofs ( this, field_id )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)              , intent(in)    :: field_id
  integer(ip), pointer :: fe_dofs(:)
  integer(ip) :: i 
  call this%get_field_fe_dofs(field_id, fe_dofs)
  if ( associated(fe_dofs) ) then
    do i=1, size(fe_dofs)
      if ( this%is_hanging_dof(fe_dofs(i)) ) then
        call this%fe_space%has_hanging_dofs_x_fe(field_id)%set(this%get_gid(),.true.)
        exit
      end if
    end do
  end if 
end subroutine fe_cell_iterator_set_has_hanging_dofs

subroutine fe_cell_iterator_set_at_strong_dirichlet_boundary_all_fields ( this )
  implicit none
  class(fe_cell_iterator_t)   , intent(inout) :: this
  integer(ip) :: field_id
  do field_id=1, this%get_num_fields()
    call this%determine_at_strong_dirichlet_boundary(field_id)
  end do
end subroutine fe_cell_iterator_set_at_strong_dirichlet_boundary_all_fields

function fe_cell_iterator_is_free_dof ( this, dof_lid )
  implicit none
  class(fe_cell_iterator_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: dof_lid
  logical :: fe_cell_iterator_is_free_dof
  fe_cell_iterator_is_free_dof = this%fe_space%is_free_dof(dof_lid)
end function fe_cell_iterator_is_free_dof

function fe_cell_iterator_is_ghost_dof ( this, dof_lid )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)              , intent(in) :: dof_lid
  logical :: fe_cell_iterator_is_ghost_dof
  fe_cell_iterator_is_ghost_dof = this%fe_space%is_ghost_dof(dof_lid)
end function fe_cell_iterator_is_ghost_dof

function fe_cell_iterator_is_strong_dirichlet_dof ( this, dof_lid )
  implicit none
  class(fe_cell_iterator_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: dof_lid
  logical :: fe_cell_iterator_is_strong_dirichlet_dof
  fe_cell_iterator_is_strong_dirichlet_dof = this%fe_space%is_strong_dirichlet_dof(dof_lid)
end function fe_cell_iterator_is_strong_dirichlet_dof

function fe_cell_iterator_is_fixed_dof ( this, dof_lid )
  implicit none
  class(fe_cell_iterator_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: dof_lid
  logical :: fe_cell_iterator_is_fixed_dof
  fe_cell_iterator_is_fixed_dof = this%fe_space%is_fixed_dof(dof_lid)
end function fe_cell_iterator_is_fixed_dof

function fe_cell_iterator_is_hanging_dof ( this, dof_lid )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)              , intent(in) :: dof_lid
  logical :: fe_cell_iterator_is_hanging_dof
  fe_cell_iterator_is_hanging_dof = this%fe_space%is_hanging_dof(dof_lid)
end function fe_cell_iterator_is_hanging_dof

function fe_cell_iterator_compute_volume ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  real(rp) :: fe_cell_iterator_compute_volume
  integer(ip)                 :: q_poin, num_quadrature_points
  
  type(quadrature_t), pointer :: quadrature
  
  quadrature => this%get_quadrature()
  
  num_quadrature_points = quadrature%get_num_quadrature_points()
  fe_cell_iterator_compute_volume = 0.0_rp
  do q_poin = 1, num_quadrature_points
     fe_cell_iterator_compute_volume = fe_cell_iterator_compute_volume + &
          &                          this%get_det_jacobian(q_poin) * &
          &                          quadrature%get_weight(q_poin)
  end do
end function fe_cell_iterator_compute_volume

function fe_cell_iterator_compute_characteristic_length(this,qpoint)
  implicit none
  class(fe_cell_iterator_t), target , intent(in) :: this
  integer(ip)                       , intent(in) :: qpoint
  real(rp) :: fe_cell_iterator_compute_characteristic_length
  fe_cell_iterator_compute_characteristic_length = this%cell_map%compute_h(qpoint)
end function fe_cell_iterator_compute_characteristic_length

function fe_cell_iterator_get_quadrature_degree ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip) :: fe_cell_iterator_get_quadrature_degree
  if ( this%fe_space%cell_quadratures_degree%size() > 0 ) then
     fe_cell_iterator_get_quadrature_degree = this%fe_space%cell_quadratures_degree%get(this%get_gid())
  end if
  if ( this%fe_space%cell_quadratures_degree%size() == 0 .or. &
       fe_cell_iterator_get_quadrature_degree == fe_space_default_quadrature_degree_flag ) then
     fe_cell_iterator_get_quadrature_degree = this%get_default_quadrature_degree()
  end if
end function fe_cell_iterator_get_quadrature_degree

function fe_cell_iterator_get_default_quadrature_degree ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip) :: fe_cell_iterator_get_default_quadrature_degree
  integer(ip) :: reference_fe_id
  reference_fe_id = this%fe_space%max_order_reference_fe_id_x_cell%get(this%get_gid())
  fe_cell_iterator_get_default_quadrature_degree = & 
    this%fe_space%reference_fes(reference_fe_id)%p%get_default_quadrature_degree()
end function fe_cell_iterator_get_default_quadrature_degree

subroutine fe_cell_iterator_set_quadrature_degree ( this, quadrature_degree )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)         , intent(in)    :: quadrature_degree
  assert ( quadrature_degree >= -1 )
  if ( this%fe_space%cell_quadratures_degree%size() == 0 ) then
     call this%fe_space%allocate_and_init_cell_quadratures_degree()
  end if
  call this%fe_space%cell_quadratures_degree%set(this%get_gid(),quadrature_degree)
end subroutine fe_cell_iterator_set_quadrature_degree

function fe_cell_iterator_get_quadrature ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  type(quadrature_t), pointer      :: fe_cell_iterator_get_quadrature
  integer(ip) :: cell_quadratures_key, cell_quadratures_position
  integer(ip) :: istat
  if ( .not. this%single_quad_cell_map_cell_integs ) then
    cell_quadratures_key = this%fe_space%generate_cell_quadratures_position_key(this%get_reference_fe_geo_id(),&
                                                                               this%get_quadrature_degree())
  
    call this%fe_space%cell_quadratures_and_maps_position%get(key=cell_quadratures_key, &
                                                              val=cell_quadratures_position, &
                                                              stat=istat)
    assert ( .not. istat == key_not_found )
    fe_cell_iterator_get_quadrature => this%fe_space%cell_quadratures%get_pointer(cell_quadratures_position)
  else
    fe_cell_iterator_get_quadrature => this%quadrature
  end if  
end function fe_cell_iterator_get_quadrature

function fe_cell_iterator_get_cell_map ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  type(cell_map_t), pointer :: fe_cell_iterator_get_cell_map
  fe_cell_iterator_get_cell_map => this%cell_map
end function fe_cell_iterator_get_cell_map

!==================================================================================================
subroutine fe_cell_iterator_update_cell_map ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: cell_maps_position, cell_maps_key
  integer(ip) :: istat
  if ( .not. this%single_quad_cell_map_cell_integs ) then
    cell_maps_key = this%fe_space%generate_cell_quadratures_position_key(this%get_reference_fe_geo_id(),&
                                                                         this%get_quadrature_degree())
  
    call this%fe_space%cell_quadratures_and_maps_position%get(key=cell_maps_key, &
                                                             val=cell_maps_position, &
                                                             stat=istat)
  
    assert ( .not. istat == key_not_found )
    this%cell_map => this%fe_space%cell_maps%get_pointer(cell_maps_position)
  end if
end subroutine fe_cell_iterator_update_cell_map

!==================================================================================================
subroutine fe_cell_iterator_update_cell_integrators ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout)   :: this
  integer(ip) :: cell_integrators_position_key
  integer(ip) :: cell_integrators_position
  integer(ip) :: istat, field_id, num_fields
  type(cell_integrator_t), pointer :: cell_integrators(:)
  if ( .not. this%single_quad_cell_map_cell_integs ) then
    num_fields = this%get_num_fields()
    cell_integrators => this%fe_space%cell_integrators%get_pointer()
    do field_id = 1, num_fields
       cell_integrators_position_key = &
             this%fe_space%generate_cell_integrators_position_key(this%get_reference_fe_geo_id(), &
                                                                  this%get_quadrature_degree(), &
                                                                  this%fe_space%field_cell_to_ref_fes(field_id)%get(this%get_gid()))  
       call this%fe_space%cell_integrators_position%get(key=cell_integrators_position_key, &
                                                        val=cell_integrators_position, &
                                                        stat=istat)
       assert ( .not. istat == key_not_found )
       this%cell_integrators(field_id)%p => cell_integrators(cell_integrators_position) 
    end do
  end if 
end subroutine fe_cell_iterator_update_cell_integrators


!==================================================================================================
subroutine fe_cell_iterator_set_cell_map ( this, cell_map )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  type(cell_map_t), target, intent(in) :: cell_map
  this%cell_map => cell_map
end subroutine fe_cell_iterator_set_cell_map

!==================================================================================================
subroutine fe_cell_iterator_set_cell_integrator ( this, field_id, cell_integrator )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)              , intent(in) :: field_id
  type(cell_integrator_t), target, intent(in) :: cell_integrator
  this%cell_integrators(field_id)%p => cell_integrator
end subroutine fe_cell_iterator_set_cell_integrator

!==================================================================================================
subroutine fe_cell_iterator_nullify_cell_map ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  nullify(this%cell_map)
end subroutine fe_cell_iterator_nullify_cell_map

!==================================================================================================
subroutine fe_cell_iterator_nullify_cell_integrators ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: field_id
  do field_id=1, this%get_num_fields()
    nullify(this%cell_integrators(field_id)%p)
  end do   
end subroutine fe_cell_iterator_nullify_cell_integrators

!==================================================================================================
function fe_cell_iterator_is_integration_updated ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  logical :: fe_cell_iterator_is_integration_updated
  fe_cell_iterator_is_integration_updated = this%integration_updated
end function fe_cell_iterator_is_integration_updated

!==================================================================================================
subroutine fe_cell_iterator_set_integration_updated ( this, integration_updated )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  logical                  , intent(in)    :: integration_updated
  this%integration_updated = integration_updated
end subroutine fe_cell_iterator_set_integration_updated

!==================================================================================================
function fe_cell_iterator_is_single_octree_mesh ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  logical :: fe_cell_iterator_is_single_octree_mesh
  fe_cell_iterator_is_single_octree_mesh = this%single_octree_mesh
end function fe_cell_iterator_is_single_octree_mesh

!==================================================================================================
subroutine fe_cell_iterator_set_single_octree_mesh ( this, single_octree_mesh )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  logical                  , intent(in)    :: single_octree_mesh
  this%single_octree_mesh = single_octree_mesh
end subroutine fe_cell_iterator_set_single_octree_mesh

!==================================================================================================
function fe_cell_iterator_get_quadrature_points_coordinates(this)
  implicit none
  class(fe_cell_iterator_t)   , target, intent(in) :: this
  type(point_t), pointer :: fe_cell_iterator_get_quadrature_points_coordinates(:)
  type(cell_map_t), pointer :: cell_map
  cell_map => this%get_cell_map()
  fe_cell_iterator_get_quadrature_points_coordinates => cell_map%get_quadrature_points_coordinates()
end function fe_cell_iterator_get_quadrature_points_coordinates

!==================================================================================================
function fe_cell_iterator_get_det_jacobian ( this, i )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)    , intent(in) :: i
  real(rp) :: fe_cell_iterator_get_det_jacobian
  type(cell_map_t), pointer :: cell_map
  cell_map => this%get_cell_map()
  fe_cell_iterator_get_det_jacobian = cell_map%get_det_jacobian(i)
end function fe_cell_iterator_get_det_jacobian

!==================================================================================================
subroutine  fe_cell_iterator_get_det_jacobians ( this, det_jacobians )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                 , intent(inout) :: det_jacobians(:)
  type(cell_map_t), pointer :: cell_map
  cell_map => this%get_cell_map()
  call cell_map%get_det_jacobians(det_jacobians)
end subroutine  fe_cell_iterator_get_det_jacobians

!==================================================================================================
function fe_cell_iterator_get_cell_integrator ( this, field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)   :: this
  integer(ip)         , intent(in)   :: field_id
  type(cell_integrator_t), pointer :: fe_cell_iterator_get_cell_integrator
  fe_cell_iterator_get_cell_integrator => this%cell_integrators(field_id)%p
end function fe_cell_iterator_get_cell_integrator

function fe_cell_iterator_get_interpolation_duties ( this, field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)   :: this
  integer(ip)              , intent(in)   :: field_id
  type(interpolation_duties_t), pointer :: fe_cell_iterator_get_interpolation_duties
  type(cell_integrator_t), pointer :: cell_integrator
  cell_integrator => this%get_cell_integrator(field_id)
  fe_cell_iterator_get_interpolation_duties => & 
    cell_integrator%get_interpolation_duties_real_cell()
end function fe_cell_iterator_get_interpolation_duties

subroutine fe_cell_iterator_get_fe_vef(this, ivef, fe_vef)
  implicit none
  class(fe_cell_iterator_t)   , intent(in)    :: this
  integer(ip)            , intent(in)    :: ivef
  type(fe_vef_iterator_t), intent(inout) :: fe_vef
  call fe_vef%set_gid( this%cell%get_vef_gid(ivef))
end subroutine fe_cell_iterator_get_fe_vef

function fe_cell_iterator_get_reference_fe(this, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  integer(ip)              , intent(in)    :: field_id
  class(reference_fe_t), pointer :: fe_cell_iterator_get_reference_fe
  fe_cell_iterator_get_reference_fe => this%reference_fes(field_id)%p
  !fe_cell_iterator_get_reference_fe => this%fe_space%reference_fes(this%fe_space%field_cell_to_ref_fes(field_id)%get(this%get_gid()))%p
end function fe_cell_iterator_get_reference_fe

function fe_cell_iterator_get_max_order_reference_fe(this)
  implicit none
  class(fe_cell_iterator_t),  intent(in)      :: this
  class(reference_fe_t), pointer         :: fe_cell_iterator_get_max_order_reference_fe
  class(reference_fe_t), pointer         :: reference_fe
  integer(ip)                            :: max_order
  integer(ip)                            :: field_id
  max_order = -1
  do field_id=1, this%get_num_fields()
    reference_fe => this%get_reference_fe(field_id)
    if ( reference_fe%get_max_order() > max_order ) then
      max_order = reference_fe%get_max_order()
      fe_cell_iterator_get_max_order_reference_fe => reference_fe
    end if
  end do
end function fe_cell_iterator_get_max_order_reference_fe

function fe_cell_iterator_get_max_order_reference_fe_id(this)
  implicit none
  class(fe_cell_iterator_t),  intent(in)      :: this
  integer(ip)                            :: fe_cell_iterator_get_max_order_reference_fe_id
  class(reference_fe_t), pointer         :: reference_fe
  integer(ip)                            :: max_order
  integer(ip)                            :: field_id
  max_order = -1
  fe_cell_iterator_get_max_order_reference_fe_id = -1
  do field_id=1, this%get_num_fields()
    reference_fe => this%get_reference_fe(field_id)
    if ( reference_fe%get_max_order() >= max_order ) then
      max_order = reference_fe%get_max_order()
      fe_cell_iterator_get_max_order_reference_fe_id = this%get_reference_fe_id(field_id)
    end if
  end do
end function fe_cell_iterator_get_max_order_reference_fe_id

function fe_cell_iterator_get_reference_fe_id(this, field_id)
  implicit none
  class(fe_cell_iterator_t), target   , intent(in)    :: this
  integer(ip)                    , intent(in)    :: field_id
  integer(ip) :: fe_cell_iterator_get_reference_fe_id
  fe_cell_iterator_get_reference_fe_id = this%fe_space%field_cell_to_ref_fes(field_id)%get(this%get_gid())
end function fe_cell_iterator_get_reference_fe_id

subroutine fe_cell_iterator_set_reference_fe_id(this, field_id, reference_fe_id)
  implicit none
  class(fe_cell_iterator_t), target   , intent(inout) :: this
  integer(ip)                    , intent(in)    :: field_id
  integer(ip)                    , intent(in)    :: reference_fe_id
  call this%fe_space%field_cell_to_ref_fes(field_id)%set(this%get_gid(),reference_fe_id)
end subroutine fe_cell_iterator_set_reference_fe_id

function fe_cell_iterator_is_void(this, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  integer(ip),          intent(in)    :: field_id
  logical                             :: fe_cell_iterator_is_void
  fe_cell_iterator_is_void =  .false.
  select type (ref_fe => this%reference_fes(field_id)%p)
    class is (void_reference_fe_t)
      fe_cell_iterator_is_void =  .true.
  end select
end function fe_cell_iterator_is_void

function fe_cell_iterator_create_own_dofs_on_vef_iterator ( this, ivef, field_id ) result(list_iterator)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)                , intent(in) :: ivef
  integer(ip)                , intent(in) :: field_id
  type(list_iterator_t)                   :: list_iterator
  class(reference_fe_t), pointer          :: reference_fe
  
  reference_fe => this%get_reference_fe(field_id)
  list_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
end function fe_cell_iterator_create_own_dofs_on_vef_iterator

subroutine fe_cell_iterator_impose_strong_dirichlet_bcs_conforming ( this, fe_function, elmat, elvec )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  type(fe_function_t)      , intent(in)    :: fe_function
  real(rp)                 , intent(in)    :: elmat(:,:)
  real(rp)                 , intent(inout) :: elvec(:)
  integer(ip) :: idof, elmat_col, field_id, spos, dof_gid
  type(serial_scalar_array_t), pointer :: strong_dirichlet_values
  real(rp)                   , pointer :: strong_dirichlet_values_entries(:)
  
  assert ( this%is_integration_updated() )
  
  strong_dirichlet_values         => fe_function%get_fixed_dof_values()
  strong_dirichlet_values_entries => strong_dirichlet_values%get_entries()
  
  elmat_col = 0
  do field_id = 1, this%fe_space%get_num_fields()
    if ( this%at_strong_dirichlet_boundary(field_id) ) then
      do idof = 1, size(this%fe_dofs(field_id)%p)
        elmat_col = elmat_col + 1
        dof_gid = this%fe_dofs(field_id)%p(idof)
        if ( this%fe_space%is_strong_dirichlet_dof(dof_gid) ) then 
          elvec = elvec - elmat(:,elmat_col)*strong_dirichlet_values_entries(abs(dof_gid))
        end if
      end do
    end if
  end do
end subroutine fe_cell_iterator_impose_strong_dirichlet_bcs_conforming

subroutine fe_cell_iterator_impose_strong_dirichlet_bcs_non_conforming ( this, fe_function )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  type(fe_function_t)      , intent(in)    :: fe_function
  
  type(serial_scalar_array_t), pointer :: strong_dirichlet_values
  real(rp)                   , pointer :: strong_dirichlet_values_entries(:)
  integer(ip) :: ifield, i_lid, i_gid, i_gid_hanging, k_lid, k_gid, pos, spos, epos
  real(rp) :: weight
  integer(ip) :: offset
  
  assert ( this%is_integration_updated() )
  
  strong_dirichlet_values         => fe_function%get_fixed_dof_values()
  strong_dirichlet_values_entries => strong_dirichlet_values%get_entries()
  do ifield=1, this%get_num_fields() 
     if (ifield==1) then
       offset = 0
     else
       offset = offset + this%num_cell_dofs_x_field(ifield-1)
     end if
     do i_lid=1, this%num_cell_dofs_x_field(ifield)
        i_gid = this%fe_dofs(ifield)%p(i_lid)
        ! i is a hanging DoF?
        if ( this%is_hanging_dof(i_gid) ) then
           ! Traverse constraining dirichlet DoFs of i
           i_gid_hanging = abs(i_gid) - this%fe_space%num_dirichlet_dofs
           spos = this%fe_space%ptr_constraining_dirichlet_dofs%get(i_gid_hanging)
           epos = this%fe_space%ptr_constraining_dirichlet_dofs%get(i_gid_hanging+1)-1
           do pos=spos, epos 
              k_gid = this%fe_space%constraining_dirichlet_dofs%get(pos)
              weight = this%fe_space%constraining_dirichlet_dofs_coefficients%get(pos)
              ! add the hanging dof column * weighting * dirichlet dof value * -1 to the RHS (for extended elvec)
              this%extended_elvec%a(:) = this%extended_elvec%a(:)-weight*this%extended_elmat%a(:,i_lid+offset)*strong_dirichlet_values_entries(abs(k_gid))
           end do
        ! i is dirichlet dof, proceed as usual
        else if ( this%is_strong_dirichlet_dof(i_gid) ) then
           this%extended_elvec%a(:) = this%extended_elvec%a(:)-this%extended_elmat%a(:,i_lid+offset)*strong_dirichlet_values_entries(abs(i_gid))
        end if
     end do
  end do
  
end subroutine fe_cell_iterator_impose_strong_dirichlet_bcs_non_conforming

subroutine fe_cell_iterator_assembly_array ( this,  &
                                             elvec, &
                                             assembler )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  real(rp)                 , intent(in)    :: elvec(:)
  class(assembler_t)       , intent(inout) :: assembler
  
  logical     :: no_hanging_node_constraints
  integer(ip) :: ifield
  
  no_hanging_node_constraints = .true.
  do ifield=1, this%fe_space%num_fields
     if ( this%has_hanging_dofs(ifield) ) then
        no_hanging_node_constraints = .false.
        exit
     end if
  end do

  call this%update_assembly_scratch_data()
  if ( no_hanging_node_constraints ) then
    call assembler%assembly_array( this%fe_space%num_fields,            &
                                   this%fe_space%get_field_blocks(),    &
                                   this%num_cell_dofs_x_field,          &
                                   this%fe_dofs,                        &
                                   elvec )
  else
     call this%apply_constraints ( elvec )
     call assembler%assembly_array( this%fe_space%num_fields,           &
                                    this%fe_space%get_field_blocks(),   &
                                    this%num_cell_dofs_x_field,         &
                                    this%fe_dofs,                       &
                                    this%extended_elvec%a )
  end if
  
end subroutine fe_cell_iterator_assembly_array

subroutine fe_cell_iterator_assembly_matrix ( this,  &
                                              elmat, &
                                              assembler )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  real(rp)                 , intent(in)    :: elmat(:,:)
  class(assembler_t)       , intent(inout) :: assembler
  
  logical     :: no_hanging_node_constraints
  integer(ip) :: ifield
  
  no_hanging_node_constraints = .true.
  do ifield=1, this%fe_space%num_fields
     if ( this%has_hanging_dofs(ifield) ) then
        no_hanging_node_constraints = .false.
        exit
     end if
  end do
  
  call this%update_assembly_scratch_data()
  if ( no_hanging_node_constraints ) then
    call assembler%assembly_matrix( this%fe_space%num_fields,           &
                                    this%fe_space%get_field_blocks(),   &
                                    this%fe_space%get_field_coupling(), &
                                    this%num_cell_dofs_x_field,         &
                                    this%num_cell_dofs_x_field,         &
                                    this%fe_dofs,                       &
                                    this%fe_dofs,                       &
                                    elmat )
  else
     call this%apply_constraints ( elmat )
     call assembler%assembly_matrix( this%fe_space%num_fields,           &
                                     this%fe_space%get_field_blocks(),   &
                                     this%fe_space%get_field_coupling(), &
                                     this%num_cell_dofs_x_field,         &
                                     this%num_cell_dofs_x_field,         &
                                     this%fe_dofs,                       &
                                     this%fe_dofs,                       &
                                     this%extended_elmat%a )
  end if
  
end subroutine fe_cell_iterator_assembly_matrix

subroutine fe_cell_iterator_assembly_matrix_array ( this,  &
                                                    elmat, &
                                                    elvec, &
                                                    assembler )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  real(rp)                 , intent(in)    :: elmat(:,:)
  real(rp)                 , intent(in)    :: elvec(:)
  class(assembler_t)       , intent(inout) :: assembler
  
  logical     :: no_hanging_node_constraints
  integer(ip) :: ifield
  
  no_hanging_node_constraints = .true.
  do ifield=1, this%fe_space%num_fields
     if ( this%has_hanging_dofs(ifield) ) then
        no_hanging_node_constraints = .false.
        exit
     end if
  end do
  
  call this%update_assembly_scratch_data()
  if ( no_hanging_node_constraints ) then
    call assembler%assembly_matrix( this%fe_space%num_fields,           &
                                    this%fe_space%get_field_blocks(),   &
                                    this%fe_space%get_field_coupling(), &
                                    this%num_cell_dofs_x_field,         &
                                    this%num_cell_dofs_x_field,         &
                                    this%fe_dofs,                       &
                                    this%fe_dofs,                       &
                                    elmat )
    call assembler%assembly_array( this%fe_space%num_fields,            &
                                   this%fe_space%get_field_blocks(),    &
                                   this%num_cell_dofs_x_field,          &
                                   this%fe_dofs,                        &
                                   elvec )
  else
     call this%apply_constraints ( elmat, elvec )
     call assembler%assembly_matrix( this%fe_space%num_fields,           &
                                     this%fe_space%get_field_blocks(),   &
                                     this%fe_space%get_field_coupling(), &
                                     this%num_cell_dofs_x_field,         &
                                     this%num_cell_dofs_x_field,         &
                                     this%fe_dofs,                       &
                                     this%fe_dofs,                       &
                                     this%extended_elmat%a )
     call assembler%assembly_array( this%fe_space%num_fields,           &
                                    this%fe_space%get_field_blocks(),   &
                                    this%num_cell_dofs_x_field,         &
                                    this%fe_dofs,                       &
                                    this%extended_elvec%a )
  end if
  
end subroutine fe_cell_iterator_assembly_matrix_array

subroutine fe_cell_iterator_assembly_matrix_array_with_strong_bcs ( this,        &
                                                                    fe_function, &
                                                                    elmat,       &
                                                                    elvec,       &
                                                                    assembler )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  type(fe_function_t)      , intent(in)    :: fe_function
  real(rp)                 , intent(in)    :: elmat(:,:)
  real(rp)                 , intent(inout) :: elvec(:)
  class(assembler_t)       , intent(inout) :: assembler
  integer(ip), pointer :: field_blocks(:)
  logical, pointer :: field_coupling(:,:)
  
  logical :: no_hanging_node_constraints
  integer(ip) :: ifield
  
  no_hanging_node_constraints = .true.
  do ifield=1, this%fe_space%num_fields
     if ( this%has_hanging_dofs(ifield) ) then
        no_hanging_node_constraints = .false.
        exit
     end if
  end do
  
  call this%update_assembly_scratch_data()
  field_blocks   => this%fe_space%get_field_blocks()
  field_coupling => this%fe_space%get_field_coupling()
  if ( no_hanging_node_constraints ) then
    call this%impose_strong_dirichlet_bcs ( fe_function, elmat, elvec )
    call assembler%assembly_matrix( this%fe_space%num_fields,           &
                                    field_blocks,   &
                                    field_coupling, &
                                    this%num_cell_dofs_x_field,         &
                                    this%num_cell_dofs_x_field,         &
                                    this%fe_dofs,                       &
                                    this%fe_dofs,                       &
                                    elmat )
    call assembler%assembly_array( this%fe_space%num_fields,            &
                                   field_blocks,    &
                                   this%num_cell_dofs_x_field,          &
                                   this%fe_dofs,                        &
                                   elvec )
  else
     call this%apply_constraints ( elmat, elvec )
     call this%impose_strong_dirichlet_bcs ( fe_function )
     call assembler%assembly_matrix( this%fe_space%num_fields,           &
                                     field_blocks,   &
                                     field_coupling, &
                                     this%num_cell_dofs_x_field,         &
                                     this%num_cell_dofs_x_field,         &
                                     this%fe_dofs,                       &
                                     this%fe_dofs,                       &
                                     this%extended_elmat%a )
     call assembler%assembly_array( this%fe_space%num_fields,           &
                                    field_blocks,   &
                                    this%num_cell_dofs_x_field,         &
                                    this%fe_dofs,                       &
                                    this%extended_elvec%a )
  end if
  
end subroutine fe_cell_iterator_assembly_matrix_array_with_strong_bcs

subroutine fe_cell_iterator_clear_scratch_field_fe_dofs(this,field_id)
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)              , intent(in)    :: field_id
  this%fe_dofs(field_id)%p = 0
end subroutine fe_cell_iterator_clear_scratch_field_fe_dofs

subroutine fe_cell_iterator_first_local_non_void(this,field_id)
 implicit none
 class(fe_cell_iterator_t), intent(inout) :: this
 integer(ip),          intent(in)    :: field_id
 class(triangulation_t), pointer :: triangulation
 ! Find the first local elem non void in this field
 ! If all local elems are void, then position the iterator at the end ( this%has_finished() == .true. )
 call this%first()
 do while( .not. this%has_finished())
   if (this%is_local()) then
     if ( .not. this%is_void(field_id) ) exit
   end if
   call this%next()
 end do
end subroutine fe_cell_iterator_first_local_non_void

function fe_cell_iterator_get_boundary_quadrature(this) result (quadrature)
  implicit none
  class(fe_cell_iterator_t),  intent(in) :: this
  type(quadrature_t), pointer      :: quadrature
  mcheck(.false.,'This TPB cannot be called from this class')
end function fe_cell_iterator_get_boundary_quadrature

function fe_cell_iterator_get_boundary_piecewise_cell_map(this) result (cell_map)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  type(piecewise_cell_map_t), pointer :: cell_map
  mcheck(.false.,'This TPB cannot be called from this class')
end function fe_cell_iterator_get_boundary_piecewise_cell_map

function fe_cell_iterator_get_boundary_cell_map(this) result (cell_map)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  type(cell_map_t), pointer :: cell_map
  mcheck(.false.,'This TPB cannot be called from this class')
end function fe_cell_iterator_get_boundary_cell_map

function fe_cell_iterator_get_boundary_cell_integrator(this, field_id) result (cell_int)
  implicit none
  class(fe_cell_iterator_t), intent(in)   :: this
  integer(ip)         , intent(in)   :: field_id
  type(cell_integrator_t), pointer :: cell_int
  mcheck(.false.,'This TPB cannot be called from this class')
end function fe_cell_iterator_get_boundary_cell_integrator

subroutine fe_cell_iterator_update_boundary_integration( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  mcheck(.false.,'This TPB cannot be called from this class')
end subroutine fe_cell_iterator_update_boundary_integration

subroutine fe_cell_iterator_get_values_scalar (this, values, field_id)
  implicit none
  class(fe_cell_iterator_t)   , intent(in)    :: this
  real(rp), allocatable        , intent(inout) :: values(:,:)
  integer(ip)     , optional   , intent(in)    :: field_id
  integer(ip) :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  cell_integrator => this%get_cell_integrator(field_id_)
  call cell_integrator%get_values(values)
end subroutine fe_cell_iterator_get_values_scalar

subroutine fe_cell_iterator_get_values_vector (this, values, field_id)
  implicit none
  class(fe_cell_iterator_t)       , intent(in)    :: this
  type(vector_field_t), allocatable, intent(inout) :: values(:,:)
  integer(ip)     , optional       , intent(in)    :: field_id
  integer(ip) :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  cell_integrator => this%get_cell_integrator(field_id_)
  call cell_integrator%get_values(values)
end subroutine fe_cell_iterator_get_values_vector

subroutine fe_cell_iterator_get_gradients_scalar (this, gradients, field_id)
  implicit none
  class(fe_cell_iterator_t)              , intent(in)    :: this
  type(vector_field_t),        allocatable, intent(inout) :: gradients(:,:)
  integer(ip)     , optional              , intent(in)    :: field_id
  integer(ip) :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  cell_integrator => this%get_cell_integrator(field_id_)
  call cell_integrator%get_gradients(gradients)
end subroutine fe_cell_iterator_get_gradients_scalar

subroutine fe_cell_iterator_get_gradients_vector (this, gradients, field_id)
  implicit none
  class(fe_cell_iterator_t)           , intent(in)     :: this
  type(tensor_field_t),     allocatable, intent(inout)  :: gradients(:,:)
  integer(ip)     , optional           , intent(in)     :: field_id
  integer(ip) :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  cell_integrator => this%get_cell_integrator(field_id_)
  call cell_integrator%get_gradients(gradients)
end subroutine fe_cell_iterator_get_gradients_vector

subroutine fe_cell_iterator_get_divergences_vector (this, divergences, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp), allocatable     , intent(inout) :: divergences(:,:)
  integer(ip)  , optional   , intent(in)    :: field_id
  integer(ip) :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  cell_integrator => this%get_cell_integrator(field_id_)
  call cell_integrator%get_divergences(divergences)
end subroutine fe_cell_iterator_get_divergences_vector

subroutine fe_cell_iterator_get_curls_vector (this, curls, field_id)
  implicit none
  class(fe_cell_iterator_t)       , intent(in)    :: this
  type(vector_field_t), allocatable, intent(inout) :: curls(:,:)
  integer(ip)     , optional       , intent(in)    :: field_id
  integer(ip) :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  cell_integrator => this%get_cell_integrator(field_id_)
  call cell_integrator%get_curls(curls)
end subroutine fe_cell_iterator_get_curls_vector

subroutine fe_cell_iterator_get_laplacians_scalar (this, laplacians, field_id)
  implicit none
  class(fe_cell_iterator_t)   , intent(in)    :: this
  real(rp), allocatable        , intent(inout) :: laplacians(:,:)
  integer(ip)     , optional   , intent(in)    :: field_id
  integer(ip) :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  cell_integrator => this%get_cell_integrator(field_id_)
  call cell_integrator%get_laplacians(laplacians)
end subroutine fe_cell_iterator_get_laplacians_scalar

subroutine fe_cell_iterator_get_laplacians_vector (this, laplacians, field_id)
  implicit none
  class(fe_cell_iterator_t)       , intent(in)    :: this
  type(vector_field_t), allocatable, intent(inout) :: laplacians(:,:)
  integer(ip)     , optional       , intent(in)    :: field_id
  integer(ip) :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  cell_integrator => this%get_cell_integrator(field_id_)
  call cell_integrator%get_laplacians(laplacians)
end subroutine fe_cell_iterator_get_laplacians_vector

!=================================================================================================
subroutine fe_cell_iterator_evaluate_fe_function_scalar ( this,                     &
                                                         nodal_values,             &
                                                         quadrature_points_values, &
                                                         field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  real(rp), allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  cell_integrator => this%get_cell_integrator(field_id_)
  call cell_integrator%evaluate_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_fe_function_scalar
!=================================================================================================
subroutine fe_cell_iterator_evaluate_fe_function_vector ( this,                     &
                                                         nodal_values,             &
                                                         quadrature_points_values, &
                                                         field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  type(vector_field_t)    , allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  cell_integrator => this%get_cell_integrator(field_id_)
  call cell_integrator%evaluate_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_fe_function_vector
!=================================================================================================
subroutine fe_cell_iterator_evaluate_fe_function_tensor ( this,                     &
                                                         nodal_values,             &
                                                         quadrature_points_values, &
                                                         field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  type(tensor_field_t)    , allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  cell_integrator => this%get_cell_integrator(field_id_)
  call cell_integrator%evaluate_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_fe_function_tensor
!=================================================================================================
subroutine fe_cell_iterator_evaluate_gradient_fe_function_scalar ( this,                     &
                                                         nodal_values,             &
                                                         quadrature_points_values, &
                                                         field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  type(vector_field_t)    , allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  cell_integrator => this%get_cell_integrator(field_id_)
  call cell_integrator%evaluate_gradient_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_gradient_fe_function_scalar
!=================================================================================================
subroutine fe_cell_iterator_evaluate_gradient_fe_function_vector ( this,                     &
                                                         nodal_values,             &
                                                         quadrature_points_values, &
                                                         field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  type(tensor_field_t)    , allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  cell_integrator => this%get_cell_integrator(field_id_)
  call cell_integrator%evaluate_gradient_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_gradient_fe_function_vector
!=================================================================================================
subroutine fe_cell_iterator_evaluate_laplacian_fe_function_scalar ( this,                     &
                                                                    nodal_values,             &
                                                                    quadrature_points_values, &
                                                                    field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  real(rp), allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  cell_integrator => this%get_cell_integrator(field_id_)
  call cell_integrator%evaluate_laplacian_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_laplacian_fe_function_scalar
!=================================================================================================
subroutine fe_cell_iterator_evaluate_laplacian_fe_function_vector ( this,                     &
                                                                    nodal_values,             &
                                                                    quadrature_points_values, &
                                                                    field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  type(vector_field_t)    , allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  cell_integrator => this%get_cell_integrator(field_id_)
  call cell_integrator%evaluate_laplacian_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_laplacian_fe_function_vector

!=================================================================================================
subroutine fe_cell_iterator_apply_constraints_array(this, elvec)
  implicit none
  class(fe_cell_iterator_t), intent(inout)    :: this
  real(rp), intent(in) :: elvec(:)
  integer(ip) :: ifield, i_lid, j_lid, i_gid, i_gid_hanging, j_gid, total_num_dofs
  integer(ip) :: num_fields, num_dofs_field, num_dofs_field_i
  integer(ip) :: current_i, current_extended_i
  integer(ip) :: k_lid, k_gid, pos, spos, epos, iblock
  real(rp) :: weight
  integer(ip), pointer :: field_blocks(:)
  integer(ip) :: offset
  integer(ip), pointer :: p_ptr_constraining_free_dofs(:)
  integer(ip), pointer :: p_constraining_free_dofs(:)
  real(rp), pointer :: p_constraining_free_dofs_coefficients(:)
  
  field_blocks                          => this%get_field_blocks()
  num_fields                            = this%get_num_fields()
  p_ptr_constraining_free_dofs          => this%fe_space%ptr_constraining_free_dofs%get_pointer()
  p_constraining_free_dofs              => this%fe_space%constraining_free_dofs%get_pointer()
  p_constraining_free_dofs_coefficients => this%fe_space%constraining_free_dofs_coefficients%get_pointer()

  ! Count number of free dofs involved in the assembly of this cell
  ! i.e., the free dofs of the cell + all other free dofs that constrain
  ! hanging dofs of the cell  
  call this%compute_gid_to_lid_ext_fe_dofs_num_cell_dofs_and_fe_dofs()

  ! Compute all extended dofs, and resize elvec accordingly
  total_num_dofs = sum(this%num_cell_dofs_x_field)
  call this%extended_elvec%resize(total_num_dofs)
  this%extended_elvec%a(1:total_num_dofs) = 0.0_rp

  current_i          = 1 
  current_extended_i = 1     
  do ifield=1, num_fields   
     num_dofs_field_i = this%get_num_dofs_field(ifield)
     this%extended_elvec%a(current_extended_i:current_extended_i+num_dofs_field_i-1) &
          & = elvec(current_i:current_i+num_dofs_field_i-1)
     current_i = current_i + num_dofs_field_i
     current_extended_i = current_extended_i + this%num_cell_dofs_x_field(ifield)       
  end do

  ! Now, we want to compute the vector entries for the constraining free dofs, both the own constraining free dofs
  ! and the outer ones
  do ifield=1, num_fields 
     iblock = field_blocks(ifield)
     if (ifield==1) then
        offset = 0
     else
        offset = offset + this%num_cell_dofs_x_field(ifield-1)
     end if
     num_dofs_field = this%get_num_dofs_field(ifield)
     do i_lid=1, this%get_num_dofs_field(ifield)
        i_gid = this%fe_dofs(ifield)%p(i_lid)
        ! i is a hanging DoF?
        if ( this%is_hanging_dof(i_gid) ) then
           ! Traverse constraining free DoFs of i
           i_gid_hanging = abs(i_gid) - this%fe_space%num_dirichlet_dofs
           spos = p_ptr_constraining_free_dofs(i_gid_hanging)
           epos = p_ptr_constraining_free_dofs(i_gid_hanging+1)-1
           do pos=spos, epos 
              k_gid = p_constraining_free_dofs(pos)
              weight = p_constraining_free_dofs_coefficients(pos)
              k_lid = this%gid_to_lid_map(iblock)%a(k_gid)
              ! free dofs, add the hanging dof row * weighting in the free dof row (for extended elmat and elvec)
              this%extended_elvec%a(k_lid+offset)   = this%extended_elvec%a(k_lid+offset)   + weight*this%extended_elvec%a(i_lid+offset)
           end do
        end if
     end do
  end do

  ! Initialize gid_to_lid_map to zero
  call this%reset_gid_to_lid_map()

end subroutine fe_cell_iterator_apply_constraints_array
   
subroutine fe_cell_iterator_apply_constraints_matrix(this,elmat)
  implicit none
  class(fe_cell_iterator_t), intent(inout)    :: this
  real(rp), intent(in) :: elmat(:,:)
  integer(ip) :: ifield, jfield, i_lid, j_lid, i_gid, i_gid_hanging, j_gid, total_num_dofs
  integer(ip) :: num_fields, num_dofs_field, num_dofs_field_i, num_dofs_field_j
  integer(ip) :: current_i, current_extended_i, current_j, current_extended_j
  integer(ip) :: k_lid, k_gid, pos, spos, epos, iblock
  real(rp) :: weight
  integer(ip), pointer :: field_blocks(:)
  integer(ip) :: offset
  integer(ip), pointer :: p_ptr_constraining_free_dofs(:)
  integer(ip), pointer :: p_constraining_free_dofs(:)
  real(rp), pointer :: p_constraining_free_dofs_coefficients(:)
  
  field_blocks                          => this%get_field_blocks()
  num_fields                            = this%get_num_fields()
  p_ptr_constraining_free_dofs          => this%fe_space%ptr_constraining_free_dofs%get_pointer()
  p_constraining_free_dofs              => this%fe_space%constraining_free_dofs%get_pointer()
  p_constraining_free_dofs_coefficients => this%fe_space%constraining_free_dofs_coefficients%get_pointer()

  
  ! Count number of free dofs involved in the assembly of this cell
  ! i.e., the free dofs of the cell + all other free dofs that constrain
  ! hanging dofs of the cell  
  call this%compute_gid_to_lid_ext_fe_dofs_num_cell_dofs_and_fe_dofs()

  ! Compute all extended dofs, and resize elmat accordingly
  total_num_dofs = sum(this%num_cell_dofs_x_field)
  call this%extended_elmat%resize(total_num_dofs, total_num_dofs)
  this%extended_elmat%a(1:total_num_dofs,1:total_num_dofs) = 0.0_rp

  current_i          = 1 
  current_extended_i = 1     
  do ifield=1, num_fields   
     num_dofs_field_i = this%get_num_dofs_field(ifield)
     current_j          = 1 
     current_extended_j = 1   
     do jfield=1, num_fields 
        num_dofs_field_j = this%get_num_dofs_field(jfield)
        ! For every field, insert the cell dofs entries
        this%extended_elmat%a(current_extended_i:current_extended_i+num_dofs_field_i-1, &
             & current_extended_j:current_extended_j+num_dofs_field_j-1) = &
             & elmat(current_i:current_i+num_dofs_field_i-1, &
             & current_j:current_j+num_dofs_field_j-1)
        current_j = current_j + num_dofs_field_j
        current_extended_j = current_extended_j + this%num_cell_dofs_x_field(jfield)  
     end do
     current_i = current_i + num_dofs_field_i
     current_extended_i = current_extended_i + this%num_cell_dofs_x_field(ifield)       
  end do

  ! Now, we want to compute the matrix entries for the constraining free dofs, both the own constraining free dofs
  ! and the outer ones
  do ifield=1, num_fields 
     iblock = field_blocks(ifield)
     if (ifield==1) then
        offset = 0
     else
        offset = offset + this%num_cell_dofs_x_field(ifield-1)
     end if
     num_dofs_field = this%get_num_dofs_field(ifield)
     do i_lid=1, this%get_num_dofs_field(ifield)
        i_gid = this%fe_dofs(ifield)%p(i_lid)
        ! i is a hanging DoF?
        if ( this%is_hanging_dof(i_gid) ) then
           ! Traverse constraining free DoFs of i
           i_gid_hanging = abs(i_gid) - this%fe_space%num_dirichlet_dofs
           spos = p_ptr_constraining_free_dofs(i_gid_hanging)
           epos = p_ptr_constraining_free_dofs(i_gid_hanging+1)-1
           do pos=spos, epos 
              k_gid = p_constraining_free_dofs(pos)
              weight = p_constraining_free_dofs_coefficients(pos)
              k_lid = this%gid_to_lid_map(iblock)%a(k_gid)
              ! free dofs, add the hanging dof row * weighting in the free dof row (for extended elmat and elvec)
              this%extended_elmat%a(k_lid+offset,:) = this%extended_elmat%a(k_lid+offset,:) + weight*this%extended_elmat%a(i_lid+offset,:)
           end do
        end if
     end do
  end do

  ! Idem for columns
  do ifield=1, num_fields 
     iblock = field_blocks(ifield)
     if (ifield==1) then
        offset = 0
     else
        offset = offset + this%num_cell_dofs_x_field(ifield-1)
     end if
     do i_lid=1, this%get_num_dofs_field(ifield)
        i_gid = this%fe_dofs(ifield)%p(i_lid)
        ! i is a hanging DoF?
        if ( this%is_hanging_dof(i_gid) ) then
           ! Traverse constraining free DoFs of i
           i_gid_hanging = abs(i_gid) - this%fe_space%num_dirichlet_dofs
           spos = p_ptr_constraining_free_dofs(i_gid_hanging)
           epos = p_ptr_constraining_free_dofs(i_gid_hanging+1)-1
           do pos=spos, epos 
              k_gid = p_constraining_free_dofs(pos)
              weight = p_constraining_free_dofs_coefficients(pos)
              k_lid = this%gid_to_lid_map(iblock)%a(k_gid)
              ! free dofs, add the hanging dof column * weighting in the free dof column (for extended elmat and elvec)
              this%extended_elmat%a(:,k_lid+offset) = this%extended_elmat%a(:,k_lid+offset) + weight*this%extended_elmat%a(:,i_lid+offset)
           end do
        end if
     end do
  end do

  ! Initialize gid_to_lid_map to zero
  call this%reset_gid_to_lid_map()  

end subroutine fe_cell_iterator_apply_constraints_matrix

subroutine fe_cell_iterator_apply_constraints_matrix_array(this,elmat,elvec)
  implicit none
  class(fe_cell_iterator_t), intent(inout)    :: this
  real(rp), intent(in) :: elmat(:,:)
  real(rp), intent(in) :: elvec(:)

  integer(ip) :: ifield, jfield, i_lid, j_lid, i_gid, i_gid_hanging, j_gid, total_num_dofs
  integer(ip) :: num_fields, num_dofs_field, num_dofs_field_i, num_dofs_field_j
  integer(ip) :: current_i, current_extended_i, current_j, current_extended_j
  integer(ip) :: k_lid, k_gid, pos, spos, epos, iblock
  real(rp) :: weight
  integer(ip), pointer :: field_blocks(:)
  integer(ip) :: offset
  integer(ip), pointer :: p_ptr_constraining_free_dofs(:)
  integer(ip), pointer :: p_constraining_free_dofs(:)
  real(rp), pointer :: p_constraining_free_dofs_coefficients(:)
  
  field_blocks                          => this%get_field_blocks()
  num_fields                            = this%get_num_fields()
  p_ptr_constraining_free_dofs          => this%fe_space%ptr_constraining_free_dofs%get_pointer()
  p_constraining_free_dofs              => this%fe_space%constraining_free_dofs%get_pointer()
  p_constraining_free_dofs_coefficients => this%fe_space%constraining_free_dofs_coefficients%get_pointer()

  ! Count number of free dofs involved in the assembly of this cell
  ! i.e., the free dofs of the cell + all other free dofs that constrain
  ! hanging dofs of the cell  
  call this%compute_gid_to_lid_ext_fe_dofs_num_cell_dofs_and_fe_dofs()

  ! Compute all extended dofs, and resize elmat and elvec accordingly
  total_num_dofs = sum(this%num_cell_dofs_x_field)
  call this%extended_elmat%resize(total_num_dofs, total_num_dofs)
  call this%extended_elvec%resize(total_num_dofs)

  this%extended_elmat%a(1:total_num_dofs,1:total_num_dofs) = 0.0_rp
  this%extended_elvec%a(1:total_num_dofs) = 0.0_rp

  current_i          = 1 
  current_extended_i = 1     
  do ifield=1, num_fields   
     num_dofs_field_i = this%get_num_dofs_field(ifield)
     current_j          = 1 
     current_extended_j = 1   
     do jfield=1, num_fields 
        num_dofs_field_j = this%get_num_dofs_field(jfield)
        ! For every field, insert the cell dofs entries
        this%extended_elmat%a(current_extended_i:current_extended_i+num_dofs_field_i-1, &
             & current_extended_j:current_extended_j+num_dofs_field_j-1) = &
             & elmat(current_i:current_i+num_dofs_field_i-1, &
             & current_j:current_j+num_dofs_field_j-1)
        current_j = current_j + num_dofs_field_j
        current_extended_j = current_extended_j + this%num_cell_dofs_x_field(jfield)  
     end do
     this%extended_elvec%a(current_extended_i:current_extended_i+num_dofs_field_i-1) &
          & = elvec(current_i:current_i+num_dofs_field_i-1)
     current_i = current_i + num_dofs_field_i
     current_extended_i = current_extended_i + this%num_cell_dofs_x_field(ifield)       
  end do

  ! Now, we want to compute the matrix entries for the constraining free dofs, both the own constraining free dofs
  ! and the outer ones
  do ifield=1, num_fields 
     iblock = field_blocks(ifield)
     if (ifield==1) then
        offset = 0
     else
        offset = offset + this%num_cell_dofs_x_field(ifield-1)
     end if
     num_dofs_field = this%get_num_dofs_field(ifield)
     do i_lid=1, this%get_num_dofs_field(ifield)
        i_gid = this%fe_dofs(ifield)%p(i_lid)
        ! i is a hanging DoF?
        if ( this%is_hanging_dof(i_gid) ) then
           ! Traverse constraining free DoFs of i
           i_gid_hanging = abs(i_gid) - this%fe_space%num_dirichlet_dofs
           spos = p_ptr_constraining_free_dofs(i_gid_hanging)
           epos = p_ptr_constraining_free_dofs(i_gid_hanging+1)-1
           do pos=spos, epos 
              k_gid = p_constraining_free_dofs(pos)
              weight = p_constraining_free_dofs_coefficients(pos)
              k_lid = this%gid_to_lid_map(iblock)%a(k_gid)
              ! free dofs, add the hanging dof row * weighting in the free dof row (for extended elmat and elvec)
              this%extended_elmat%a(k_lid+offset,:) = this%extended_elmat%a(k_lid+offset,:) + weight*this%extended_elmat%a(i_lid+offset,:)
              this%extended_elvec%a(k_lid+offset)   = this%extended_elvec%a(k_lid+offset)   + weight*this%extended_elvec%a(i_lid+offset)
           end do
        end if
     end do
  end do

  ! Idem for columns
  do ifield=1, num_fields 
     iblock = field_blocks(ifield)
     if (ifield==1) then
        offset = 0
     else
        offset = offset + this%num_cell_dofs_x_field(ifield-1)
     end if
     do i_lid=1, this%get_num_dofs_field(ifield)
        i_gid = this%fe_dofs(ifield)%p(i_lid)
        ! i is a hanging DoF?
        if ( this%is_hanging_dof(i_gid) ) then
           ! Traverse constraining free DoFs of i
           i_gid_hanging = abs(i_gid) - this%fe_space%num_dirichlet_dofs
           spos = p_ptr_constraining_free_dofs(i_gid_hanging)
           epos = p_ptr_constraining_free_dofs(i_gid_hanging+1)-1
           do pos=spos, epos 
              k_gid = p_constraining_free_dofs(pos)
              weight = p_constraining_free_dofs_coefficients(pos)
              k_lid = this%gid_to_lid_map(iblock)%a(k_gid)
              ! free dofs, add the hanging dof column * weighting in the free dof column (for extended elmat and elvec)
              this%extended_elmat%a(:,k_lid+offset) = this%extended_elmat%a(:,k_lid+offset) + weight*this%extended_elmat%a(:,i_lid+offset)
           end do
        end if
     end do
  end do

  ! Initialize gid_to_lid_map to zero
  call this%reset_gid_to_lid_map()

end subroutine fe_cell_iterator_apply_constraints_matrix_array


subroutine fci_compute_gid_to_lid_ext_fe_dofs_num_cell_dofs_and_fe_dofs(this)
  implicit none
  class(fe_cell_iterator_t), intent(inout)    :: this
  integer(ip)  :: ifield, iblock, i_lid, i_gid, i_gid_hanging, j_gid, j_lid
  integer(ip)  :: num_fields, num_dofs_field
  integer(ip), pointer :: field_blocks(:)
  integer(ip), pointer :: p_ptr_constraining_free_dofs(:)
  integer(ip), pointer :: p_constraining_free_dofs(:)
  real(rp), pointer :: p_constraining_free_dofs_coefficients(:)
  
  field_blocks                          => this%get_field_blocks()  
  num_fields                            = this%get_num_fields()
  p_ptr_constraining_free_dofs          => this%fe_space%ptr_constraining_free_dofs%get_pointer()
  p_constraining_free_dofs              => this%fe_space%constraining_free_dofs%get_pointer()
  p_constraining_free_dofs_coefficients => this%fe_space%constraining_free_dofs_coefficients%get_pointer()  

  ! Count number of free dofs involved in the assembly of this cell
  ! i.e., the free dofs of the cell + all other free dofs that constrain
  ! hanging dofs of the cell
  do ifield=1, num_fields 
     iblock = field_blocks(ifield)
     ! Only if hanging nodes perform the following work
     if ( this%has_hanging_dofs(ifield) ) then
        ! Initialize extended_fe_dofs
        call this%extended_fe_dofs(ifield)%resize(0)
        
        num_dofs_field = this%get_num_dofs_field(ifield)
        
        ! First, insert all free nodes
        do i_lid=1, num_dofs_field
           i_gid = this%fe_dofs(ifield)%p(i_lid)
           if ( this%is_free_dof(i_gid) ) then
              ! Global to local map for free dofs (dofs already belonging to the cell)
              this%gid_to_lid_map(iblock)%a(i_gid) = i_lid
           end if
           ! Insert all dofs belonging to the cell
           call this%extended_fe_dofs(ifield)%push_back(i_gid)
        end do
        do i_lid=1, num_dofs_field
           i_gid = this%fe_dofs(ifield)%p(i_lid)
           if ( this%is_hanging_dof(i_gid) ) then
              ! Only for hanging dofs, find outer constraining dofs
              i_gid_hanging = abs(i_gid) - this%fe_space%num_dirichlet_dofs
              do j_lid= p_ptr_constraining_free_dofs(i_gid_hanging), &
                   p_ptr_constraining_free_dofs(i_gid_hanging+1)-1
                 j_gid = p_constraining_free_dofs(j_lid)
                 ! If not touched constraining free dof, compute gid to lid map, and insert this dof
                 ! in extended_fe_dofs
                 if ( this%gid_to_lid_map(iblock)%a(j_gid) == 0 ) then
                    this%num_cell_dofs_x_field(ifield) = this%num_cell_dofs_x_field(ifield)+1
                    this%gid_to_lid_map(iblock)%a(j_gid) = this%num_cell_dofs_x_field(ifield)
                    call this%extended_fe_dofs(ifield)%push_back(j_gid) 
                 end if
              end do
           end if
        end do
        ! Update the fe_dofs array with the extended ones
        this%fe_dofs(ifield)%p => this%extended_fe_dofs(ifield)%get_pointer()
     end if
  end do
  
end subroutine fci_compute_gid_to_lid_ext_fe_dofs_num_cell_dofs_and_fe_dofs


subroutine fe_cell_iterator_reset_gid_to_lid_map(this)
  implicit none
  class(fe_cell_iterator_t), intent(inout)    :: this
  integer(ip)  :: ifield, iblock, i_lid, i_gid, i_gid_hanging, j_gid, j_lid 
  integer(ip)  :: num_fields
  integer(ip), pointer :: field_blocks(:)
  integer(ip), pointer :: p_ptr_constraining_free_dofs(:)
  integer(ip), pointer :: p_constraining_free_dofs(:)
  real(rp), pointer :: p_constraining_free_dofs_coefficients(:)
  
  field_blocks                          => this%get_field_blocks()  
  num_fields                            = this%get_num_fields()
  p_ptr_constraining_free_dofs          => this%fe_space%ptr_constraining_free_dofs%get_pointer()
  p_constraining_free_dofs              => this%fe_space%constraining_free_dofs%get_pointer()
  p_constraining_free_dofs_coefficients => this%fe_space%constraining_free_dofs_coefficients%get_pointer()  

  ! Initialize gid_to_lid_map to zero
  do ifield=1, num_fields 
     iblock = field_blocks(ifield)
     ! Only if hanging nodes perform the following work
     if ( this%has_hanging_dofs(ifield) ) then
        do i_lid=1, this%get_num_dofs_field(ifield)
           i_gid = this%fe_dofs(ifield)%p(i_lid)
           if ( this%is_hanging_dof(i_gid) ) then
              ! Only for hanging dofs, find outer constraining dofs
              i_gid_hanging = abs(i_gid) - this%fe_space%num_dirichlet_dofs
              do j_lid= p_ptr_constraining_free_dofs(i_gid_hanging), &
                   p_ptr_constraining_free_dofs(i_gid_hanging+1)-1
                 j_gid = p_constraining_free_dofs(j_lid)
                 ! If not touched constraining free dof, compute gid to lid map, and insert this dof
                 ! in extended_fe_dofs
                 this%gid_to_lid_map(iblock)%a(j_gid) = 0
              end do
           else if ( this%is_free_dof(i_gid) ) then
              ! Global to local map for free dofs (dofs already belonging to the cell)
              this%gid_to_lid_map(iblock)%a(i_gid) = 0
           end if
        end do
     end if
  end do  
  
end subroutine fe_cell_iterator_reset_gid_to_lid_map

! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine serial_fe_space_create_with_parameter_list( this,          &
                                                       triangulation, &
                                                       parameters,    &
                                                       conditions,    &
                                                       generate_global_dof_numbering)
  implicit none
  class(serial_fe_space_t)                     ,         intent(inout)   :: this
  class(triangulation_t)                       ,         intent(in)      :: triangulation
  type(ParameterList_t)                        ,         intent(in)      :: parameters
  class(strong_boundary_conditions_t), optional,         intent(inout)   :: conditions
  logical                            , optional,         intent(in)      :: generate_global_dof_numbering 
  
  integer(ip) :: istat, i, num_fields, Nt
  integer(ip), allocatable :: fe_space_field_ids(:), fe_space_field_blocks(:)
  integer(ip), allocatable :: reference_fe_order(:)
  type(p_reference_fe_t), allocatable :: reference_fes(:)
  logical, allocatable :: reference_fe_conformity(:), reference_fe_continuity(:)
  logical :: fe_space_same_reference_fe_all_cells
  
  class(cell_iterator_t), allocatable  :: cell
  class(reference_fe_t), pointer       :: reference_fe_geo
  
  integer(ip), allocatable :: shape(:)
  type(string), allocatable :: fe_space_field_types_array(:), reference_fe_type_array(:)
  
  call this%free()
  
  ! Optional parameters
  istat = parameters%get(key = fes_same_ref_fes_all_cells_key, &
                         value = fe_space_same_reference_fe_all_cells);assert(istat==0)
  
  call this%get_fe_space_num_fields_from_pl(parameters, num_fields)
  call this%get_fe_space_field_blocks_from_pl(parameters,fe_space_field_blocks)
  
  istat = parameters%GetShape(Key=fes_ref_fe_conformities_key, Shape=Shape);assert(istat==0)
  call memalloc( Shape(1), reference_fe_conformity, __FILE__, __LINE__) 
  istat = parameters%get(key = fes_ref_fe_conformities_key, value = reference_fe_conformity);assert(istat==0)
  if ( .not. Shape(1) == num_fields ) then
    call memrealloc(num_fields,reference_fe_conformity,__FILE__,__LINE__)
    reference_fe_conformity(1:num_fields) = .true.   
    wassert( .false., fes_ref_fe_conformities_key // " size is different from the value provided to " // fes_num_fields_key // ", assuming conformity for all fields" )
  end if
  
  istat = parameters%GetShape(Key=fes_ref_fe_continuities_key, Shape=Shape);assert(istat==0)
  call memalloc( Shape(1), reference_fe_continuity, __FILE__, __LINE__) 
  istat = parameters%get(key = fes_ref_fe_continuities_key, value = reference_fe_continuity);assert(istat==0)
  if ( .not. Shape(1) == num_fields ) then
    call memrealloc(num_fields,reference_fe_continuity,__FILE__,__LINE__)
    reference_fe_continuity(1:num_fields) = .true.   
    wassert( .false., fes_ref_fe_continuities_key // " size is different from the value provided to " // fes_num_fields_key // ", assuming conformity for all fields" )
  end if


  istat = parameters%GetShape(Key=fes_field_types_key, Shape=Shape);assert(istat==0)
  massert( Shape(1) == num_fields, fes_field_types_key // " size is different from the value provided to " // fes_num_fields_key )
  allocate(fe_space_field_types_array(Shape(1)))
  istat = parameters%get(key = fes_field_types_key, value = fe_space_field_types_array);assert(istat==0)

  istat = parameters%GetShape(Key=fes_ref_fe_types_key, Shape=Shape);assert(istat==0)
  massert( Shape(1) == num_fields, fes_ref_fe_types_key // " size is different from the value provided to " // fes_num_fields_key )
  allocate(reference_fe_type_array(Shape(1)))
  istat = parameters%get(key = fes_ref_fe_types_key, value = reference_fe_type_array);assert(istat==0)
  
  istat = parameters%GetShape(Key=fes_ref_fe_orders_key, Shape=Shape);assert(istat==0)
  massert( Shape(1) == num_fields, fes_ref_fe_orders_key // " size is different from the value provided to " // fes_num_fields_key )
  call memalloc( num_fields, reference_fe_order, __FILE__, __LINE__) 
  istat = parameters%get(key = fes_ref_fe_orders_key, value = reference_fe_order)

  allocate(this%reference_fes_internally_allocated(num_fields), stat=istat); check(istat==0)
  if ( fe_space_same_reference_fe_all_cells ) then
    ! Extract cell topology
    call triangulation%create_cell_iterator(cell)
    reference_fe_geo => cell%get_reference_fe()
    ! Create reference FEs
    do i = 1, num_fields
      this%reference_fes_internally_allocated(i) = make_reference_fe ( topology = reference_fe_geo%get_topology(), &
                                                                       fe_type = trim(reference_fe_type_array(i)%chars()), &
                                                                       num_dims = triangulation%get_num_dims(), &
                                                                       order =    reference_fe_order(i), &
                                                                       field_type = trim(fe_space_field_types_array(i)%chars()), &
                                                                       conformity = reference_fe_conformity(i) )
    end do
    call triangulation%free_cell_iterator(cell)
    
    call this%set_triangulation(triangulation)
    call this%set_environment(triangulation%get_environment())
    call this%set_num_fields(num_fields)
    call this%allocate_and_fill_reference_fes(this%reference_fes_internally_allocated)
    call this%allocate_and_fill_set_ids_to_reference_fes(  RESHAPE([(i, i=1,size(this%reference_fes_internally_allocated))], [size(this%reference_fes_internally_allocated),1]) )
    call this%allocate_field_cell_to_ref_fes()
    call this%fill_field_cell_to_ref_fes_same_on_all_cells()
    this%same_reference_fes_on_all_cells = .true. 
    call this%allocate_same_reference_fe_or_void_x_field()
    this%same_reference_fe_or_void_x_field(:) = .true.
    call this%allocate_and_fill_gen_dof_num_scratch_data()
    call this%check_cell_vs_fe_topology_consistency()
    call this%allocate_and_fill_fe_space_type_x_field()
    call this%fill_facet_gids()
    call this%allocate_and_init_ptr_lst_dofs_gids()
    
    else
      massert( 0 == 1, "Parameter list based FE space constructor not available" )
  end if
  
  if ( present(conditions) ) then
    call conditions%process_boundary_condition(this)
    call this%set_conditions(conditions)
  end if
  call this%allocate_and_init_at_strong_dirichlet_bound()
  call this%allocate_and_init_has_fixed_dofs()
  call this%allocate_and_init_has_hanging_dofs_x_fe()
  call this%set_up_strong_dirichlet_bcs()
  call this%block_layout%create( this%get_num_fields(),fe_space_field_blocks)   
  if ( present(generate_global_dof_numbering) ) then
    if ( generate_global_dof_numbering ) then
      call this%generate_global_dof_numbering()
    end if 
  else
    call this%generate_global_dof_numbering()
  end if
  call memfree( reference_fe_order, __FILE__, __LINE__) 
  call memfree( reference_fe_continuity, __FILE__, __LINE__) 
  call memfree( reference_fe_conformity, __FILE__, __LINE__) 
  call memfree( fe_space_field_blocks, __FILE__, __LINE__) 
end subroutine serial_fe_space_create_with_parameter_list

subroutine serial_fe_space_get_fe_space_num_fields_from_pl ( this, &
                                                         parameters, &
                                                         num_fields ) 
   implicit none
   class(serial_fe_space_t), intent(in)    :: this
   type(ParameterList_t)   , intent(in)    :: parameters
   integer(ip)             , intent(inout) :: num_fields
   integer(ip) :: istat
   istat = parameters%get(key = fes_num_fields_key, value = num_fields); assert(istat==0)
end subroutine serial_fe_space_get_fe_space_num_fields_from_pl 

subroutine serial_fe_space_get_fe_space_field_blocks_from_pl ( this, &
                                                           parameters, &
                                                           fe_space_field_blocks  ) 
   implicit none
   class(serial_fe_space_t), intent(in)    :: this
   type(ParameterList_t)   , intent(in)    :: parameters
   integer(ip), allocatable, intent(inout) :: fe_space_field_blocks(:)
   integer(ip) :: istat, num_fields
   integer(ip), allocatable :: Shape(:)
   if ( allocated(fe_space_field_blocks) ) then
     call memfree( fe_space_field_blocks, __FILE__, __LINE__) 
   end if 
   call this%get_fe_space_num_fields_from_pl(parameters, num_fields)
   istat = parameters%GetShape(Key=fes_field_blocks_key, Shape=Shape); assert(istat==0)
   call memalloc( Shape(1), fe_space_field_blocks, __FILE__, __LINE__) 
   istat = parameters%get(key = fes_field_blocks_key, value = fe_space_field_blocks); assert(istat==0)
   if ( .not. Shape(1) == num_fields ) then
     call memrealloc(num_fields,fe_space_field_blocks,__FILE__,__LINE__)
     fe_space_field_blocks(1:num_fields) = 1    
     wassert( .false., fes_field_blocks_key // " size is different from the value provided to " // fes_num_fields_key // ", assuming monolithic storage")
   end if
end subroutine serial_fe_space_get_fe_space_field_blocks_from_pl 
                                                           

subroutine serial_fe_space_create_same_reference_fes_on_all_cells( this,          &
                                                                   triangulation, &
                                                                   reference_fes, &
                                                                   conditions,    &
                                                                   field_blocks,  &
                                                                   field_coupling, &
                                                                   generate_global_dof_numbering)
  implicit none
  class(serial_fe_space_t)                     , intent(inout) :: this
  class(triangulation_t)                       , intent(in)    :: triangulation
  type(p_reference_fe_t)                       , intent(in)    :: reference_fes(:)
  class(conditions_t)               , optional,  intent(in)    :: conditions
  integer(ip)                       , optional , intent(in)    :: field_blocks(:)
  logical                           , optional , intent(in)    :: field_coupling(:,:)
  logical                           , optional , intent(in)    :: generate_global_dof_numbering

  integer(ip) :: i, istat, jfield, ifield
  logical :: perform_numbering

  call this%free()

  call this%set_triangulation(triangulation)
  call this%set_environment(triangulation%get_environment())
  call this%set_num_fields(size(reference_fes))
  call this%allocate_and_fill_reference_fes(reference_fes)
  call this%allocate_and_fill_set_ids_to_reference_fes(  RESHAPE([(i, i=1,size(reference_fes))], [size(reference_fes),1]) )
  call this%allocate_field_cell_to_ref_fes()
  call this%fill_field_cell_to_ref_fes_same_on_all_cells()
  this%same_reference_fes_on_all_cells = .true. 
  call this%allocate_same_reference_fe_or_void_x_field()
  this%same_reference_fe_or_void_x_field(:) = .true.
  call this%allocate_and_fill_gen_dof_num_scratch_data()
  call this%check_cell_vs_fe_topology_consistency()
  call this%allocate_and_fill_fe_space_type_x_field()
  call this%fill_facet_gids()
  call this%allocate_and_init_ptr_lst_dofs_gids()

  if ( present(conditions) ) call this%set_conditions(conditions)
  call this%allocate_and_init_at_strong_dirichlet_bound()
  call this%allocate_and_init_has_fixed_dofs()
  call this%allocate_and_init_has_hanging_dofs_x_fe()
  call this%set_up_strong_dirichlet_bcs()
  
  call this%block_layout%create(this%get_num_fields(),&
                                field_blocks, &
                                field_coupling)
  
  if ( present(generate_global_dof_numbering) ) then
    if ( generate_global_dof_numbering ) then
      call this%generate_global_dof_numbering()
    end if 
  else
    call this%generate_global_dof_numbering()
  end if 
  
end subroutine serial_fe_space_create_same_reference_fes_on_all_cells

subroutine serial_fe_space_create_different_ref_fes_between_cells( this,             &
                                                           triangulation,            &
                                                           reference_fes,            &
                                                           set_ids_to_reference_fes, &
                                                           conditions,               &
                                                           field_blocks,             &
                                                           field_coupling,           &
                                                           generate_global_dof_numbering )
  implicit none
  class(serial_fe_space_t)                    , intent(inout) :: this
  class(triangulation_t)                      , intent(in)    :: triangulation
  type(p_reference_fe_t)                      , intent(in)    :: reference_fes(:)
  integer(ip)                                 , intent(in)    :: set_ids_to_reference_fes(:,:)
  class(conditions_t)               , optional, intent(in)    :: conditions
  integer(ip)                       , optional, intent(in)    :: field_blocks(:)
  logical                           , optional, intent(in)    :: field_coupling(:,:)
  logical                           , optional, intent(in)    :: generate_global_dof_numbering

  call this%free()
  
  call this%set_triangulation(triangulation)
  call this%set_environment(triangulation%get_environment())
  call this%set_num_fields(size(set_ids_to_reference_fes,1))
  call this%allocate_and_fill_reference_fes(reference_fes)
  call this%allocate_and_fill_set_ids_to_reference_fes(set_ids_to_reference_fes)
  call this%allocate_field_cell_to_ref_fes()
  call this%fill_field_cell_to_ref_fes_different_ref_fes_between_cells(set_ids_to_reference_fes)
  this%same_reference_fes_on_all_cells = .false.
  call this%allocate_same_reference_fe_or_void_x_field()
  call this%fill_same_reference_fe_or_void_x_field()
  call this%allocate_and_fill_gen_dof_num_scratch_data()
  call this%check_cell_vs_fe_topology_consistency()
  call this%allocate_and_fill_fe_space_type_x_field()
  call this%fill_facet_gids()
  call this%allocate_and_init_ptr_lst_dofs_gids()
  

    if ( present(conditions) ) call this%set_conditions(conditions)
    call this%allocate_and_init_at_strong_dirichlet_bound()
    call this%allocate_and_init_has_fixed_dofs()
    call this%allocate_and_init_has_hanging_dofs_x_fe()
    call this%set_up_strong_dirichlet_bcs()
    call this%block_layout%create( this%get_num_fields(), &
                                 field_blocks, &
                                 field_coupling )   
    if ( present(generate_global_dof_numbering) ) then
      if ( generate_global_dof_numbering ) then
        call this%generate_global_dof_numbering()
      end if 
    else
      call this%generate_global_dof_numbering()
    end if 
end subroutine serial_fe_space_create_different_ref_fes_between_cells

subroutine serial_fe_space_free (this)
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this
  call this%free_reference_fes()
  call this%free_set_ids_to_reference_fes()
  this%same_reference_fes_on_all_cells = .false. 
  call this%free_field_cell_to_ref_fes()
  call this%free_same_reference_fe_or_void_x_field()
  call this%free_fe_space_type_x_field()
  call this%free_facet_gids()
  call this%free_ptr_lst_dofs()
  call this%old_fe_function_nodal_values%free()
  call this%new_fe_function_nodal_values%free()  
  call this%free_at_strong_dirichlet_boundary()
  call this%free_has_fixed_dofs()
  nullify(this%conditions)
  this%num_total_free_dofs  = 0
  this%num_total_free_ghost_dofs = 0
  this%num_fixed_dofs = 0
  if (allocated(this%num_dofs_x_field)) & 
     call memfree( this%num_dofs_x_field, __FILE__, __LINE__ )
  if (allocated(this%num_global_dofs_x_block)) & 
     call memfree( this%num_global_dofs_x_block, __FILE__, __LINE__ )
  call this%free_gen_dof_num_scratch_data()
  call this%free_fe_integration()
  call this%free_facet_integration()
  this%num_hanging_dofs = 0
  this%num_hanging_ghost_dofs = 0
  this%num_dirichlet_dofs = 0
  call this%free_has_hanging_dofs_x_fe()
  call this%free_constraining_dofs_arrays()
  call this%block_layout%free()
  nullify(this%triangulation)
  nullify(this%environment)
end subroutine serial_fe_space_free

subroutine serial_fe_space_free_constraining_dofs_arrays (this)
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this
  call this%free_ptr_constraining_free_dofs()
  call this%free_constraining_free_dofs
  call this%free_constraining_free_dofs_coefficients
  call this%free_ptr_constraining_dirichlet_dofs()
  call this%free_constraining_dirichlet_dofs
  call this%free_constraining_dirichlet_dofs_coefficients
  call this%free_constraints_independent_term
end subroutine serial_fe_space_free_constraining_dofs_arrays

subroutine serial_fe_space_print ( this )
  class(serial_fe_space_t), intent(in)    :: this
  class(fe_cell_iterator_t), allocatable :: fe
  type(i1p_t), allocatable         :: fe_dofs(:)
  integer(ip)                      :: field_id, istat

  if (allocated(this%num_dofs_x_field)) write(*,'(a,i10,a)') '********* num_dofs_x_field ',this%num_dofs_x_field,'********'

  allocate ( fe_dofs(this%get_num_fields()), stat=istat)
  check(istat==0)

  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     write(*,'(a,i10,a)') '********* ELEMENT: ',fe%get_gid(),'********'
     write(*,'(a)') '********* ELEMENT 2 DOF********'
     call fe%get_fe_dofs(fe_dofs)
     do field_id = 1, fe%get_num_fields()
        write(*,'(a,i10,a)') '********* FIELD: ',field_id,'********'
        if ( associated(fe_dofs(field_id)%p) ) then
          write(*,'(10i10)') fe_dofs(field_id)%p
        else
          write(*,'(a)') '(not associated)'
        end if
     end do
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe)

  deallocate ( fe_dofs, stat=istat)
  check(istat==0)
end subroutine serial_fe_space_print


subroutine serial_fe_space_allocate_and_fill_fe_space_type_x_field(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_cell_iterator_t), allocatable :: fe
  integer(ip) :: field_id
  class(reference_fe_t), pointer ::reference_fe
  call this%free_fe_space_type_x_field()
  call memalloc ( this%num_fields, this%fe_space_type_x_field, __FILE__, __LINE__ )
  do field_id=1, this%get_num_fields()
    this%fe_space_type_x_field(field_id) = this%determine_fe_space_type(field_id)
  end do
#ifdef DEBUG  
  call this%create_fe_cell_iterator(fe)
  call fe%next()
  do while ( .not. fe%has_finished())
     do field_id=1, this%get_num_fields()
        assert ( this%fe_space_type_x_field(field_id) == fe%get_fe_space_type(field_id)  )
     end do
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe)
#endif  
end subroutine serial_fe_space_allocate_and_fill_fe_space_type_x_field

subroutine serial_fe_space_free_fe_space_type_x_field(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if ( allocated(this%fe_space_type_x_field) ) call memfree ( this%fe_space_type_x_field, __FILE__, __LINE__ )
end subroutine serial_fe_space_free_fe_space_type_x_field

subroutine serial_fe_space_allocate_and_init_ptr_lst_dofs_gids(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this

  integer(ip)                    :: field_id
  class(fe_cell_iterator_t), allocatable :: fe
  class(reference_fe_t), pointer :: reference_fe
  integer(ip)                    :: error

  if ( .not. allocated(this%ptr_dofs_x_fe) ) then
    allocate( this%ptr_dofs_x_fe(this%num_fields), stat = error ); check ( error == 0 )
  end if
  
  do field_id = 1,this%num_fields
    call this%ptr_dofs_x_fe(field_id)%resize(this%triangulation%get_num_cells()+1)
  end do
  
  call this%ptr_dofs_x_fe(1)%set(1,1) 
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     do field_id=1, fe%get_num_fields()-1
        reference_fe => fe%get_reference_fe(field_id)
        call this%ptr_dofs_x_fe(field_id+1)%set( fe%get_gid(), & 
             this%ptr_dofs_x_fe(field_id)%get(fe%get_gid()) + reference_fe%get_num_shape_functions() )
     end do
     reference_fe => fe%get_reference_fe(field_id)
     call this%ptr_dofs_x_fe(1)%set( fe%get_gid()+1, & 
          this%ptr_dofs_x_fe(field_id)%get(fe%get_gid()) + reference_fe%get_num_shape_functions() )
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe) 
  
  call this%lst_dofs_gids%resize(0)
  call this%lst_dofs_gids%resize(this%ptr_dofs_x_fe(1)%get(this%triangulation%get_num_cells()+1)-1,0)

end subroutine serial_fe_space_allocate_and_init_ptr_lst_dofs_gids

subroutine serial_fe_space_copy_ptr_lst_dofs ( this, ptr_dofs_x_fe, lst_dofs_gids )
  implicit none
  class(serial_fe_space_t)                  , intent(inout) :: this
  type(std_vector_integer_ip_t), allocatable, intent(inout) :: ptr_dofs_x_fe(:)
  type(std_vector_integer_ip_t)             , intent(inout) :: lst_dofs_gids
  integer(ip) :: field_id, error
  assert ( .not. allocated(ptr_dofs_x_fe) )
  allocate( ptr_dofs_x_fe(this%num_fields), stat = error ); check( error == 0 )
  do field_id = 1,this%num_fields
    call ptr_dofs_x_fe(field_id)%copy(this%ptr_dofs_x_fe(field_id))
  end do
  call lst_dofs_gids%copy(this%lst_dofs_gids)
end subroutine serial_fe_space_copy_ptr_lst_dofs

subroutine serial_fe_space_free_ptr_lst_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: field_id, error
  if ( allocated(this%ptr_dofs_x_fe) ) then
    do field_id = 1,this%num_fields
      call this%ptr_dofs_x_fe(field_id)%free()
    end do
    deallocate( this%ptr_dofs_x_fe, stat = error ) ; check( error == 0 )
  end if
  call this%lst_dofs_gids%free()
end subroutine serial_fe_space_free_ptr_lst_dofs

subroutine serial_fe_space_allocate_and_init_at_strong_dirichlet_bound(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: field_id, error
  if ( .not. allocated( this%at_strong_dirichlet_boundary_x_fe ) ) then
    allocate( this%at_strong_dirichlet_boundary_x_fe(this%num_fields), stat = error ) ; check( error == 0 )
  end if
  do field_id = 1,this%num_fields
    call this%at_strong_dirichlet_boundary_x_fe(field_id)%resize(0)
    call this%at_strong_dirichlet_boundary_x_fe(field_id)%resize(this%triangulation%get_num_cells(),.false.)
  end do
end subroutine serial_fe_space_allocate_and_init_at_strong_dirichlet_bound

subroutine serial_fe_space_free_at_strong_dirichlet_boundary (this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: field_id, error
  if ( allocated(this%at_strong_dirichlet_boundary_x_fe) ) then
    do field_id = 1,this%num_fields
      call this%at_strong_dirichlet_boundary_x_fe(field_id)%free()
    end do
    deallocate( this%at_strong_dirichlet_boundary_x_fe, stat = error ) ; check ( error == 0 )
  end if
end subroutine serial_fe_space_free_at_strong_dirichlet_boundary

subroutine serial_fe_space_allocate_and_init_has_fixed_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: field_id, error
  if ( .not. allocated( this%has_fixed_dofs_x_fe ) ) then
    allocate( this%has_fixed_dofs_x_fe(this%num_fields), stat = error ) ; check( error == 0 )
  end if
  do field_id = 1,this%num_fields
    call this%has_fixed_dofs_x_fe(field_id)%resize(0)
    call this%has_fixed_dofs_x_fe(field_id)%resize(this%triangulation%get_num_cells(),.false.)
  end do
end subroutine serial_fe_space_allocate_and_init_has_fixed_dofs

subroutine serial_fe_space_free_has_fixed_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: field_id, error
  if ( allocated(this%has_fixed_dofs_x_fe) ) then
    do field_id = 1,this%num_fields
      call this%has_fixed_dofs_x_fe(field_id)%free()
    end do
    deallocate( this%has_fixed_dofs_x_fe, stat = error ) ; check ( error == 0 )
  end if
end subroutine serial_fe_space_free_has_fixed_dofs

subroutine serial_fe_space_set_up_strong_dirichlet_bcs( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this

  integer(ip)             :: field_id
  integer(ip)             :: ivef
  integer(ip)             :: component_id
  integer(ip), allocatable :: offset_component_x_field(:)
  integer(ip)             :: istat
  class(fe_cell_iterator_t), allocatable :: fe, source_fe
  class(fe_cell_iterator_t), allocatable :: coarser_fe
  type(fe_vef_iterator_t)    :: vef
  class(reference_fe_t), pointer :: reference_fe
  logical              , allocatable :: components_code(:)
  integer(ip), allocatable           :: visited_proper_vef_to_cell_map(:,:)
  integer(ip), allocatable           :: visited_improper_vef_to_cell_map(:,:)
  integer(ip)                        :: previous_num_dirichlet_dofs
  class(triangulation_t), pointer :: triangulation


  ! Count num_dirichlet_dofs
  this%num_dirichlet_dofs = 0
  this%num_fixed_dofs = 0

  triangulation => this%get_triangulation()

  if ( .not. associated(this%conditions) .or. triangulation%get_num_cells() == 0 ) then
     return
  end if

  ! For every component of every field, we go through all FEs and look for DoFs 
  ! subject to strong Dirichlet BCs. It would be desirable (for efficiency) to 
  ! know a priori which FEs have DoFs which are subject to strong Dirichlet BCs, 
  ! but at the present moment we do not have any way to determine such a thing
  assert ( this%conditions%get_num_components() == this%get_num_components() )
  call memalloc ( this%conditions%get_num_components(), components_code, __FILE__, __LINE__ )

  call memalloc (this%get_num_fields()+1,offset_component_x_field,__FILE__,__LINE__)
  call memalloc ( 2, this%triangulation%get_num_proper_vefs(), visited_proper_vef_to_cell_map,  __FILE__, __LINE__ )
  call memalloc ( 2, this%triangulation%get_num_improper_vefs(), visited_improper_vef_to_cell_map,  __FILE__, __LINE__ )

  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(coarser_fe)
  call this%create_fe_cell_iterator(source_fe)
  call this%create_fe_vef_iterator(vef)

  ! Precompute the offsets
  offset_component_x_field(1) = 1
  do field_id = 1, this%get_num_fields()
     reference_fe => fe%get_reference_fe(field_id)
     offset_component_x_field(field_id+1) = offset_component_x_field(field_id) + reference_fe%get_num_field_components()
  end do

  do field_id = 1, this%get_num_fields()
     ! Initialize
     visited_proper_vef_to_cell_map = -1
     visited_improper_vef_to_cell_map = -1

     call fe%first()
     do while (.not. fe%has_finished() )
        if ( .not. fe%is_void(field_id) ) then
           do ivef = 1, fe%get_num_vefs()
              call fe%get_vef(ivef, vef)

                 ! Check whether a set_id different from 0 has been set for current vef. 
                 !        "0" is a magic number. MUCH BETTER REPLACE by parameter constant.
                 if ( vef%get_set_id() /= 0 .and. vef%all_coarser_cells_are_void(field_id, coarser_fe) ) then

                    ! Get components code corresponding to set_id assigned to current vef
                    ! TO-DO: The number of calls to this TBP (virtual) could be reduced by using
                    ! a more clever strategy. Does pay off to look carefully at this?
                    call this%conditions%get_components_code( vef%get_set_id(), components_code )

                    ! Auxiliary function containing the work done at each innermost iteration
                    previous_num_dirichlet_dofs = this%num_dirichlet_dofs

                    if ( vef%is_proper() ) then
                       call this%set_up_strong_dirichlet_bcs_on_vef_and_field(fe,&
                            vef,&
                            ivef,&
                            field_id,&
                            components_code(offset_component_x_field(field_id):&
                            offset_component_x_field(field_id+1)-1),&
                            visited_proper_vef_to_cell_map,&
                            source_fe)

                       if ( visited_proper_vef_to_cell_map(1, vef%get_gid()) == -1 .and. &
                            previous_num_dirichlet_dofs < this%num_dirichlet_dofs ) then
                          visited_proper_vef_to_cell_map ( 1, vef%get_gid() ) = fe%get_gid()
                          visited_proper_vef_to_cell_map ( 2, vef%get_gid() ) = ivef
                       end if
                    else
                       call this%set_up_strong_dirichlet_bcs_on_vef_and_field(fe,&
                            vef,&
                            ivef,&
                            field_id,&
                            components_code(offset_component_x_field(field_id):&
                            offset_component_x_field(field_id+1)-1),&
                            visited_improper_vef_to_cell_map,&
                            source_fe)

                       if ( visited_improper_vef_to_cell_map(1, abs(vef%get_gid())) == -1 .and. &
                            previous_num_dirichlet_dofs < this%num_dirichlet_dofs ) then
                          visited_improper_vef_to_cell_map ( 1, abs(vef%get_gid()) ) = fe%get_gid()
                          visited_improper_vef_to_cell_map ( 2, abs(vef%get_gid()) ) = ivef
                       end if
                    end if
                 end if
           end do
        end if
        call fe%next()
     end do ! Loop in FEs
  end do ! Loop in fields
  ! This second sweep over all cells cannot be integrated as part of the first one
  ! as the fe%determine_* TBPs have as a pre-condition that this%strong_dirichlet_values
  ! has at least been created (i.e., that it has at least size already set)
  call fe%first()
  do while (.not. fe%has_finished() )
     do field_id = 1, this%get_num_fields()
        call fe%determine_at_strong_dirichlet_boundary(field_id)
     end do
     call fe%next()
  end do

  this%num_fixed_dofs = this%num_dirichlet_dofs

  call memfree ( visited_proper_vef_to_cell_map,  __FILE__, __LINE__ )
  call memfree ( visited_improper_vef_to_cell_map,  __FILE__, __LINE__ )
  call memfree ( components_code, __FILE__, __LINE__ )
  call memfree (offset_component_x_field,__FILE__,__LINE__)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_cell_iterator(source_fe)
  call this%free_fe_vef_iterator(vef)
  call this%free_fe_cell_iterator(coarser_fe)
end subroutine serial_fe_space_set_up_strong_dirichlet_bcs

subroutine serial_fe_space_set_up_strong_dirichlet_bcs_on_vef_and_field(this,&
                                                                        fe, &
                                                                        vef, &
                                                                        ivef, &
                                                                        field_id,&
                                                                        components_code,&
                                                                        visited_vef_to_cell_map,&
                                                                        source_fe)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_cell_iterator_t),     intent(inout) :: fe
  type(fe_vef_iterator_t),  intent(in)    :: vef
  integer(ip),              intent(in)    :: ivef
  integer(ip),              intent(in)    :: field_id
  logical,                  intent(in)    :: components_code(:)
  integer(ip),              intent(inout) :: visited_vef_to_cell_map(:,:)
  class(fe_cell_iterator_t),     intent(inout) :: source_fe

  type(list_iterator_t)           :: own_dofs_on_vef_iterator
  class(reference_fe_t), pointer  :: reference_fe

  ! TO-DO: there is no need to call `get_reference_fe` for each inner loop iteration.
  !        We could use an allocatable array of type(p_reference_fe_t) items, and
  !        allocate/initialize it from the beginning.
  reference_fe => fe%get_reference_fe(field_id)
  assert ( size(components_code) == reference_fe%get_num_field_components() )
  
  ! If reference_fe is interpolatory ... 
  if ( reference_fe%has_nodal_quadrature() ) then
     if ( visited_vef_to_cell_map(1, abs(vef%get_gid())) == -1 ) then
       call fe%generate_own_dofs_vef_component_wise ( ivef, &
                                                     field_id, &
                                                     this%num_dirichlet_dofs, &
                                                     components_code, &
                                                     free_dofs_loop=.false. )
     end if 
  else
     if ( components_code(1) ) then
       if ( visited_vef_to_cell_map(1, abs(vef%get_gid())) == -1 ) then
           call fe%generate_own_dofs_vef ( ivef, &
                                          field_id, &
                                          this%num_dirichlet_dofs, &
                                          free_dofs_loop=.false.)
       end if
     end if
  end if 
  
  if ( visited_vef_to_cell_map(1, abs(vef%get_gid())) /= -1 ) then
    call source_fe%set_gid(visited_vef_to_cell_map(1,abs(vef%get_gid())))
    call fe%fetch_own_dofs_vef_from_source_fe ( ivef, &
                                                source_fe, &
                                                visited_vef_to_cell_map(2,abs(vef%get_gid())), &
                                                field_id) 
  end if
end subroutine serial_fe_space_set_up_strong_dirichlet_bcs_on_vef_and_field

function select_default_interpolator_type(reference_fe) 
  implicit none
  class(reference_fe_t), intent(in) :: reference_fe
  character(:), allocatable :: select_default_interpolator_type
  
  select type ( reference_fe )
  class is (nedelec_reference_fe_t ) 
    select_default_interpolator_type = interpolator_type_Hcurl
  class is (lagrangian_reference_fe_t)
    select_default_interpolator_type = interpolator_type_nodal  
  class is (void_reference_fe_t)
    check(.false.)
  class DEFAULT
  check(.false.) 
  end select 
end function select_default_interpolator_type 

subroutine serial_fe_space_interpolate_scalar_function (this, field_id, function, fe_function, interpolator_type, time)
  implicit none
  class(serial_fe_space_t)         , intent(in)    :: this
  integer(ip)                      , intent(in)    :: field_id
  class(scalar_function_t)         , intent(in)    :: function 
  type(fe_function_t)              , intent(inout) :: fe_function
  character(*)           , optional, intent(in)    :: interpolator_type
  real(rp)               , optional, intent(in)    :: time

  class(reference_fe_t)    , pointer     :: reference_fe 
  class(fe_cell_iterator_t), allocatable :: fe 
  class(fe_cell_iterator_t), allocatable :: aux_fe
  type(fe_vef_iterator_t)                :: vef
  real(rp)                 , allocatable :: dof_values(:)
  class(interpolator_t)    , allocatable :: interpolator
  character(:)             , allocatable :: interpolator_type_
  logical                                :: is_void_field 
  class(triangulation_t)   , pointer     :: triangulation 
  integer(ip)                            :: vef_lid
  integer(ip)                            :: ielem  
  logical                                :: non_void_local_found 

  triangulation => this%get_triangulation() 
  if ( triangulation%get_num_cells() == 0) return 

  ! Extract reference_fe_t instance associated to field_id for the first non-void element 
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(aux_fe)
  call this%create_fe_vef_iterator(vef)

  is_void_field = .true. 
  do while (  (.not. fe%has_finished() )) 
     if ( .not. fe%is_void(field_id)) then 
        is_void_field = .false.; exit 
     end if
     call fe%next() 
  end do

  ! I am already located at the first non-void FE, if it exists
  if ( .not. is_void_field ) then 
     reference_fe => fe%get_reference_fe(field_id)
     call memalloc( reference_fe%get_num_shape_functions(), dof_values, __FILE__, __LINE__ )

     ! Process optional arguments
     if ( present(interpolator_type) ) then
        interpolator_type_ = interpolator_type
     else
        interpolator_type_  = select_default_interpolator_type(reference_fe)
     end if

     call make_interpolator  (interpolator_type_, reference_fe%get_topology(), interpolator )
     call interpolator%create(this, field_id)
     do while (.not. fe%has_finished() )  
        non_void_local_found=.true. 
        if ( .not. fe%is_local() .and. .not. fe%is_void(field_id) ) then 
           vef_loop: do vef_lid = 1, fe%get_num_vefs() 
              call fe%get_vef(vef_lid, vef)
              if ( .not. vef%is_ghost() .and. vef%is_proper() ) then
                 non_void_local_found = .false.
                 do ielem=1, vef%get_num_cells_around()
                    call vef%get_cell_around(ielem, aux_fe)
                    if (aux_fe%is_local() .and. (.not. aux_fe%is_void(field_id))) then
                       non_void_local_found = .true.
                       exit 
                    end if
                 end do
                 if (.not. non_void_local_found) exit vef_loop 
              end if
           end do vef_loop
        end if

        if ( (fe%is_local() .and. .not. fe%is_void(field_id)) .or. .not. non_void_local_found) then
           call interpolator%evaluate_scalar_function_moments( fe, function, dof_values, time=time )
           call fe_function%insert_nodal_values(fe, field_id, dof_values) 
        end if
        call fe%next()
     end do
     call memfree( dof_values, __FILE__, __LINE__ )
     call interpolator%free() 
  end if

  call this%update_hanging_dof_values(fe_function)
  call this%free_fe_cell_iterator(fe) 
  call this%free_fe_cell_iterator(aux_fe)
  call this%free_fe_vef_iterator(vef)
end subroutine serial_fe_space_interpolate_scalar_function

subroutine serial_fe_space_interpolate_vector_function (this, field_id, function, fe_function, interpolator_type, time)
  implicit none
  class(serial_fe_space_t)         , intent(in)    :: this
  integer(ip)                      , intent(in)    :: field_id
  class(vector_function_t)         , intent(in)    :: function 
  type(fe_function_t)              , intent(inout) :: fe_function
  character(*)           , optional, intent(in)    :: interpolator_type
  real(rp)               , optional, intent(in)    :: time

  class(reference_fe_t)    , pointer     :: reference_fe 
  class(fe_cell_iterator_t), allocatable :: fe 
  class(fe_cell_iterator_t), allocatable :: aux_fe
  type(fe_vef_iterator_t)                :: vef
  real(rp)                 , allocatable :: dof_values(:)
  class(interpolator_t)    , allocatable :: interpolator
  character(:)             , allocatable :: interpolator_type_
  logical                  , allocatable :: is_void_field  
  class(triangulation_t)   , pointer     :: triangulation 
  integer(ip)                            :: vef_lid
  integer(ip)                            :: ielem  
  logical                                :: non_void_local_found 

  triangulation => this%get_triangulation() 
  if ( triangulation%get_num_cells() == 0) return 

  ! Extract reference_fe_t instance associated to field_id for the first non-void element 
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(aux_fe)
  call this%create_fe_vef_iterator(vef)

  is_void_field = .true. 
  do while (  (.not. fe%has_finished() )) 
     if ( .not. fe%is_void(field_id) ) then 
        is_void_field = .false.; exit 
     end if
     call fe%next() 
  end do

  ! I am already located at the first non-void FE, if it exists 
  if ( .not. is_void_field ) then    
     reference_fe => fe%get_reference_fe(field_id)
     call memalloc( reference_fe%get_num_shape_functions(), dof_values, __FILE__, __LINE__ )

     ! Process optional arguments
     if ( present(interpolator_type) ) then
        interpolator_type_ = interpolator_type
     else
        interpolator_type_  = select_default_interpolator_type(reference_fe)
     end if

     call make_interpolator  (interpolator_type_, reference_fe%get_topology(), interpolator )
     call interpolator%create(this, field_id)
     do while (.not. fe%has_finished() )  
        non_void_local_found=.true. 
        if ( .not. fe%is_local() .and. .not. fe%is_void(field_id) ) then 
           vef_loop: do vef_lid = 1, fe%get_num_vefs() 
              call fe%get_vef(vef_lid, vef)
              if ( .not. vef%is_ghost() .and. vef%is_proper() ) then
                 non_void_local_found = .false.
                 do ielem=1, vef%get_num_cells_around()
                    call vef%get_cell_around(ielem, aux_fe)
                    if (aux_fe%is_local() .and. (.not. aux_fe%is_void(field_id)) ) then
                       non_void_local_found = .true.
                       exit 
                    end if
                 end do
                 if (.not. non_void_local_found) exit vef_loop
              end if
           end do vef_loop
        end if

        if ( (fe%is_local() .and. .not. fe%is_void(field_id)) .or. .not. non_void_local_found ) then
           call interpolator%evaluate_vector_function_moments( fe, function, dof_values, time=time )
           call fe_function%insert_nodal_values(fe, field_id, dof_values)
        end if

        call fe%next()
     end do
     call memfree( dof_values, __FILE__, __LINE__ ) 
     call interpolator%free() 
  end if

  call this%update_hanging_dof_values(fe_function)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_cell_iterator(aux_fe)
  call this%free_fe_vef_iterator(vef)
end subroutine serial_fe_space_interpolate_vector_function

subroutine serial_fe_space_interpolate_tensor_function (this, field_id, function, fe_function, interpolator_type, time)
  implicit none
  class(serial_fe_space_t)         , intent(in)    :: this
  integer(ip)                      , intent(in)    :: field_id
  class(tensor_function_t)         , intent(in)    :: function 
  type(fe_function_t)              , intent(inout) :: fe_function
  character(*)           , optional, intent(in)    :: interpolator_type
  real(rp)               , optional, intent(in)    :: time

  class(reference_fe_t)    , pointer     :: reference_fe 
  class(fe_cell_iterator_t), allocatable :: fe 
  class(fe_cell_iterator_t), allocatable :: aux_fe
  type(fe_vef_iterator_t)                :: vef
  real(rp)                 , allocatable :: dof_values(:)
  class(interpolator_t)    , allocatable :: interpolator
  character(:)             , allocatable :: interpolator_type_
  logical                  , allocatable :: is_void_field  
  class(triangulation_t)   , pointer     :: triangulation 
  integer(ip)                            :: vef_lid
  integer(ip)                            :: ielem  
  logical                                :: local_found 

  triangulation => this%get_triangulation() 
  if ( triangulation%get_num_cells() == 0) return 

  ! Extract reference_fe_t instance associated to field_id for the first non-void element 
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(aux_fe)
  call this%create_fe_vef_iterator(vef)

  is_void_field = .true. 
  do while (  (.not. fe%has_finished() )) 
     if ( .not. fe%is_void(field_id) ) then 
        is_void_field = .false.; exit 
     end if
     call fe%next() 
  end do

  ! I am already located at the first non-void FE, if it exists 
  if ( .not. is_void_field ) then    
     reference_fe => fe%get_reference_fe(field_id)
     call memalloc( reference_fe%get_num_shape_functions(), dof_values, __FILE__, __LINE__ )

     ! Process optional arguments
     if ( present(interpolator_type) ) then
        interpolator_type_ = interpolator_type
     else
        interpolator_type_  = select_default_interpolator_type(reference_fe)
     end if

     call make_interpolator  (interpolator_type_, reference_fe%get_topology(), interpolator )
     call interpolator%create(this, field_id)
     do while (.not. fe%has_finished() )  
        local_found=.true. 
        if ( .not. fe%is_local() .and. .not. fe%is_void(field_id) ) then 
           vef_loop: do vef_lid = 1, fe%get_num_vefs() 
              call fe%get_vef(vef_lid, vef)
              if ( .not. vef%is_ghost() .and. vef%is_proper() ) then
                 local_found = .false.
                 do ielem=1, vef%get_num_cells_around()
                    call vef%get_cell_around(ielem, aux_fe)
                    if (aux_fe%is_local()) then
                       local_found = .true.
                       exit 
                    end if
                 end do
                 if (.not. local_found) exit vef_loop
              end if
           end do vef_loop
        end if

        if ( (fe%is_local() .and. .not. fe%is_void(field_id)) .or. .not. local_found ) then
           call interpolator%evaluate_tensor_function_moments( fe, function, dof_values, time=time )
           call fe_function%insert_nodal_values(fe, field_id, dof_values)
        end if

        call fe%next()
     end do
     call memfree( dof_values, __FILE__, __LINE__ ) 
     call interpolator%free() 
  end if

  call this%update_hanging_dof_values(fe_function)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_cell_iterator(aux_fe)
  call this%free_fe_vef_iterator(vef)
end subroutine serial_fe_space_interpolate_tensor_function

subroutine serial_fe_space_interpolate_dirichlet_values (this, fe_function, interpolator_type, time, time_derivative_order)
  implicit none
  class(serial_fe_space_t)          , intent(in)    :: this
  type(fe_function_t)               , intent(inout) :: fe_function
  character(*)            , optional, intent(in)    :: interpolator_type(:)
  real(rp)                , optional, intent(in)    :: time
  integer(ip)             , optional, intent(in)    :: time_derivative_order

  class(reference_fe_t)    , pointer        :: reference_fe 
  class(fe_cell_iterator_t), allocatable    :: fe 
  class(fe_cell_iterator_t), allocatable    :: coarser_fe 
  class(fe_cell_iterator_t), allocatable    :: aux_fe 
  type(fe_vef_iterator_t)                   :: vef 
  type(list_iterator_t)                     :: own_dofs_on_vef_iterator  

  integer(ip)                :: field_id 
  integer(ip)                :: icomp, component_id 
  logical     , allocatable  :: components_code(:)
  integer(ip) , allocatable  :: offset_component(:)

  type(p_scalar_function_t), allocatable :: function_scalar_components(:,:)
  real(rp)                 , allocatable :: dof_values(:)  
  integer(ip)              , pointer     :: fe_dofs(:)
  real(rp)                 , pointer     :: fixed_dof_values_entries(:)
  integer(ip)                            :: idof, vef_lid, istat
  type(p_interpolator_t)   , allocatable :: interpolators(:) 
  character(:)             , allocatable :: interpolator_type_
  logical                  , allocatable :: is_void_field(:) 
  logical                  , allocatable :: n_face_mask(:,:) 
  logical                                :: reallocate 
  logical                                :: non_void_local_found
  integer(ip)                            :: ielem
  class(triangulation_t), pointer        :: triangulation 
  
  triangulation => this%get_triangulation()
  if ( triangulation%get_num_cells() == 0 ) return
  
  call this%create_fe_cell_iterator(fe) 
  call this%create_fe_cell_iterator(coarser_fe) 
  call this%create_fe_cell_iterator(aux_fe)
  call memalloc( this%get_num_fields(), is_void_field, __FILE__, __LINE__ ) 

  ! Create and initialize interpolators 
  allocate ( interpolators(this%get_num_fields()), stat=istat); check(istat==0)  
  do field_id = 1, this%get_num_fields() 

     call fe%first() 
     is_void_field(field_id) = .true. 
     do while (  (.not. fe%has_finished() )) 
        if ( .not. fe%is_void(field_id) ) then 
           is_void_field(field_id) = .false.
           exit 
        end if
        call fe%next() 
     end do

     if ( .not. is_void_field(field_id) ) then 
        reference_fe => fe%get_reference_fe(field_id)

        if ( present(interpolator_type) ) then
           interpolator_type_ = interpolator_type(field_id)
        else
           interpolator_type_  = select_default_interpolator_type(reference_fe)
        end if

        call make_interpolator( interpolator_type_, reference_fe%get_topology(), interpolators(field_id)%p )  
        call interpolators(field_id)%p%create( this, field_id ) 
     end if

  end do

  call this%create_fe_vef_iterator(vef)
  fixed_dof_values_entries => fe_function%fixed_dof_values%get_entries()

  call this%allocate_and_fill_offset_component(offset_component)
  assert(associated(this%conditions) )
  call memalloc ( this%get_num_components(), components_code, __FILE__, __LINE__ )

  do field_id = 1, this%get_num_fields()
     if ( .not. is_void_field(field_id) ) then 
        call fe%first() 
        do while (.not. fe%has_finished() )     
           if ( fe%at_strong_dirichlet_boundary(field_id) .and. (.not. fe%is_void(field_id)) ) then 
              reference_fe => fe%get_reference_fe(field_id) 
              ! Allocate field-dependent values at the first non-void FE 
              if ( .not. (allocated(dof_values) )) call memalloc( reference_fe%get_num_shape_functions(), dof_values, __FILE__, __LINE__ ) 
              ! Reallocate FE dependent arrays if necessary. Mixed topology case ..? 
              reallocate = .false.
              if (allocated(n_face_mask)) reallocate = ( size(n_face_mask,2) < fe%get_num_vefs() )                                      
              if ( (.not. allocated(n_face_mask)) .or. reallocate) then
                 if (allocated(n_face_mask)) call memfree(n_face_mask, __FILE__,__LINE__); 
                 call memalloc(this%triangulation%get_num_dims(), fe%get_num_vefs(), n_face_mask, __FILE__,__LINE__);
              end if
              reallocate = .false.
              if (allocated(function_scalar_components)) reallocate = ( size(function_scalar_components,2) < fe%get_num_vefs() )                                      
              if ( (.not. allocated(function_scalar_components)) .or. reallocate) then
                 if (allocated(function_scalar_components)) deallocate(function_scalar_components, stat=istat); check(istat==0)  
                 allocate ( function_scalar_components(this%triangulation%get_num_dims(), fe%get_num_vefs()), stat=istat); check(istat==0)
              end if

              call fe%get_field_fe_dofs(field_id,fe_dofs)

              ! Loop over all vefs in to extract scalar function components over every vef 
              n_face_mask = .false.
              do vef_lid = 1, fe%get_num_vefs() 
                 call fe%get_vef(vef_lid, vef)
                 if ( .not. vef%is_ghost() ) then
                    if ( vef%get_set_id() /= 0 .and. vef%all_coarser_cells_are_void(field_id,coarser_fe) ) then
                       non_void_local_found = .false.
                       do ielem=1, vef%get_num_cells_around()
                          call vef%get_cell_around(ielem, aux_fe)
                          if ( aux_fe%is_local() .and. (.not. aux_fe%is_void(field_id))) then
                             non_void_local_found = .true.
                             exit
                          end if
                       end do

                       if ( fe%is_local() .or. .not. non_void_local_found ) then
                          ! Get scalar boundary functions 
                          call this%conditions%get_components_code( vef%get_set_id(), components_code )
                          component_id = offset_component(field_id) + 1
                          do icomp=1, reference_fe%get_num_field_components()
                             if ( components_code(component_id+icomp-1) ) then
                                n_face_mask(icomp, vef_lid) = .true. 
                                ! Retreive the scalar functions corresponding to the components of the function to be projected
                                call this%conditions%get_function(vef%get_set_id(),                 &
                                                                  component_id+icomp-1,             &
                                                                  function_scalar_components(icomp, vef_lid)%p)
                             end if
                          end do
                       end if
                    end if
                 end if
              end do

              ! Evaluate moments on the FE dirichlet boundary 
              call interpolators(field_id)%p%evaluate_function_scalar_components_moments( n_face_mask,                & 
                                                                                         fe,                         &
                                                                                         function_scalar_components, &
                                                                                         dof_values,                 &
                                                                                         time = time,                &
                                                                                         time_derivative_order = time_derivative_order)

              ! Insert nodal values on vefs at the dirichlet boundary
              do vef_lid = 1, fe%get_num_vefs() 
                 if ( any(n_face_mask(:,vef_lid)) ) then 
                    own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(vef_lid) 
                    do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() ) 
                       idof = own_dofs_on_vef_iterator%get_current()   
                       if( fe%is_strong_dirichlet_dof(fe_dofs(idof))) then
                          fixed_dof_values_entries(-fe_dofs(idof)) = dof_values(idof) 
                       end if
                       call own_dofs_on_vef_iterator%next()  
                    end do
                 end if
              end do
           end if
          call fe%next()
        end do
        if (allocated(dof_values)) call memfree( dof_values, __FILE__, __LINE__ )
     end if
  end do

  call this%free_fe_cell_iterator(fe)
  call this%free_fe_cell_iterator(aux_fe)
  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_vef_iterator(vef) 

  do field_id = 1, this%get_num_fields() 
     if ( .not. is_void_field(field_id) ) call interpolators(field_id)%p%free() 
  end do
  deallocate( interpolators, stat=istat); check(istat==0) 

  call memfree( components_code, __FILE__, __LINE__ ) 
  call memfree( offset_component, __FILE__, __LINE__ )
  call memfree( is_void_field, __FILE__, __LINE__ )
  if (allocated(function_scalar_components) ) deallocate( function_scalar_components, stat=istat); check(istat==0)
  if (allocated(n_face_mask) ) call memfree( n_face_mask, __FILE__,__LINE__)

end subroutine serial_fe_space_interpolate_dirichlet_values

subroutine serial_fe_space_project_dirichlet_values_curl_conforming (this, fe_function, time, fields_to_project)
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  class(fe_function_t)              , intent(inout) :: fe_function
  real(rp)                , optional, intent(in)    :: time
  integer(ip)             , optional, intent(in)    :: fields_to_project(:)

  !  Locals
  integer(ip)                  , allocatable :: fields_to_project_(:)  
  integer(ip)                                :: field_id, istat
  integer(ip)                                :: component_id
  integer(ip)                  , allocatable :: offset_component(:)
  integer(ip)                                :: num_components
  logical                      , allocatable :: components_code(:)
  type(serial_scalar_array_t)  , pointer     :: strong_dirichlet_values

  class(reference_fe_t)        , pointer     :: reference_fe

  class(fe_cell_iterator_t)     , allocatable :: fe
  class(fe_facet_iterator_t), allocatable :: fe_face

  type(i1p_t), allocatable :: fe_dofs(:)

  type(sparse_matrix_t)       :: matrix
  type(serial_scalar_array_t) :: rhs
  type(serial_scalar_array_t) :: projected_nodal_values
  integer(ip), allocatable    :: subset2global_dirichlet_dofs(:) 
  integer(ip), allocatable    :: global2subset_dirichlet_dofs(:) 
  integer(ip), allocatable    :: subset_fe_dofs(:) 
#ifdef ENABLE_MKL  
  type(direct_solver_t)           :: direct_solver
#else
  type(iterative_linear_solver_t) :: iterative_linear_solver
#endif
  real(rp), allocatable       :: elmat(:,:)
  real(rp), allocatable       :: elvec(:) 
  integer(ip)                 :: qpoint, n_q_points, ishape, jshape


  type(p_scalar_function_t), allocatable :: function_scalar_components(:)
  real(rp)                 , allocatable :: scalar_function_values(:,:)
  type(vector_field_t)     , allocatable :: vector_function_values(:,:)
  type(vector_field_t)     , allocatable :: shape_values(:,:)

  type(parameterlist_t)  :: parameter_list
  integer(ip)            :: FPLError
  integer                :: iparm(64)
  integer(ip)            :: ifield, jfield, idof, idof_subset, idof_global
  integer(ip)            :: num_subset_strong_dirichlet_dofs

  assert ( associated(this%conditions) )
  call memalloc ( this%get_num_components(), components_code, __FILE__, __LINE__ )

  call this%allocate_and_fill_fields_to_project_(fields_to_project_, &
                                                 fields_to_project)
  
  call this%allocate_and_fill_offset_component(offset_component)
  
  call memalloc ( this%get_max_num_shape_functions(), &
                  this%get_max_num_shape_functions(), &
                  elmat, __FILE__, __LINE__ )

  call memalloc ( this%get_max_num_shape_functions(), &
                  elvec, __FILE__, __LINE__ )

  call memalloc ( this%get_max_num_shape_functions(), subset_fe_dofs, __FILE__, __LINE__ )

  allocate ( vector_function_values(this%get_max_num_facet_quadrature_points(),1), & 
             stat=istat); check(istat==0);

  allocate ( scalar_function_values(this%get_max_num_facet_quadrature_points(),1), & 
             stat=istat); check(istat==0);

  allocate ( function_scalar_components(this%triangulation%get_num_dims()), & 
             stat=istat); check(istat==0);
  
  allocate( fe_dofs(this%get_num_fields()), stat=istat); check(istat==0);

  num_subset_strong_dirichlet_dofs = this%allocate_and_fill_global2subset_and_inverse(fields_to_project_, &
                                                                                         global2subset_dirichlet_dofs, &
                                                                                         subset2global_dirichlet_dofs)
  
  ! Create linear system 
  call matrix%create(num_rows_and_cols=num_subset_strong_dirichlet_dofs, &
                     symmetric_storage=.true.,       &
                     is_symmetric=.true.,            &
                     sign=SPARSE_MATRIX_SIGN_POSITIVE_DEFINITE )

  call rhs%create_and_allocate(num_subset_strong_dirichlet_dofs) 
  call rhs%init(0.0_rp)

  ! Create data structures
  call projected_nodal_values%create_and_allocate(num_subset_strong_dirichlet_dofs)
  call this%create_fe_facet_iterator(fe_face)
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe_face%has_finished() )
     if ( fe_face%is_at_boundary() ) then
        if ( fe_face%get_set_id() /= 0 ) then
           call fe_face%update_integration() 
           call fe_face%get_cell_around(1,fe)
           call fe%get_fe_dofs(fe_dofs)
           call this%conditions%get_components_code( fe_face%get_set_id(), components_code )

           do ifield = 1, size(fields_to_project_)    
              field_id = fields_to_project_(ifield) 
              component_id = offset_component(field_id) + 1
              if (components_code(component_id)) then
                 
                 call this%get_function_scalar_components(fe_face, &
                                                          fe, &
                                                          field_id, &
                                                          component_id, &
                                                          function_scalar_components)
                 
                 call this%evaluate_vector_function_scalar_components(fe_face, &
                                                                      fe, &
                                                                      field_id, &
                                                                      function_scalar_components, &
                                                                      scalar_function_values, &
                                                                      vector_function_values, &
                                                                      time)
                 
                 call this%project_curl_conforming_compute_elmat_elvec(fe_face, &
                                                                       fe, &
                                                                       field_id, &
                                                                       vector_function_values, &
                                                                       elmat, &
                                                                       elvec, &
                                                                       shape_values)
              
              
                 ! Consecutive DOF re-numbering for the subset of Dirichlet DOFs to be projected 
                 subset_fe_dofs = 0
                 if ( associated(fe_dofs(field_id)%p) ) then
                   do idof = 1, size(fe_dofs(field_id)%p)
                      if ( fe%is_strong_dirichlet_dof(fe_dofs(field_id)%p(idof)) ) then 
                          subset_fe_dofs(idof) = global2subset_dirichlet_dofs( -fe_dofs(field_id)%p(idof) )
                      end if
                   end do
                 end if
                 
                 reference_fe => fe%get_reference_fe(field_id)
                 call matrix%insert(num_rows = reference_fe%get_num_shape_functions(),& 
                                    num_cols = reference_fe%get_num_shape_functions(),& 
                                    ia       = subset_fe_dofs, &
                                    ja       = subset_fe_dofs, &
                                    ioffset  = 0, &
                                    joffset  = 0, & 
                                    val      = elmat)
                 call rhs%add(num_entries = reference_fe%get_num_shape_functions(),& 
                              ia          = subset_fe_dofs, &
                              ioffset     = 0, &
                              val         = elvec)
              end if
           end do
        end if
     end if
     call fe_face%next()
  end do
  call this%free_fe_facet_iterator(fe_face)
  call this%free_fe_cell_iterator(fe)
  call matrix%convert(csr_format)
      
  call parameter_list%init()
#ifdef ENABLE_MKL
  FPLError = parameter_list%set(key = dls_type_key                  ,  value = pardiso_mkl)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_matrix_type  ,  value = pardiso_mkl_spd)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_message_level,  value = 0)
  iparm = 0
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_iparm,         value = iparm)
  assert(FPLError == 0)

  call direct_solver%set_type_from_pl(parameter_list)
  call direct_solver%set_parameters_from_pl(parameter_list)
  call direct_solver%set_matrix(matrix)
  call direct_solver%numerical_setup()
  call direct_solver%solve(rhs,projected_nodal_values)
  call direct_solver%free()
#else
  FPLError = parameter_list%set(key = ils_rtol_key, value = 1.0e-12_rp)
  FPLError = FPLError + parameter_list%set(key = ils_output_frequency_key, value = 30)
  assert(FPLError == 0)
  call iterative_linear_solver%create(this%get_environment())
  call iterative_linear_solver%set_type_from_string(cg_name)
  call iterative_linear_solver%set_parameters_from_pl(parameter_list)
  call iterative_linear_solver%set_operators(matrix, .identity. matrix) 
  call iterative_linear_solver%solve(rhs,projected_nodal_values)
  call iterative_linear_solver%free()
#endif
  call parameter_list%free()

  ! Insert projected nodal values into strong_dirichlet_values array 
  strong_dirichlet_values => fe_function%get_fixed_dof_values()
  call strong_dirichlet_values%insert_subvector(iblock=1, &
                                                size_indices=num_subset_strong_dirichlet_dofs, &
                                                indices=subset2global_dirichlet_dofs,             &
                                                values=projected_nodal_values%get_entries())

  call matrix%free()
  call rhs%free()
  call projected_nodal_values%free()
  call memfree (elmat, __FILE__, __LINE__)
  call memfree (elvec, __FILE__, __LINE__)
  call memfree (offset_component, __FILE__, __LINE__ )
  deallocate ( function_scalar_components, stat=istat); check(istat==0);
  deallocate ( vector_function_values, stat=istat); check(istat==0);
  deallocate ( scalar_function_values, stat=istat); check(istat==0);
  deallocate ( shape_values, stat=istat); check(istat==0);
  call memfree ( components_code, __FILE__, __LINE__ )
  call memfree ( subset2global_dirichlet_dofs, __FILE__, __LINE__ )
  call memfree ( global2subset_dirichlet_dofs, __FILE__, __LINE__ ) 
  call memfree ( fields_to_project_, __FILE__, __LINE__ )
  call memfree ( subset_fe_dofs, __FILE__, __LINE__ )
  deallocate(fe_dofs, stat=istat ); check (istat==0)
end subroutine serial_fe_space_project_dirichlet_values_curl_conforming


subroutine serial_fe_space_allocate_and_fill_fields_to_project_ (this, &
                                                                 fields_to_project_, &
                                                                 fields_to_project)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  integer(ip), allocatable    , intent(inout) :: fields_to_project_(:)
  integer(ip), optional       , intent(in)    :: fields_to_project(:)
  
  integer(ip) :: ifield, jfield, field_id
  
  if (allocated(fields_to_project_)) call memfree(fields_to_project_,__FILE__,__LINE__)

  if ( present(fields_to_project) ) then 
     ! User specifies which fields will be projected 
     call memalloc ( size(fields_to_project), fields_to_project_, __FILE__, __LINE__ ) 
     fields_to_project_ = fields_to_project
  else  
     ! By default, all fields are projected ( i.e., 1-field case where no subset selection is needed) 
     call memalloc ( this%get_num_fields() , fields_to_project_, __FILE__, __LINE__ )  
     do field_id=1,this%get_num_fields() 
        fields_to_project_(field_id) = field_id
     end do
  end if
  
  ! fields_to_project_ consistency check (only in DEBUG mode)
#ifdef DEBUG
  do ifield = 1, size(fields_to_project_) 
    field_id = fields_to_project_(ifield)
    assert ( field_id >= 1 .and. field_id <= this%get_num_fields() )
    do jfield = ifield+1, size(fields_to_project_)
      assert ( fields_to_project_(ifield) /= fields_to_project_(jfield) )
    end do
  end do
#endif  
  
end subroutine serial_fe_space_allocate_and_fill_fields_to_project_

subroutine serial_fe_space_allocate_and_fill_offset_component(this, offset_component)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  integer(ip), allocatable    , intent(inout) :: offset_component(:)
  integer(ip) :: field_id
  class(reference_fe_t), pointer :: reference_fe
  if (allocated(offset_component)) call memfree(offset_component, __FILE__, __LINE__ )
  ! Build offset components 
  call memalloc( this%get_num_fields(), offset_component, __FILE__, __LINE__ ) 
  offset_component(1) = 0
  do field_id = 2, this%get_num_fields() 
     reference_fe                   => this%get_reference_fe(field_id-1)
     offset_component(field_id)     =  offset_component(field_id-1) + reference_fe%get_num_field_components() 
  end do
end subroutine serial_fe_space_allocate_and_fill_offset_component

! Returns the sum of those DoFs subject to strong Dirichlet boundary conditions
! associated to the fields enumerated in the fields_to_project(:) dummy argument
function serial_fe_space_allocate_and_fill_global2subset_and_inverse(this,              &
                                                                     fields_to_project, &
                                                                     global2subset,     &
                                                                     subset2global) result(num_subset_strong_dirichlet_dofs)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  integer(ip)                 , intent(in)    :: fields_to_project(:)
  integer(ip), allocatable    , intent(inout) :: global2subset(:)                 
  integer(ip), allocatable    , intent(inout) :: subset2global(:)
  integer(ip)                                 :: num_subset_strong_dirichlet_dofs

  integer(ip)              :: ifield, field_id, idof, idof_subset, idof_global
  integer(ip)              :: istat
  class(fe_cell_iterator_t), allocatable :: fe
  type(i1p_t), allocatable :: fe_dofs(:)


  if (allocated(global2subset)) call memfree(global2subset,__FILE__,__LINE__)
  if (allocated(subset2global)) call memfree(subset2global,__FILE__,__LINE__)
  
  allocate( fe_dofs(this%get_num_fields()), stat=istat); check(istat==0);
  call memalloc ( this%num_dirichlet_dofs, global2subset, __FILE__, __LINE__ ) 
  global2subset=0

  ! Count number of Dirichlet DOFs to be projected
  num_subset_strong_dirichlet_dofs = 0
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     if ( fe%is_local() ) then
        do ifield = 1, size(fields_to_project) 
           field_id = fields_to_project(ifield) 
           if ( fe%at_strong_dirichlet_boundary(field_id) ) then 
              call fe%get_fe_dofs(fe_dofs)
              if ( associated(fe_dofs(field_id)%p) ) then
                do idof = 1,size(fe_dofs(field_id)%p)
                   if ( fe%is_strong_dirichlet_dof(fe_dofs(field_id)%p(idof)) ) then 
                      if (global2subset(-fe_dofs(field_id)%p(idof))==0) then 
                         num_subset_strong_dirichlet_dofs = num_subset_strong_dirichlet_dofs + 1
                         global2subset(-fe_dofs(field_id)%p(idof)) = num_subset_strong_dirichlet_dofs 
                      end if
                   end if
                end do
              end if
           end if
        end do
     end if
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe)
  ! Allocate + compute subset2global_dirichlet_dofs from subset2global_dirichlet_dofs
  call memalloc ( num_subset_strong_dirichlet_dofs, subset2global, __FILE__, __LINE__ ) 

  idof_subset=1
  do idof_global=1, this%num_dirichlet_dofs
     if (global2subset(idof_global) /= 0) then
        subset2global(global2subset(idof_global)) = idof_global
     end if
  end do  
  deallocate(fe_dofs, stat=istat ); check (istat==0)
end function serial_fe_space_allocate_and_fill_global2subset_and_inverse

subroutine serial_fe_space_get_function_scalar_components ( this, &
                                                            fe_face, &
                                                            fe, &
                                                            field_id, &
                                                            component_id, &
                                                            function_scalar_components )
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  class(fe_facet_iterator_t)   , intent(in)    :: fe_face
  class(fe_cell_iterator_t)        , intent(inout) :: fe
  integer(ip)                 , intent(in)    :: field_id
  integer(ip)                 , intent(in)    :: component_id
  type(p_scalar_function_t)   , intent(inout) :: function_scalar_components(:)
  
  ! Locals
  integer(ip)                    :: icomp
  class(reference_fe_t), pointer :: reference_fe
  
  call fe_face%get_cell_around(1,fe)
  reference_fe => fe%get_reference_fe(field_id)
  
  assert ( reference_fe%get_num_field_components() <= size(function_scalar_components) )
  assert ( field_id >= 1 .and. field_id <= this%get_num_fields() )
  assert ( component_id >= 1 .and. component_id <= this%conditions%get_num_components() )
  
  ! Retreive the scalar functions corresponding to the components of the function to be projected
  do icomp=1, reference_fe%get_num_field_components()
       call this%conditions%get_function(fe_face%get_set_id(), &
                                         component_id+icomp-1, &
                                         function_scalar_components(icomp)%p)
  end do
end subroutine serial_fe_space_get_function_scalar_components

subroutine serial_fe_space_evaluate_vector_function_scalar_components(this, &
                                                                      fe_face, &
                                                                      fe, &
                                                                      field_id, &
                                                                      function_scalar_components, &
                                                                      scalar_function_values, &
                                                                      vector_function_values, &
                                                                      time)
  implicit none
  class(serial_fe_space_t) , intent(in)    :: this
  class(fe_facet_iterator_t), intent(inout) :: fe_face
  class(fe_cell_iterator_t)     , intent(inout) :: fe
  integer(ip)              , intent(in)    :: field_id
  type(p_scalar_function_t), intent(in)    :: function_scalar_components(:)
  real(rp)                 , intent(inout) :: scalar_function_values(:,:) ! Work-space
  type(vector_field_t)     , intent(inout) :: vector_function_values(:,:)
  real(rp), optional       , intent(in)    :: time

  ! Locals
  integer(ip)                    :: icomp
  class(reference_fe_t), pointer :: reference_fe
  type(quadrature_t)   , pointer :: quadrature
  type(point_t)        , pointer :: quad_coords(:)
                   
  real(rp)                       :: time_(1)
  integer(ip)                    :: qpoint, n_q_points
  
  call fe_face%get_cell_around(1,fe)
  reference_fe => fe%get_reference_fe(field_id)
  quad_coords  => fe_face%get_quadrature_points_coordinates()
  
  assert ( reference_fe%get_num_field_components() <= size(function_scalar_components) )
  assert ( field_id >= 1 .and. field_id <= this%get_num_fields() )
  
  if ( present(time) ) time_(1) = time
  
  quadrature   => fe_face%get_quadrature()
  n_q_points   = quadrature%get_num_quadrature_points()
  
  select case(reference_fe%get_field_type())
  case ( field_type_scalar )
     ! reference_fe MUST BE a vector-valued FE
     assert (.false.)
  case ( field_type_vector )
     do icomp=1, reference_fe%get_num_field_components()
        if(present(time)) then
           call function_scalar_components(icomp)%p%get_values_set_space_time(quad_coords,time_,scalar_function_values(1:n_q_points,:))
        else
           call function_scalar_components(icomp)%p%get_values_set_space(quad_coords,scalar_function_values(1:n_q_points,1))
        end if
        do qpoint = 1, n_q_points
           call vector_function_values(qpoint,1)%set(icomp,scalar_function_values(qpoint,1))
        end do
     end do
  case ( field_type_tensor )
     ! reference_fe MUST BE a vector-valued FE
     assert(.false.)
  end select
end subroutine serial_fe_space_evaluate_vector_function_scalar_components

!========================================================================================
subroutine serial_fe_space_project_curl_conforming_compute_elmat_elvec ( this, &
                                                                         fe_face, & 
                                                                         fe, &
                                                                         field_id, &
                                                                         vector_function_values, &
                                                                         elmat, &
                                                                         elvec, &
                                                                         shape_values)
  implicit none
  class(serial_fe_space_t) , intent(in)    :: this
  class(fe_facet_iterator_t), intent(inout) :: fe_face
  class(fe_cell_iterator_t)     , intent(inout) :: fe
  integer(ip)              , intent(in)    :: field_id
  type(vector_field_t)     , intent(in)    :: vector_function_values(:,:)
  real(rp)                 , intent(inout) :: elmat(:,:)
  real(rp)                 , intent(inout) :: elvec(:)
  type(vector_field_t), allocatable, intent(inout) :: shape_values(:,:)

  ! Locals
  class(reference_fe_t)  , pointer :: reference_fe
  type(quadrature_t)     , pointer :: quadrature
  integer(ip)                      :: qpoint, n_q_points
  integer(ip)                      :: ishape, jshape
  real(rp)                         :: factor
  type(vector_field_t) :: normals(2)
  type(vector_field_t) :: vector_shape_test, vector_shape_trial
  
  call fe_face%get_cell_around(1,fe)
  reference_fe      => fe%get_reference_fe(field_id)
  quadrature        => fe_face%get_quadrature()  
  n_q_points        = quadrature%get_num_quadrature_points()
  select case(reference_fe%get_field_type())
  case ( field_type_scalar )
     ! Curl-conforming projection does not make sense with scalar-valued fields
     assert(.false.)
  case ( field_type_vector )
     elmat = 0.0_rp
     elvec = 0.0_rp
     call fe_face%get_values(1,shape_values)
     do qpoint = 1, n_q_points
     call fe_face%get_normal(qpoint, normals)
        factor = fe_face%get_det_jacobian(qpoint) * quadrature%get_weight(qpoint)
        
        do ishape = 1, reference_fe%get_num_shape_functions() 
           do jshape = 1, reference_fe%get_num_shape_functions()
              elmat(ishape,jshape) = elmat(ishape,jshape) + cross_product(shape_values(ishape,qpoint),normals(1))*cross_product(shape_values(jshape,qpoint),normals(1))*factor
           end do
           elvec(ishape) = elvec(ishape) + cross_product(vector_function_values(qpoint,1),normals(1))*cross_product(shape_values(ishape,qpoint),normals(1))*factor
        end do
     end do
  case ( field_type_tensor )
     ! Curl-conforming projection does not make sense with tensor-valued fields
     assert(.false.)
  end select
end subroutine serial_fe_space_project_curl_conforming_compute_elmat_elvec

!========================================================================================
subroutine serial_fe_space_allocate_and_fill_reference_fes ( this, reference_fes )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  type(p_reference_fe_t)                ,  intent(in)   :: reference_fes(:)
  integer(ip) :: i, istat

  this%reference_fes_size = size(reference_fes)
  allocate( this%reference_fes(this%reference_fes_size), stat=istat )
  check ( istat == 0 )

  do i  = 1, this%reference_fes_size
     this%reference_fes(i) = reference_fes(i)
  end do
end subroutine serial_fe_space_allocate_and_fill_reference_fes

!========================================================================================
subroutine serial_fe_space_free_reference_fes ( this )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  integer(ip) :: istat, i
  this%reference_fes_size = 0
  if (allocated(this%reference_fes)) then
     deallocate( this%reference_fes, stat=istat )
     check ( istat == 0 )
  end if
  if (allocated(this%reference_fes_internally_allocated)) then
     do i=1, size(this%reference_fes_internally_allocated)
       call this%reference_fes_internally_allocated(i)%p%free()
     end do 
     deallocate( this%reference_fes_internally_allocated, stat=istat )
     check ( istat == 0 )
  end if     
end subroutine serial_fe_space_free_reference_fes

!========================================================================================
subroutine sfs_allocate_same_reference_fe_or_void_x_field ( this ) 
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  call this%free_same_reference_fe_or_void_x_field()
  call memalloc ( this%num_fields, this%same_reference_fe_or_void_x_field, __FILE__, __LINE__ )
end subroutine sfs_allocate_same_reference_fe_or_void_x_field 

!========================================================================================
subroutine serial_fe_space_free_same_reference_fe_or_void_x_field ( this ) 
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  if ( allocated(this%same_reference_fe_or_void_x_field) ) then
    call memfree ( this%same_reference_fe_or_void_x_field, __FILE__, __LINE__ )
  end if
end subroutine serial_fe_space_free_same_reference_fe_or_void_x_field

!========================================================================================
subroutine serial_fe_space_fill_same_reference_fe_or_void_x_field ( this )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  integer(ip)            , pointer     :: current_field_cell_to_ref_fes(:)
  integer(ip)                          :: ifield
  integer(ip) :: non_void_ref_fe_id, icell
  do ifield=1, this%num_fields
    current_field_cell_to_ref_fes => this%field_cell_to_ref_fes(ifield)%get_pointer()
    this%same_reference_fe_or_void_x_field (ifield) = .true.
    non_void_ref_fe_id = -1
    do icell=1, this%triangulation%get_num_cells()
       select type( ref_fe => this%reference_fes(current_field_cell_to_ref_fes(icell))%p ) 
         class is ( void_reference_fe_t ) 
         class default
          if ( non_void_ref_fe_id == -1 ) then
             non_void_ref_fe_id = current_field_cell_to_ref_fes(icell)
          else 
            if ( non_void_ref_fe_id /= current_field_cell_to_ref_fes(icell) ) then
              this%same_reference_fe_or_void_x_field (ifield) = .false.
              exit
            end if 
          end if 
       end select
    end do
  end do
end subroutine serial_fe_space_fill_same_reference_fe_or_void_x_field 

!========================================================================================
subroutine sfs_allocate_and_fill_set_ids_to_reference_fes(this, set_ids_to_reference_fes)
  implicit none
  class(serial_fe_space_t)           , intent(inout) :: this
  integer(ip)                        , intent(in)    :: set_ids_to_reference_fes(:,:)
  call this%free_set_ids_to_reference_fes()
  call memalloc ( size(set_ids_to_reference_fes,1), &
                  size(set_ids_to_reference_fes,2), &
                  this%set_ids_to_reference_fes, __FILE__, __LINE__ )
  this%set_ids_to_reference_fes = set_ids_to_reference_fes
end subroutine sfs_allocate_and_fill_set_ids_to_reference_fes

!========================================================================================
subroutine sfs_free_set_ids_to_reference_fes(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if ( allocated(this%set_ids_to_reference_fes) ) then
    call memfree ( this%set_ids_to_reference_fes, __FILE__, __LINE__ )
  end if
end subroutine sfs_free_set_ids_to_reference_fes

subroutine serial_fe_space_allocate_field_cell_to_ref_fes ( this )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  integer(ip) :: error, field_id
  if ( .not. allocated(this%field_cell_to_ref_fes) ) then
    allocate( this%field_cell_to_ref_fes(this%num_fields) , stat = error ); check( error == 0 )
    do field_id = 1,this%num_fields
      call this%field_cell_to_ref_fes(field_id)%resize(this%triangulation%get_num_cells())
    end do
  end if
end subroutine serial_fe_space_allocate_field_cell_to_ref_fes

subroutine serial_fe_space_free_field_cell_to_ref_fes ( this )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  integer(ip) :: error, field_id
  if ( allocated(this%field_cell_to_ref_fes) ) then
    do field_id = 1,this%num_fields
      call this%field_cell_to_ref_fes(field_id)%free()
    end do
    deallocate( this%field_cell_to_ref_fes, stat = error ); check( error == 0 )
  end if
end subroutine serial_fe_space_free_field_cell_to_ref_fes

subroutine serial_fe_space_fill_field_cell_to_ref_fes_same_on_all_cells ( this )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  integer(ip), pointer :: current_field_cell_to_ref_fes(:)
  integer(ip)          :: ifield
  integer(ip)          :: ife
  
  do ifield=1, this%num_fields
     current_field_cell_to_ref_fes => this%field_cell_to_ref_fes(ifield)%get_pointer()
     do ife=1, this%triangulation%get_num_cells()
        current_field_cell_to_ref_fes(ife) = ifield
     end do
  end do

end subroutine serial_fe_space_fill_field_cell_to_ref_fes_same_on_all_cells

subroutine sfes_fill_field_cell_to_ref_fes_different_ref_fes_between_cells ( this, set_ids_to_reference_fes )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip)             , intent(in)    :: set_ids_to_reference_fes(:,:)
  integer(ip)            , pointer     :: current_field_cell_to_ref_fes(:)
  integer(ip)                          :: ifield
  class(cell_iterator_t) , allocatable :: cell
  
  call this%triangulation%create_cell_iterator(cell)
  do ifield=1, this%num_fields
    call cell%first()
    current_field_cell_to_ref_fes => this%field_cell_to_ref_fes(ifield)%get_pointer()
    do while (.not. cell%has_finished())
      current_field_cell_to_ref_fes(cell%get_gid()) = set_ids_to_reference_fes(ifield,cell%get_set_id())
      call cell%next()
    end do
  end do
  call this%triangulation%free_cell_iterator(cell)

end subroutine sfes_fill_field_cell_to_ref_fes_different_ref_fes_between_cells

subroutine serial_fe_space_check_cell_vs_fe_topology_consistency(this)
  implicit none
  class(serial_fe_space_t)          , intent(in) :: this
  class(fe_cell_iterator_t), allocatable :: fe
  class(reference_fe_t), pointer :: reference_fe_unkno
  class(reference_fe_t), pointer :: reference_fe_geo
  integer(ip) :: field_id

#ifdef DEBUG
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     reference_fe_geo => fe%get_reference_fe_geo()
     do field_id = 1, fe%get_num_fields()  
        reference_fe_unkno => fe%get_reference_fe(field_id)
        assert ( reference_fe_unkno%get_topology() == reference_fe_geo%get_topology() )
     end do
     call fe%next()
  end do
  call fe%free()
#endif

end subroutine serial_fe_space_check_cell_vs_fe_topology_consistency

subroutine serial_fe_space_allocate_and_init_cell_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%cell_quadratures_degree%resize(0)
  call this%cell_quadratures_degree%resize(this%triangulation%get_num_cells(),fe_space_default_quadrature_degree_flag)
end subroutine serial_fe_space_allocate_and_init_cell_quadratures_degree 

subroutine serial_fe_space_free_cell_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%cell_quadratures_degree%free()
end subroutine serial_fe_space_free_cell_quadratures_degree

subroutine serial_fe_space_free_max_order_reference_fe_id_x_cell ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%max_order_reference_fe_id_x_cell%free()
end subroutine serial_fe_space_free_max_order_reference_fe_id_x_cell 

subroutine serial_fe_space_compute_max_order_reference_fe_id_x_cell ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_cell_iterator_t), allocatable :: fe
  integer(ip), pointer :: max_order_reference_fe_id_x_cell(:)
  integer(ip)          :: max_order, max_order_reference_fe_id_within_fe
  integer(ip)          :: field_id
  
  call this%max_order_reference_fe_id_x_cell%resize(this%triangulation%get_num_cells())
  max_order_reference_fe_id_x_cell => this%max_order_reference_fe_id_x_cell%get_pointer()
  
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     max_order = -1
     do field_id=1, this%get_num_fields()
        if ( max_order <= fe%get_max_order_single_field(field_id) ) then
           max_order = fe%get_max_order_single_field(field_id)
           max_order_reference_fe_id_within_fe = fe%get_reference_fe_id(field_id)
        end if
     end do
     max_order_reference_fe_id_x_cell(fe%get_gid()) = max_order_reference_fe_id_within_fe
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe) 
end subroutine serial_fe_space_compute_max_order_reference_fe_id_x_cell 

subroutine serial_fe_space_set_up_cell_integration ( this, interpolation_duties, cell_map_duties )
  implicit none
  class(serial_fe_space_t)      , target  , intent(inout) :: this
  type(interpolation_duties_t), optional, intent(in)    :: interpolation_duties(:)
  type(cell_map_duties_t)     , optional, intent(in)    :: cell_map_duties
  type(fe_cell_iterator_t) :: fe

  integer(ip)         :: cell_quadrature_and_map_position
  integer(ip)         :: cell_integrator_position
  
  integer(ip)         :: field_id
  integer(ip)         :: max_order, max_order_reference_fe_id_within_fe
  integer(ip)         :: cell_quadrature_and_map_key
  integer(ip)         :: cell_integrators_position_key
  integer(ip)         :: istat
  
  class(reference_fe_t), pointer :: reference_fe
  integer(ip)          , pointer :: max_order_reference_fe_id_x_cell(:)

  type(quadrature_t)     , pointer :: current_quadrature
  type(cell_map_t)       , pointer :: current_cell_map
  type(cell_integrator_t), pointer :: current_cell_integrator
  type(cell_map_duties_t)          :: current_cell_map_duties
  type(interpolation_duties_t)     :: current_interpolation_duties
  logical :: compute_first_derivatives, compute_second_derivatives

  ! We need to set to .false. this member variable as the traversal over all
  ! cells below would fail if the value of this variable is .true. This can
  ! happen, e.g. if we call this%set_up_cell_integration(...) twice in a FE
  ! program
  this%cell_integration_is_set_up = .false.

  if(.not.present(cell_map_duties)) then
     ! Select higher derivatives of all inerpolations to define the mapping
     if(present(interpolation_duties)) then
        assert(size(interpolation_duties)== this%get_num_fields())
        do field_id=1, this%get_num_fields()
           call current_interpolation_duties%assign_compute_first_derivatives( &
                & current_interpolation_duties%compute_first_derivatives_is_assigned() .or.  &
                & interpolation_duties(field_id)%compute_first_derivatives_is_assigned())
           call current_interpolation_duties%assign_compute_second_derivatives( &
                & current_interpolation_duties%compute_second_derivatives_is_assigned() .or.  &
                & interpolation_duties(field_id)%compute_second_derivatives_is_assigned())
        end do
     else ! Assign default duties (those we had before duties control)
        call current_interpolation_duties%assign_compute_first_derivatives(.true.)
        call current_interpolation_duties%assign_compute_second_derivatives(.false.)
     end if
  end if
  call this%compute_max_order_reference_fe_id_x_cell()
  max_order_reference_fe_id_x_cell => this%max_order_reference_fe_id_x_cell%get_pointer()
  
  call this%cell_quadratures_and_maps_position%init()
  call this%cell_integrators_position%init()
  call this%cell_quadratures%resize(0)
  call this%cell_maps%resize(0)
  call this%cell_integrators%resize(0)
  cell_quadrature_and_map_position = 1
  cell_integrator_position = 1

  call fe%create(this)
  do while ( .not. fe%has_finished())
   
     cell_quadrature_and_map_key = this%generate_cell_quadratures_position_key(fe%get_reference_fe_geo_id(), &
                                                                               fe%get_quadrature_degree())
     
     call this%cell_quadratures_and_maps_position%put(key = cell_quadrature_and_map_key,      &
                                                      val = cell_quadrature_and_map_position, &
                                                      stat= istat)
     if (istat == now_stored) then
        ! Create quadrature and cell_map associated to current max_order_within_fe
        max_order_reference_fe_id_within_fe = max_order_reference_fe_id_x_cell(fe%get_gid()) 
        reference_fe => this%reference_fes(max_order_reference_fe_id_within_fe)%p
        call this%cell_quadratures%resize(cell_quadrature_and_map_position)
        current_quadrature => this%cell_quadratures%get_pointer(cell_quadrature_and_map_position)
        call reference_fe%create_quadrature(current_quadrature,fe%get_quadrature_degree())
        call this%cell_maps%resize(cell_quadrature_and_map_position)
        current_cell_map => this%cell_maps%get_pointer(cell_quadrature_and_map_position)
        if(present(cell_map_duties)) then
           current_cell_map_duties = cell_map_duties
        else
           ! Checck if any field needs jacobian inverse and/or derivative
           call current_cell_map_duties%assign_compute_jacobian_inverse(.false.)
           call current_cell_map_duties%assign_compute_jacobian_derivative(.false.)
           do field_id=1, this%get_num_fields()
              reference_fe => fe%get_reference_fe(field_id)
              call reference_fe%assign_cell_map_duties(current_interpolation_duties,current_cell_map_duties)
           end do
        end if
        call current_cell_map%create(current_quadrature,fe%get_reference_fe_geo(),cell_map_duties)
        cell_quadrature_and_map_position = cell_quadrature_and_map_position + 1
     end if

     do field_id=1, this%get_num_fields()
        cell_integrators_position_key = &
             this%generate_cell_integrators_position_key(fe%get_reference_fe_geo_id(), &
                                                         fe%get_quadrature_degree(),   &
                                                         this%field_cell_to_ref_fes(field_id)%get(fe%get_gid()))
        
        call this%cell_integrators_position%put(key=cell_integrators_position_key, &
                                                val=cell_integrator_position,      &
                                                stat=istat)
        if (istat == now_stored) then 
           current_quadrature => fe%get_quadrature()
           call this%cell_integrators%resize(cell_integrator_position)
           current_cell_integrator => this%cell_integrators%get_pointer(cell_integrator_position)
           if(present(interpolation_duties)) current_interpolation_duties = interpolation_duties(field_id)
           call current_cell_integrator%create(current_quadrature,fe%get_reference_fe(field_id),current_interpolation_duties)
           cell_integrator_position = cell_integrator_position + 1
        end if
     end do
     call fe%next()
  end do
  call fe%free()
  this%cell_integration_is_set_up = .true.
end subroutine serial_fe_space_set_up_cell_integration

function serial_fe_space_cell_integration_was_set_up(this)
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  logical :: serial_fe_space_cell_integration_was_set_up
  serial_fe_space_cell_integration_was_set_up = this%cell_integration_is_set_up
end function serial_fe_space_cell_integration_was_set_up

subroutine serial_fe_space_set_cell_integration_was_set_up (this, was_set_up)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  logical                 , intent(in)    :: was_set_up
  this%cell_integration_is_set_up = was_set_up
end subroutine serial_fe_space_set_cell_integration_was_set_up

subroutine serial_fe_space_free_fe_integration ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%cell_quadratures_and_maps_position%free()
  call this%cell_integrators_position%free()
  call this%cell_quadratures%free()
  call this%cell_maps%free()
  call this%cell_integrators%free()
  call this%free_cell_quadratures_degree()
  call this%free_max_order_reference_fe_id_x_cell()
  this%cell_integration_is_set_up = .false.
end subroutine serial_fe_space_free_fe_integration


! Some comments:
!   * geo_reference_fe_id can range from 1 to this%triangulation%get_num_reference_fes_geo()
!   * quadrature_degree can range from -1 to fe_space_max_quadrature_degree
function serial_fe_space_generate_cell_quadratures_position_key ( this, geo_reference_fe_id, quadrature_degree)
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: geo_reference_fe_id
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip) :: serial_fe_space_generate_cell_quadratures_position_key
  massert ( quadrature_degree >= -1,  "serial_fe_space_generate_cell_quadratures_position_key::Invalid quadrature degree")
  massert ( geo_reference_fe_id >= 1 .and. geo_reference_fe_id <= this%triangulation%get_num_reference_fes(), "serial_fe_space_generate_cell_quadratures_position_key::Invalid geo_reference_fe_id" )
  serial_fe_space_generate_cell_quadratures_position_key = quadrature_degree * this%triangulation%get_num_reference_fes() + geo_reference_fe_id + this%triangulation%get_num_reference_fes()
end function serial_fe_space_generate_cell_quadratures_position_key

! Some comments:
!   * geo_reference_fe_id can range from 1 to this%triangulation%get_num_reference_fes_geo()
!   * quadrature_degree can range from -1 to fe_space_max_quadrature_degree
!   * reference_fe_id can range from 1 to this%reference_fes_size
function serial_fe_space_generate_cell_integrators_position_key ( this, geo_reference_fe_id, quadrature_degree, reference_fe_id )
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: geo_reference_fe_id
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip)                 , intent(in) :: reference_fe_id
  integer(ip) :: serial_fe_space_generate_cell_integrators_position_key
  massert ( reference_fe_id >= 1 .and. reference_fe_id <= this%get_num_reference_fes(), "serial_fe_space_generate_cell_integrators_position_key::Invalid reference_fe_id" )
  serial_fe_space_generate_cell_integrators_position_key =  reference_fe_id + &
       this%generate_cell_quadratures_position_key(geo_reference_fe_id,quadrature_degree) * this%get_num_reference_fes()
end function serial_fe_space_generate_cell_integrators_position_key

subroutine serial_fe_space_allocate_and_init_facet_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%facet_quadratures_degree%resize(0)
  call this%facet_quadratures_degree%resize(this%facet_gids%size(),fe_space_default_quadrature_degree_flag)
end subroutine serial_fe_space_allocate_and_init_facet_quadratures_degree 

subroutine serial_fe_space_free_facet_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%facet_quadratures_degree%free()
end subroutine serial_fe_space_free_facet_quadratures_degree

subroutine serial_fe_space_free_max_order_field_cell_to_ref_fes_face  ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%max_order_field_cell_to_ref_fes_face%free()
end subroutine serial_fe_space_free_max_order_field_cell_to_ref_fes_face  

subroutine serial_fe_space_compute_max_order_field_cell_to_ref_fes_face ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_facet_iterator_t), allocatable :: fe_face
  class(fe_cell_iterator_t)     , allocatable :: fe
  integer(ip), pointer :: max_order_field_cell_to_ref_fes_face(:)
  integer(ip)          :: max_order, max_order_reference_fe_id, reference_fe_id
  integer(ip)          :: max_order_fes_around_fe_face
  integer(ip)          :: field_id, icell_around
  integer(ip)          :: i 
  
  call this%max_order_field_cell_to_ref_fes_face%resize(this%facet_gids%size())
  max_order_field_cell_to_ref_fes_face => this%max_order_field_cell_to_ref_fes_face%get_pointer()
  
  if ( this%same_reference_fes_on_all_cells ) then
    max_order_reference_fe_id=1
    max_order = -1
    do i=1, size(this%reference_fes)
      if ( this%reference_fes(i)%p%get_max_order() > max_order ) then
        max_order = this%reference_fes(i)%p%get_max_order()
        max_order_reference_fe_id = i 
      end if
    end do
    max_order_field_cell_to_ref_fes_face = max_order_reference_fe_id
  else
    call this%create_fe_facet_iterator(fe_face)
    call this%create_fe_cell_iterator(fe)
    do while ( .not. fe_face%has_finished())
       max_order_fes_around_fe_face = -1
       max_order_reference_fe_id    =  1 
       do icell_around = 1, fe_face%get_num_cells_around()
          call fe_face%get_cell_around(icell_around, fe)
          do field_id=1, fe%get_num_fields()
             if ( max_order_fes_around_fe_face <= fe%get_max_order_single_field(field_id) ) then
                max_order_fes_around_fe_face = fe%get_max_order_single_field(field_id)
                max_order_reference_fe_id = fe%get_reference_fe_id(field_id)
             end if
          end do
       end do
       max_order_field_cell_to_ref_fes_face(fe_face%facet_gid) = max_order_reference_fe_id 
       call fe_face%next()
    end do
    call this%free_fe_facet_iterator(fe_face)
    call this%free_fe_cell_iterator(fe)
  end if 
end subroutine serial_fe_space_compute_max_order_field_cell_to_ref_fes_face  

subroutine serial_fe_space_fill_facet_gids ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  type(fe_vef_iterator_t) :: fe_vef
  call this%facet_gids%resize(0)
  call this%create_fe_vef_iterator(fe_vef)
  do while ( .not. fe_vef%has_finished() )
    if ( fe_vef%is_facet() .and. .not. fe_vef%is_ghost() .and.   &
         ( ( .not. fe_vef%is_proper() ) .or.                         &
         ( fe_vef%is_proper() .and. ( fe_vef%is_at_boundary() .or. &
           fe_vef%get_num_cells_around() > 1 ) ) ) ) then
      call this%facet_gids%push_back(fe_vef%get_gid())
    end if
    call fe_vef%next()
  end do
  call this%free_fe_vef_iterator(fe_vef)
end subroutine serial_fe_space_fill_facet_gids

subroutine serial_fe_space_free_facet_gids ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%facet_gids%free()
end subroutine serial_fe_space_free_facet_gids

subroutine serial_fe_space_compute_facet_permutation_indices ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_facet_iterator_t)       , allocatable :: fe_face
  class(fe_cell_iterator_t)            , allocatable :: first_fe
  class(fe_cell_iterator_t)            , allocatable :: second_fe
  integer(ip) :: fe_facet_permutation_index
  
  if ( this%triangulation%is_single_octree_mesh() ) then
    call this%facet_permutation_indices%resize(0)
    call this%facet_permutation_indices%resize(this%facet_gids%size(),1)
  else
    call this%facet_permutation_indices%resize(this%facet_gids%size(),-1)
    call this%create_fe_cell_iterator(first_fe)
    call this%create_fe_cell_iterator(second_fe)
    call this%create_fe_facet_iterator(fe_face)
    do while ( .not. fe_face%has_finished() )
      if ( .not. fe_face%is_ghost() .and. fe_face%get_num_cells_around() == 2 ) then
        fe_facet_permutation_index = fe_face%compute_fe_facet_permutation_index(first_fe,second_fe)
        call this%facet_permutation_indices%set(fe_face%facet_gid,fe_facet_permutation_index)
      end if
      call fe_face%next()
    end do
    call this%free_fe_facet_iterator(fe_face)
    call this%free_fe_cell_iterator(second_fe)
    call this%free_fe_cell_iterator(first_fe)
  end if 
end subroutine serial_fe_space_compute_facet_permutation_indices

subroutine serial_fe_space_free_facet_permutation_indices ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%facet_permutation_indices%free()
end subroutine serial_fe_space_free_facet_permutation_indices

subroutine serial_fe_space_set_up_facet_integration ( this )
  implicit none
  class(serial_fe_space_t), target, intent(inout) :: this
  type(fe_facet_iterator_t) :: fe_face

  integer(ip) :: facet_quadrature_position
  integer(ip) :: facet_maps_position
  integer(ip) :: facet_integrator_position

  integer(ip)            :: max_order_fes_around_fe_face
  integer(ip)            :: reference_fes_geo_id(2)
  type(p_reference_fe_t) :: reference_fes_geo(2)

  integer(ip)            :: reference_fes_id(2)
  type(p_reference_fe_t) :: reference_fes(2)

  integer(ip) :: facet_quadratures_position_key
  integer(ip) :: facet_integrators_position_key

  integer(ip) :: field_id, istat, icell_around

  class(reference_fe_t), pointer :: reference_fe
  class(reference_fe_t), pointer :: reference_fe_geo
  integer(ip)          , pointer :: max_order_field_cell_to_ref_fes_face(:)
  type(quadrature_t), pointer    :: quadrature

  type(quadrature_t)      , pointer :: current_facet_quadrature
  type(facet_maps_t)      , pointer :: current_facet_maps
  type(facet_integrator_t), pointer :: current_facet_integrator
  
  class(vef_iterator_t), allocatable :: vef
  class(triangulation_t), pointer :: triangulation
  integer(ip) :: num_cells_around
  
  ! We need to set to .false. this member variable as the traversal over all
  ! facets below would fail if the value of this variable is .true. This can
  ! happen, e.g. if we call this%set_up_facet_integration(...) twice in a FE
  ! program
  this%facet_integration_is_set_up = .false.
  
  call this%compute_facet_permutation_indices()
  call this%compute_max_order_field_cell_to_ref_fes_face()
  max_order_field_cell_to_ref_fes_face => this%max_order_field_cell_to_ref_fes_face%get_pointer()
  
  call this%facet_quadratures_position%init()
  call this%facet_integrators_position%init()
  call this%facet_quadratures%resize(0)
  call this%facet_maps%resize(0)
  call this%facet_integrators%resize(0)
  facet_quadrature_position = 1
  facet_maps_position = 1
  facet_integrator_position = 1
  
  ! Creating fe_facet_iterator_t
  triangulation => this%get_triangulation()
  call triangulation%create_vef_iterator(vef)
  call fe_face%create(this,vef)
  call triangulation%free_vef_iterator(vef)  
  do while ( .not. fe_face%has_finished() ) 
     reference_fes_geo_id(2) = 0
     nullify(reference_fes_geo(2)%p)
     num_cells_around = fe_face%get_num_cells_around()
     do icell_around = 1, num_cells_around
       reference_fes_geo_id(icell_around) =  1                  ! fe%get_reference_fe_geo_id()
       reference_fes_geo(icell_around)%p  => fe_face%ref_fe_geo ! fe%get_reference_fe_geo()
     end do

     facet_quadratures_position_key = &
          this%generate_facet_quadratures_position_key(fe_face%get_quadrature_degree(), &
                                                         reference_fes_geo_id(1), &
                                                         reference_fes_geo_id(2) )
     
     call this%facet_quadratures_position%put(key  = facet_quadratures_position_key, &
                                                val  = facet_quadrature_position, &
                                                stat = istat)  
     if (istat == now_stored) then
        reference_fe=>this%reference_fes( max_order_field_cell_to_ref_fes_face(fe_face%get_gid()) )%p
        call this%facet_quadratures%resize(facet_quadrature_position)
        current_facet_quadrature => this%facet_quadratures%get_pointer(facet_quadrature_position)
        call reference_fe%create_facet_quadrature(current_facet_quadrature,fe_face%get_quadrature_degree())
        call this%facet_maps%resize(facet_maps_position)
        current_facet_maps => this%facet_maps%get_pointer(facet_maps_position)
        quadrature => fe_face%get_quadrature()
        call current_facet_maps%create( quadrature, &
                                        reference_fes_geo(1)%p,   &
                                        reference_fes_geo(2)%p )
        facet_quadrature_position = facet_quadrature_position + 1
        facet_maps_position = facet_maps_position + 1
     end if

     do field_id=1, this%get_num_fields()
        reference_fes_id(2) = 0  
        nullify(reference_fes(2)%p)
        do icell_around = 1, num_cells_around
           reference_fes_id(icell_around) = & 
               this%field_cell_to_ref_fes(field_id)%get(fe_face%fes_around(icell_around)%p%get_gid())
           reference_fes(icell_around)%p => fe_face%fes_around(icell_around)%p%get_reference_fe(field_id)
        end do

        facet_integrators_position_key = &
             this%generate_facet_integrators_position_key(fe_face%get_quadrature_degree(), &
                                                            reference_fes_id(1), &
                                                            reference_fes_id(2) )

        call this%facet_integrators_position%put(key=facet_integrators_position_key, &
                                                   val=facet_integrator_position, &
                                                   stat=istat)
        if (istat == now_stored) then
           call this%facet_integrators%resize(facet_integrator_position)
           current_facet_integrator => this%facet_integrators%get_pointer(facet_integrator_position)
           quadrature => fe_face%get_quadrature()
           call current_facet_integrator%create(quadrature, &
                reference_fes(1)%p, &
                reference_fes(2)%p )
           facet_integrator_position = facet_integrator_position + 1
        end if
     end do
     call fe_face%next()
  end do
  call fe_face%free()
  this%facet_integration_is_set_up = .true.
end subroutine serial_fe_space_set_up_facet_integration


function serial_fe_space_get_facet_integration_is_set_up(this)
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  logical :: serial_fe_space_get_facet_integration_is_set_up
  serial_fe_space_get_facet_integration_is_set_up = this%facet_integration_is_set_up
end function serial_fe_space_get_facet_integration_is_set_up

subroutine serial_fe_space_set_facet_integration_is_set_up (this, is_set_up)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  logical                 , intent(in)    :: is_set_up
  this%facet_integration_is_set_up = is_set_up
end subroutine serial_fe_space_set_facet_integration_is_set_up


subroutine serial_fe_space_free_facet_integration ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: i, istat

  call this%facet_quadratures_position%free()
  call this%facet_integrators_position%free()

  call this%facet_quadratures%free()
  call this%facet_maps%free()
  call this%facet_integrators%free()
  
  call this%free_facet_quadratures_degree()
  call this%free_max_order_field_cell_to_ref_fes_face()
  
  call this%free_facet_permutation_indices()
  
  this%facet_integration_is_set_up = .false.
end subroutine serial_fe_space_free_facet_integration

! Provided the identifiers of the reference_fes_geo corresponding 
! to the cells around a fe_face, and the quadrature degree, computes a unique key 
! that is used to retrieve the position in the "this%facet_quadratures(:)" allocatable array through 
! the corresponding hash table. Some comments:
!    * [quadrature_degree >= -1]
!    * right_geo_reference_fe_id can range from 0 to num_reference_fes_geo 
!      (with 0 for boundary fe_faces)
!    * left_geo_reference_fe_id can range from 1 to num_reference_fes_geo
function serial_fe_space_facet_quadratures_position_key ( this, quadrature_degree, left_geo_reference_fe_id, right_geo_reference_fe_id )
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip)                 , intent(in) :: left_geo_reference_fe_id
  integer(ip)                 , intent(in) :: right_geo_reference_fe_id
  integer(ip) :: serial_fe_space_facet_quadratures_position_key
  integer(ip) :: num_reference_fes_geo

  num_reference_fes_geo = this%triangulation%get_num_reference_fes()
  serial_fe_space_facet_quadratures_position_key = left_geo_reference_fe_id + &
       (num_reference_fes_geo)*(right_geo_reference_fe_id) + &
       (num_reference_fes_geo)*(num_reference_fes_geo+1)*(quadrature_degree+1)
end function serial_fe_space_facet_quadratures_position_key

! For a given field, provided the identifiers of the reference_fes corresponding 
! to the cells around a fe_face, and the quadrature degree to be used, computes a unique key that 
! is used to retrieve the position in the "this%facet_integrators(:)" allocatable array through the corresponding 
! hash table. Some comments:
!    * [quadrature_degree >= -1]
!    * right_reference_fe_id can range from 1 to this%reference_fes_size 
!      (with 0 for boundary fe_faces)
!    * left_reference_fe_id can range from 1 to this%reference_fes_size
function serial_fe_space_facet_integrators_position_key(this, quadrature_degree, left_reference_fe_id, right_reference_fe_id)
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip)                 , intent(in) :: left_reference_fe_id
  integer(ip)                 , intent(in) :: right_reference_fe_id
  integer(ip) :: serial_fe_space_facet_integrators_position_key
  serial_fe_space_facet_integrators_position_key = left_reference_fe_id + &
       (this%reference_fes_size)*(right_reference_fe_id) + &
       (this%reference_fes_size)*(this%reference_fes_size+1)*(quadrature_degree+1)
end function serial_fe_space_facet_integrators_position_key

subroutine serial_fe_space_create_dof_values(this, dof_values)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  class(vector_t), allocatable, intent(inout) :: dof_values
  integer(ip) :: istat
  
  if (allocated(dof_values)) then
     call dof_values%free()
     deallocate(dof_values, stat=istat); check(istat==0);
  end if

  if (this%block_layout%get_num_blocks() == 1) then
     allocate ( serial_scalar_array_t  :: dof_values )
     select type(dof_values)
        class is(serial_scalar_array_t)
        call dof_values%create_and_allocate(this%block_layout%get_block_num_dofs(1))
        class default
        check(.false.)
     end select
  else
     allocate ( serial_block_array_t  :: dof_values )
     select type(dof_values)
        class is(serial_block_array_t)
        call dof_values%create_and_allocate(this%block_layout%get_num_blocks(),this%block_layout%get_num_dofs_x_block())
        class default
        check(.false.)
     end select
  end if
end subroutine serial_fe_space_create_dof_values

subroutine serial_fe_space_generate_global_dof_numbering( this )
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this
  call this%allocate_num_dofs_x_field()
  call this%allocate_num_global_dofs_x_block()
  if ( this%num_fields > 1 ) then 
    call this%count_dofs()
  end if  
  call this%list_dofs()
  call this%fill_num_global_dofs_x_block()
  call this%setup_hanging_node_constraints()
end subroutine serial_fe_space_generate_global_dof_numbering

subroutine serial_fe_space_count_dofs ( this ) 
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this  
  integer(ip), allocatable :: owner_cell_gid_x_field_and_vef(:,:)
  integer(ip), allocatable :: per_field_vef_lid_in_owner_cell (:,:)
  integer(ip), allocatable :: blocks_current_num_dofs(:)
  class(fe_cell_iterator_t), allocatable :: fe, coarser_fe
  type(fe_vef_iterator_t)  :: vef
  integer(ip) :: block_id, field_id
  integer(ip) :: ivef, vef_gid
  logical     :: no_dofs_counted_yet, fe_is_local, add_dofs
  integer(ip) :: ielem
  integer(ip) :: num_own_dofs_on_vef
  integer(ip) :: num_improper_vefs
  integer(ip) :: num_proper_vefs
  integer(ip) :: istat

  ! Count #DoFs per field
  this%num_dofs_x_field = 0

  num_proper_vefs   = this%triangulation%get_num_proper_vefs()
  num_improper_vefs = this%triangulation%get_num_improper_vefs()
  
  allocate ( owner_cell_gid_x_field_and_vef(this%get_num_fields(), &
                                            -num_improper_vefs:num_proper_vefs), &
                                            stat=istat); assert(istat==0);
  owner_cell_gid_x_field_and_vef = -1

  allocate ( per_field_vef_lid_in_owner_cell(this%get_num_fields(), &
                                             -num_improper_vefs:num_proper_vefs), &
                                             stat=istat); assert(istat==0);
  per_field_vef_lid_in_owner_cell = -1

  call this%create_fe_cell_iterator(coarser_fe)
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_vef_iterator(vef)
  do while ( .not. fe%has_finished())
     fe_is_local = fe%is_local()
     do field_id=1, this%get_num_fields()
        if (.not. fe%is_void(field_id)) then
           ! Own cell DoFs have to be only generated for local cells
           if ( fe_is_local ) then
             this%num_dofs_x_field(field_id) = this%num_dofs_x_field(field_id) + fe%count_own_dofs_cell(field_id)
           end if
           do ivef= 1, fe%get_num_vefs()
              call fe%get_vef(ivef,vef)
              if ( .not. vef%is_ghost() ) then
                 if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
                    vef_gid = vef%get_gid()

                    ! There will be (potentially) free DoFs on top of the current cell if either:
                    !  1. vef is proper
                    !  2. vef is improper, it is on a local cell, and all coarse cells are void
                    if ( vef%is_proper() .or. (fe_is_local .and. &
                         vef%all_coarser_cells_are_void(field_id,coarser_fe)) ) then
                       no_dofs_counted_yet = ( owner_cell_gid_x_field_and_vef( field_id, vef_gid ) == -1 )
                       if ( no_dofs_counted_yet ) then
                          ! If a given vef that does not have DoFs assigned yet on top of it,
                          ! we MUST not count DoFs on top of it if we first visit it from a ghost
                          ! cell
                          if ( fe_is_local ) then
                            num_own_dofs_on_vef = fe%count_own_dofs_vef(ivef,field_id)
                            this%num_dofs_x_field(field_id) = this%num_dofs_x_field(field_id) + num_own_dofs_on_vef
                            owner_cell_gid_x_field_and_vef ( field_id, vef_gid ) = fe%get_gid() 
                            per_field_vef_lid_in_owner_cell ( field_id, vef_gid ) = ivef
                          end if
                       end if
                    else
                      ! If we are sitting on an improver VEF which is on a ghost cell
                      ! we avoid entering here. It may happen that all coarser local cells are
                      ! void. In such a case we may end counting free DoFs to a ghost cell which is non-void
                      ! (in case there is any), which is obviously wrong.
                      if ( fe_is_local ) then
                         do ielem=1, vef%get_num_improper_cells_around()
                          call vef%get_improper_cell_around(ielem,coarser_fe)
                          if (.not. coarser_fe%is_void(field_id)) then
                             call count_dofs_on_proper_vefs_of_coarse_cell ( this, &
                                                         field_id, &
                                                         vef%get_improper_cell_around_ivef(ielem), &
                                                         coarser_fe,&
                                                         this%num_dofs_x_field(field_id))
                             ! Once all n-faces on the boundary of coarser_n_face (and coarser_n_face itself)
                             ! have been visited at least on a non-void FE, its not required to re-visit them
                             ! afterwards again
                             exit
                           end if
                         end do
                      end if
                    end if
                 else
                    if ( vef%is_facet() .and. vef%is_at_interface() ) then
                       call fe%generate_dofs_facet_integration_coupling ( ivef, &
                            field_id, &
                            this%num_dofs_x_field(field_id) )
                    end if
                 end if
              end if
           end do
        end if
     end do
     call fe%next()
  end do

  ! Count #DoFs per block
  call this%block_layout%clear_num_dofs_x_block()
  do field_id=1, this%get_num_fields()
    block_id = this%block_layout%get_block_id(field_id) 
    call this%block_layout%add_to_block_num_dofs(block_id,this%num_dofs_x_field(field_id))     
  end do

  this%num_total_free_ghost_dofs = 0
  ! Loop over ghost cells. No need to ask whether the current cell is ghost
  call fe%set_gid(this%triangulation%get_num_local_cells()+1)
  do while(.not. fe%has_finished())      
     do field_id = 1, this%num_fields
        if ( .not. fe%is_void(field_id)) then
           this%num_total_free_ghost_dofs = this%num_total_free_ghost_dofs + fe%count_own_dofs_cell(field_id)
           if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
              do ivef = 1, fe%get_num_vefs()
                 call fe%get_vef(ivef, vef)
                 if ( vef%is_ghost() ) then
                    ! Note that the owner_cell_gid_x_field_and_vef filters itfc VEFs 
                    ! that already have free DoFs assigned to them (because they are 
                    ! constraining a hanging DoF sitting on a local non-void FE)
                    vef_gid = vef%get_gid()
                    if ( .not. vef%all_coarser_cells_are_void(field_id,coarser_fe) ) cycle
                    no_dofs_counted_yet = ( owner_cell_gid_x_field_and_vef( field_id, vef_gid ) == -1 )                    
                    if ( no_dofs_counted_yet ) then ! proper and improper vefs
                       num_own_dofs_on_vef = fe%count_own_dofs_vef(ivef,field_id)
                       this%num_total_free_ghost_dofs = this%num_total_free_ghost_dofs + num_own_dofs_on_vef
                       owner_cell_gid_x_field_and_vef ( field_id, vef_gid ) = fe%get_gid()
                       per_field_vef_lid_in_owner_cell ( field_id, vef_gid ) = ivef
                    end if
                 end if
              end do
           end if
        end if
     end do
     call fe%next()
  end do

  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(vef)
  deallocate ( owner_cell_gid_x_field_and_vef, stat=istat); check(istat==0);
  deallocate ( per_field_vef_lid_in_owner_cell, stat=istat ); check(istat==0);

contains

! ** IMPORTANT NOTE: I could NOT pass owner_cell_gid_x_field_and_vef(:,:)
!                    and per_field_vef_lid_in_owner_cell(:,:) as assumed-shape
!                    dummy arguments. The dummy argument within the subroutine
!                    did not have the second dimension in the range -a:b, but 
!                    1:a+b+1. How can it be solved in Fortran200X?
subroutine count_dofs_on_proper_vefs_of_coarse_cell ( this, &
                                                         field_id, &
                                                         coarser_vef_lid, &
                                                         coarser_fe, &
                                                         num_dofs_current_field)
  class(serial_fe_space_t) , intent(inout) :: this
  integer(ip)              , intent(in)    :: field_id 
  integer(ip)              , intent(in)    :: coarser_vef_lid
  class(fe_cell_iterator_t), intent(inout) :: coarser_fe
  integer(ip)              , intent(inout) :: num_dofs_current_field  
  logical :: is_owner
  integer(ip) :: coarser_vef_gid
  integer(ip) :: i, spos, epos
    
  ! Count free DoFs on top of proper coarse vef
  spos = this%ptr_n_faces_n_face(coarser_vef_lid)
  epos = this%ptr_n_faces_n_face(coarser_vef_lid+1)-1
  do i=spos, epos
    coarser_vef_gid=coarser_fe%get_vef_gid(this%lst_n_faces_n_face(i))
    ! Let us check whether coarser_fe is owner of coarser_vef_gid, 
    ! and generate own DoFs identifiers on top of it if this is the case
    is_owner = ( owner_cell_gid_x_field_and_vef( field_id, coarser_vef_gid ) == -1 )
    if ( is_owner ) then
       num_own_dofs_on_vef = coarser_fe%count_own_dofs_vef(this%lst_n_faces_n_face(i),field_id)
       num_dofs_current_field = num_dofs_current_field + num_own_dofs_on_vef
       owner_cell_gid_x_field_and_vef ( field_id, coarser_vef_gid ) = coarser_fe%get_gid()
       per_field_vef_lid_in_owner_cell( field_id, coarser_vef_gid ) = this%lst_n_faces_n_face(i)
    end if
  end do 
end subroutine count_dofs_on_proper_vefs_of_coarse_cell

end subroutine serial_fe_space_count_dofs 

subroutine serial_fe_space_list_dofs ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this   

  integer(ip), allocatable :: owner_cell_gid_x_field_and_vef(:,:)
  integer(ip), allocatable :: per_field_vef_lid_in_owner_cell (:,:)
  integer(ip), allocatable :: blocks_current_num_dofs(:)
  integer(ip), allocatable :: fields_current_dof(:)
  class(fe_cell_iterator_t), allocatable :: fe, source_fe, coarser_fe
  type(fe_vef_iterator_t)  :: vef
  integer(ip) :: block_id, field_id
  integer(ip) :: ivef, jvef, vef_gid
  integer(ip) :: previous_dof_block
  integer(ip) :: current_fixed_dof, previous_fixed_dof, current_free_ghost_dof
  integer(ip) :: source_cell_id, source_vef_lid
  logical     :: no_dofs_assigned_yet, fe_is_local, add_dofs
  integer(ip) :: ielem
  integer(ip) :: ivef_in_source_fe
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  type(list_iterator_t) :: n_faces_n_face_iterator
  class(reference_fe_t), pointer :: reference_fe_geo
  integer(ip) :: coarse_vef_lid
  integer(ip) :: coarse_vef_gid
  integer(ip) :: num_improper_vefs
  integer(ip) :: num_proper_vefs
  integer(ip) :: istat

  current_fixed_dof = this%num_fixed_dofs

  num_proper_vefs   = this%triangulation%get_num_proper_vefs()
  num_improper_vefs = this%triangulation%get_num_improper_vefs()
  
  allocate ( owner_cell_gid_x_field_and_vef(this%get_num_fields(), &
                                            -num_improper_vefs:num_proper_vefs), &
                                            stat=istat); assert(istat==0);
  owner_cell_gid_x_field_and_vef = -1

  allocate ( per_field_vef_lid_in_owner_cell(this%get_num_fields(), &
                                             -num_improper_vefs:num_proper_vefs), &
                                             stat=istat); assert(istat==0);
  per_field_vef_lid_in_owner_cell = -1

  call memalloc( this%block_layout%get_num_blocks(), blocks_current_num_dofs, __FILE__, __LINE__ )
  blocks_current_num_dofs = 0

  call memalloc( this%num_fields, fields_current_dof, __FILE__, __LINE__ )
  fields_current_dof = 0

  if (this%num_fields > 1) then
     do field_id=1, this%num_fields
        block_id = this%block_layout%get_block_id(field_id)
        fields_current_dof(field_id) = fields_current_dof(field_id) + blocks_current_num_dofs(block_id)
        blocks_current_num_dofs(block_id) = blocks_current_num_dofs(block_id) + this%num_dofs_x_field(field_id)
     end do
  end if

  call this%create_fe_cell_iterator(coarser_fe)
  call this%create_fe_cell_iterator(source_fe)
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_vef_iterator(vef)
  do while ( .not. fe%has_finished())
     fe_is_local = fe%is_local()
     do field_id=1, this%get_num_fields()
        if (.not. fe%is_void(field_id)) then
           ! Own cell DoFs have to be only generated for local cells
           if ( fe_is_local ) then
              call fe%generate_own_dofs_cell ( field_id, fields_current_dof(field_id) )
           end if
           do ivef= 1, fe%get_num_vefs()
              call fe%get_vef(ivef,vef)
              if ( .not. vef%is_ghost() ) then
                 if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
                    vef_gid = vef%get_gid()

                    ! There will be (potentially) free DoFs on top of the current cell if either:
                    !  1. vef is proper
                    !  2. vef is improper, it is on a local cell, and all coarse cells are void
                    if ( vef%is_proper() .or. (fe_is_local .and. &
                         vef%all_coarser_cells_are_void(field_id,coarser_fe)) ) then
                       no_dofs_assigned_yet = ( owner_cell_gid_x_field_and_vef( field_id, vef_gid ) == -1 )
                       if ( no_dofs_assigned_yet ) then
                          ! If a given vef that does not have DoFs assigned yet on top of it,
                          ! we MUST not add DoFs on top of it if we first visit it from a ghost
                          ! cell
                          if ( fe_is_local ) then
                            previous_dof_block = fields_current_dof(field_id)
                            call fe%generate_own_dofs_vef ( ivef, &
                                                          field_id, &
                                                          fields_current_dof(field_id), &
                                                          free_dofs_loop=.true. )
                            if ( previous_dof_block < fields_current_dof(field_id) ) then 
                              owner_cell_gid_x_field_and_vef ( field_id, vef_gid ) = fe%get_gid() 
                              per_field_vef_lid_in_owner_cell ( field_id, vef_gid ) = ivef 
                            end if
                          end if 
                       else
                          source_cell_id = owner_cell_gid_x_field_and_vef(field_id, vef_gid)
                          source_vef_lid = per_field_vef_lid_in_owner_cell(field_id,vef_gid)
                          call source_fe%set_gid( source_cell_id )
                          call fe%fetch_own_dofs_vef_from_source_fe ( ivef, source_fe, source_vef_lid, field_id ) 
                       end if
                    else
                      ! If we are sitting on an improver VEF which is on a ghost cell
                      ! we avoid entering here. It may happen that all coarser local cells are
                      ! void. In such a case we may end adding free DoFs to a ghost cell which is non-void
                      ! (in case there is any), which is obviously wrong.
                      if ( fe_is_local ) then
                         do ielem=1, vef%get_num_improper_cells_around()
                          call vef%get_improper_cell_around(ielem,coarser_fe)
                          if (.not. coarser_fe%is_void(field_id)) then
                             call generate_dofs_on_proper_vefs_of_coarse_cell ( this, &
                                                         field_id, &
                                                         vef%get_improper_cell_around_ivef(ielem), &
                                                         coarser_fe, &
                                                         fields_current_dof ) 

                             ! Once all n-faces on the boundary of coarser_n_face (and coarser_n_face itself)
                             ! have been visited at least on a non-void FE, its not required to re-visit them
                             ! afterwards again
                             exit
                           end if
                         end do
                      end if  
                      assert ( .not. vef%is_proper() )
                      if ( owner_cell_gid_x_field_and_vef( field_id, vef_gid ) == -1 ) then
                          if ( fe_is_local ) then
                             add_dofs = .true.
                          else
                             add_dofs = .false.
                             do ielem=1, vef%get_num_improper_cells_around()
                                call vef%get_improper_cell_around(ielem, coarser_fe)
                                if ( coarser_fe%is_local() .and. (.not. coarser_fe%is_void(field_id)) ) then
                                   add_dofs = .true.
                                   exit
                                end if
                             end do
                          end if
                          if ( add_dofs ) then 
                             previous_fixed_dof = current_fixed_dof
                             call fe%generate_own_dofs_vef ( ivef, field_id, current_fixed_dof, free_dofs_loop=.false.)
                             if (previous_fixed_dof < current_fixed_dof) then
                               owner_cell_gid_x_field_and_vef( field_id, vef_gid ) = fe%get_gid()
                               per_field_vef_lid_in_owner_cell ( field_id, vef_gid ) = ivef 
                             end if
                          end if
                       else 
                          call source_fe%set_gid(owner_cell_gid_x_field_and_vef(field_id, vef_gid))
                          call fe%fetch_own_dofs_vef_from_source_fe ( ivef,      &
                                                                      source_fe, &
                                                                      per_field_vef_lid_in_owner_cell(field_id,vef_gid), &
                                                                      field_id ) 
                       end if
                    end if
                 else
                    if ( vef%is_facet() .and. vef%is_at_interface() ) then
                       call fe%generate_dofs_facet_integration_coupling ( ivef, &
                            field_id, &
                            this%num_dofs_x_field(field_id) )
                    end if
                 end if
              end if
           end do
        end if

        ! Ghost FEs DoF numbering generation is completed in the loop 
        ! over ghost FEs below. We avoid determining has_fixed_dofs and
        ! has_hanging_dofs as we only have partially generated
        ! DoFs on ghost DoFs at this point 
        if ( fe_is_local ) then
          call fe%determine_has_fixed_dofs(field_id)
          call fe%determine_has_hanging_dofs(field_id)
        end if 
     end do
     call fe%next()
  end do


  ! Set #DoFs per field and block in case of single-field, single-block problem
  ! (as we did not call fe_space%count_dofs() in this case)
  if ( this%num_fields == 1 ) then
     field_id = 1
     block_id = 1
     this%num_dofs_x_field(field_id) = fields_current_dof(field_id)
     call this%block_layout%set_block_num_dofs(block_id,this%num_dofs_x_field(field_id))
  end if

  this%num_hanging_dofs  = current_fixed_dof - this%num_fixed_dofs
  current_free_ghost_dof = fields_current_dof(this%num_fields)

  ! Loop over ghost cells. No need to ask whether the current cell is ghost
  call fe%set_gid(this%triangulation%get_num_local_cells()+1)
  do while(.not. fe%has_finished())      
     do field_id = 1, this%num_fields
        if ( .not. fe%is_void(field_id)) then
           call fe%generate_own_dofs_cell ( field_id, current_free_ghost_dof )
           if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
              do ivef = 1, fe%get_num_vefs()
                 call fe%get_vef(ivef, vef)
                 if ( vef%is_ghost() ) then
                    vef_gid = vef%get_gid()
                    if ( .not. vef%all_coarser_cells_are_void(field_id,coarser_fe) ) cycle
                    no_dofs_assigned_yet = ( owner_cell_gid_x_field_and_vef( field_id, vef_gid ) == -1 )                    
                    if ( no_dofs_assigned_yet ) then ! proper and improper vefs
                       previous_dof_block = current_free_ghost_dof
                       call fe%generate_own_dofs_vef ( ivef, &
                            field_id, &
                            current_free_ghost_dof, & 
                            free_dofs_loop=.true. )
                       if ( previous_dof_block < current_free_ghost_dof) then
                          owner_cell_gid_x_field_and_vef ( field_id, vef_gid ) = fe%get_gid() 
                          per_field_vef_lid_in_owner_cell ( field_id, vef_gid ) = ivef
                       end if
                    else
                       source_cell_id = owner_cell_gid_x_field_and_vef(field_id, vef_gid)
                       source_vef_lid = per_field_vef_lid_in_owner_cell(field_id,vef_gid)
                       call source_fe%set_gid( source_cell_id )
                       call fe%fetch_own_dofs_vef_from_source_fe ( ivef, source_fe, source_vef_lid, field_id ) 
                    end if
                 end if
              end do
           end if
        end if
        ! has_fixed_dofs_x_fe must also be filled on ghost FEs (as the 
        ! `at_strong_dirichlet_boundary_x_fe` array), otherwise
        ! the procedures fe_function_insert/gather_nodal_values skip inserting the
        ! fixed dof values on ghost FEs (constraining dirichlet DoFs included)
        call fe%determine_has_fixed_dofs(field_id)


        ! Although the `hanging_dofs_x_fe` array (seems to be) only (currently) used 
        ! in the local assembly procedures, we also compute it for ghost FEs for the
        ! sake of correctness
        call fe%determine_has_hanging_dofs(field_id)
     end do
     call fe%next()
  end do
  
   this%num_hanging_ghost_dofs = current_fixed_dof - this%num_fixed_dofs - this%num_hanging_dofs
   this%num_hanging_dofs       = this%num_hanging_dofs + this%num_hanging_ghost_dofs
   this%num_fixed_dofs         = current_fixed_dof
   this%num_total_free_dofs    = sum(this%num_dofs_x_field)
   if ( this%num_fields == 1 ) this%num_total_free_ghost_dofs = current_free_ghost_dof - this%num_total_free_dofs
  

  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_cell_iterator(source_fe)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(vef)
  call memfree( blocks_current_num_dofs, __FILE__, __LINE__ )
  call memfree( fields_current_dof     , __FILE__, __LINE__ )
  deallocate ( owner_cell_gid_x_field_and_vef, stat=istat); check(istat==0);
  deallocate ( per_field_vef_lid_in_owner_cell, stat=istat ); check(istat==0);
 
contains

! ** IMPORTANT NOTE: I could NOT pass owner_cell_gid_x_field_and_vef(:,:)
!                    and per_field_vef_lid_in_owner_cell(:,:) as assumed-shape
!                    dummy arguments. The dummy argument within the subroutine
!                    did not have the second dimension in the range -a:b, but 
!                    1:a+b+1. How can it be solved in Fortran200X?
subroutine generate_dofs_on_proper_vefs_of_coarse_cell ( this, &
                                                         field_id, &
                                                         coarser_vef_lid, &
                                                         coarser_fe, &
                                                         fields_current_dof )
  class(serial_fe_space_t) , intent(inout) :: this
  integer(ip)              , intent(in)    :: field_id 
  integer(ip)              , intent(in)    :: coarser_vef_lid
  class(fe_cell_iterator_t), intent(inout) :: coarser_fe
  integer(ip)              , intent(inout) :: fields_current_dof(:)
  logical :: is_owner
  integer(ip) :: previous_dof_block
  integer(ip) :: coarser_vef_gid
  integer(ip) :: i, spos, epos
    
  ! Generate free DoFs on top of proper coarse vef
  spos = this%ptr_n_faces_n_face(coarser_vef_lid)
  epos = this%ptr_n_faces_n_face(coarser_vef_lid+1)-1
  do i=spos, epos
    coarser_vef_gid=coarser_fe%get_vef_gid(this%lst_n_faces_n_face(i))
    ! Let us check whether coarser_fe is owner of coarser_vef_gid, 
    ! and generate own DoFs identifiers on top of it if this is the case
    is_owner = ( owner_cell_gid_x_field_and_vef( field_id, coarser_vef_gid ) == -1 )
    if ( is_owner ) then
       previous_dof_block = fields_current_dof(field_id)
       call coarser_fe%generate_own_dofs_vef ( this%lst_n_faces_n_face(i), &
                                               field_id, &
                                               fields_current_dof(field_id), &
                                               free_dofs_loop=.true. )
       if ( previous_dof_block < fields_current_dof(field_id) ) then
          owner_cell_gid_x_field_and_vef ( field_id, coarser_vef_gid ) = coarser_fe%get_gid() 
          per_field_vef_lid_in_owner_cell( field_id, coarser_vef_gid ) = this%lst_n_faces_n_face(i)
       end if
    end if
  end do 
  
end subroutine generate_dofs_on_proper_vefs_of_coarse_cell
  
end subroutine serial_fe_space_list_dofs 

subroutine serial_fe_space_allocate_num_dofs_x_field( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if ( .not. allocated(this%num_dofs_x_field) ) & 
     call memalloc( this%get_num_fields(), this%num_dofs_x_field, __FILE__, __LINE__ )
  assert ( size(this%num_dofs_x_field) == this%get_num_fields() )
end subroutine serial_fe_space_allocate_num_dofs_x_field

subroutine serial_fe_space_allocate_num_global_dofs_x_block( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if ( .not. allocated(this%num_global_dofs_x_block) ) & 
     call memalloc( this%block_layout%get_num_blocks(), this%num_global_dofs_x_block, __FILE__, __LINE__ )
  assert ( size(this%num_global_dofs_x_block) == this%block_layout%get_num_blocks() )
end subroutine serial_fe_space_allocate_num_global_dofs_x_block

subroutine serial_fe_space_fill_num_global_dofs_x_block ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: i
  assert ( allocated(this%num_global_dofs_x_block) )
  assert ( size(this%num_global_dofs_x_block) == this%block_layout%get_num_blocks() )
  this%num_global_dofs_x_block(:) = 0
  do i = 1, this%num_fields
     this%num_global_dofs_x_block(this%block_layout%get_block_id(i)) = this%num_global_dofs_x_block(this%block_layout%get_block_id(i)) + &
                   this%num_dofs_x_field(i) 
  end do
end subroutine serial_fe_space_fill_num_global_dofs_x_block 

subroutine serial_fe_space_renum_dofs_block (this, block_id, perm_old2new)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip)             , intent(in)    :: block_id
  integer(ip)             , intent(in)    :: perm_old2new(this%block_layout%get_block_num_dofs(block_id))
  class(fe_cell_iterator_t), allocatable :: fe
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     call fe%renum_dofs_block ( block_id, perm_old2new )
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe)
end subroutine serial_fe_space_renum_dofs_block

subroutine serial_fe_space_allocate_and_fill_gen_dof_num_scratch_data ( this) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(reference_fe_t), pointer :: ref_fe_geo
  class(reference_fe_t), pointer :: ref_fe
  type(list_t), pointer :: n_faces_n_face
  type(list_iterator_t) :: n_faces_n_face_iterator
  type(list_t), pointer :: own_dofs_n_face
  type(list_iterator_t) :: own_dofs_n_face_iterator
  integer(ip) :: num_n_faces
  integer(ip) :: current
  integer(ip) :: field_id, i 
  integer(ip) :: istat, icell
  integer(ip), pointer :: current_field_cell_to_ref_fes(:)
  
  call this%free_gen_dof_num_scratch_data()
  
  massert ( (this%triangulation%get_num_reference_fes() == 1), "FESpace does NOT support mixed cells topology. All triangulation cells MUST have the same topology." )
  
  ref_fe_geo     => this%triangulation%get_reference_fe(1)
  n_faces_n_face => ref_fe_geo%get_n_faces_n_face()
  num_n_faces    = n_faces_n_face%get_num_pointers()
  
  call memalloc ( num_n_faces+1, & 
                  this%ptr_n_faces_n_face, __FILE__, __LINE__ ) 
   
  ! We will set up ptr_n_faces_n_face/lst_n_faces_n_face s.t. 
  ! each n-face will include its interior, apart from the set
  ! of n-faces on its boundary
  this%ptr_n_faces_n_face(1) = 1
  do i=1, num_n_faces
     this%ptr_n_faces_n_face(i+1) = this%ptr_n_faces_n_face(i) + &
                                    n_faces_n_face%get_sublist_size(i)+1
  end do
   
  call memalloc ( this%ptr_n_faces_n_face(num_n_faces+1)-1, & 
                  this%lst_n_faces_n_face, __FILE__, __LINE__ ) 
   
  current=1
  do i=1, n_faces_n_face%get_num_pointers()
     this%lst_n_faces_n_face(current) = i
     current = current + 1 
     n_faces_n_face_iterator = ref_fe_geo%create_n_faces_n_face_iterator(i)
     do while( .not. n_faces_n_face_iterator%is_upper_bound() )
        this%lst_n_faces_n_face(current) = n_faces_n_face_iterator%get_current()
        current = current + 1
        call n_faces_n_face_iterator%next()
     end do
  end do
  

  allocate(this%ptr_own_dofs_n_face(this%get_num_fields()), stat=istat); check(istat==0);
  allocate(this%lst_own_dofs_n_face(this%get_num_fields()), stat=istat); check(istat==0);
  allocate(this%dofs_component(this%get_num_fields()), stat=istat); check(istat==0);
  do field_id=1, this%get_num_fields()
    if ( this%same_reference_fe_or_void_x_field(field_id) ) then
      current_field_cell_to_ref_fes => this%field_cell_to_ref_fes(field_id)%get_pointer()
      nullify(ref_fe)
      ! Find first non-void ref_fe 
      do icell=1, this%triangulation%get_num_cells()
         ref_fe => this%reference_fes(current_field_cell_to_ref_fes(icell))%p 
         select type( ref_fe ) 
           class is ( void_reference_fe_t ) 
           class default
              exit
         end select
      end do
    
      if ( associated(ref_fe) ) then
        select type (ref_fe)
        class is (void_reference_fe_t)
        class default
          own_dofs_n_face => ref_fe%get_own_dofs_n_face()
          num_n_faces = own_dofs_n_face%get_num_pointers()
          call this%ptr_own_dofs_n_face(field_id)%create(num_n_faces+1)
          this%ptr_own_dofs_n_face(field_id)%a(1) = 1
          do i=1, num_n_faces
            this%ptr_own_dofs_n_face(field_id)%a(i+1) = this%ptr_own_dofs_n_face(field_id)%a(i) + &
                                                        own_dofs_n_face%get_sublist_size(i)
          end do

          call this%lst_own_dofs_n_face(field_id)%create(& 
               this%ptr_own_dofs_n_face(field_id)%a(num_n_faces+1)-1)
   
          current=1
          do i=1, num_n_faces 
            own_dofs_n_face_iterator = own_dofs_n_face%create_iterator(i)
            do while( .not. own_dofs_n_face_iterator%is_upper_bound() )
              this%lst_own_dofs_n_face(field_id)%a(current) = own_dofs_n_face_iterator%get_current()
              current = current + 1
              call own_dofs_n_face_iterator%next()
            end do 
          end do
          
          if ( ref_fe%has_nodal_quadrature() ) then
            call this%dofs_component(field_id)%create(ref_fe%get_num_shape_functions())
            do i=1, ref_fe%get_num_shape_functions()
              this%dofs_component(field_id)%a(i) = ref_fe%get_component_node(i)
            end do
          end if  
          
        end select 
      end if
    end if
  end do
end subroutine serial_fe_space_allocate_and_fill_gen_dof_num_scratch_data

subroutine serial_fe_space_free_gen_dof_num_scratch_data(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: i, istat
  if ( allocated(this%ptr_n_faces_n_face) ) then
    call memfree(this%ptr_n_faces_n_face, __FILE__, __LINE__ )
  end if
  if ( allocated(this%lst_n_faces_n_face) ) then
    call memfree(this%lst_n_faces_n_face, __FILE__, __LINE__ )
  end if

  if ( allocated(this%ptr_own_dofs_n_face) ) then
    do i=1,size(this%ptr_own_dofs_n_face)
      call this%ptr_own_dofs_n_face(i)%free()
    end do
    deallocate(this%ptr_own_dofs_n_face, stat=istat); check(istat==0);
  end if
  
  if ( allocated(this%lst_own_dofs_n_face) ) then
    do i=1,size(this%lst_own_dofs_n_face)
      call this%lst_own_dofs_n_face(i)%free()
    end do
    deallocate(this%lst_own_dofs_n_face, stat=istat); check(istat==0);
  end if
  
  if ( allocated(this%dofs_component) ) then
    do i=1,size(this%dofs_component)
      call this%dofs_component(i)%free()
    end do
    deallocate(this%dofs_component, stat=istat); check(istat==0);
  end if
  
end subroutine serial_fe_space_free_gen_dof_num_scratch_data

function serial_fe_space_get_num_dims ( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)                          :: serial_fe_space_get_num_dims
  class(triangulation_t), pointer :: triangulation
  triangulation => this%get_triangulation()
  serial_fe_space_get_num_dims = triangulation%get_num_dims()
end function serial_fe_space_get_num_dims

function serial_fe_space_get_num_reference_fes ( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip) :: serial_fe_space_get_num_reference_fes
  serial_fe_space_get_num_reference_fes = size(this%reference_fes)
end function serial_fe_space_get_num_reference_fes

function serial_fe_space_get_reference_fe ( this, reference_fe_id )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  integer(ip)                     , intent(in) :: reference_fe_id
  class(reference_fe_t), pointer :: serial_fe_space_get_reference_fe
  assert ( reference_fe_id >=1 .and. reference_fe_id <= this%get_num_reference_fes() )
  serial_fe_space_get_reference_fe => this%reference_fes(reference_fe_id)%p
end function serial_fe_space_get_reference_fe

function serial_fe_space_get_field_type ( this, field_id )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  integer(ip)                     , intent(in) :: field_id
  character(:), pointer :: serial_fe_space_get_field_type
  serial_fe_space_get_field_type => this%reference_fes(this%set_ids_to_reference_fes(field_id,1))%p%get_field_type()
end function serial_fe_space_get_field_type

function serial_fe_space_determine_fe_space_type(this, field_id)
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)             , intent(in) :: field_id
  integer(ip)                          :: serial_fe_space_determine_fe_space_type
  class(reference_fe_t), pointer       :: reference_fe
  reference_fe => this%reference_fes(this%set_ids_to_reference_fes(field_id,1))%p
  if ( reference_fe%get_conformity() .and. reference_fe%get_continuity()  ) then
    serial_fe_space_determine_fe_space_type = fe_space_type_cg
  else if ( reference_fe%get_conformity() .and. .not. reference_fe%get_continuity() ) then
    serial_fe_space_determine_fe_space_type = fe_space_type_dg_conforming
  else 
    serial_fe_space_determine_fe_space_type = fe_space_type_dg
  end if
end function serial_fe_space_determine_fe_space_type


function serial_fe_space_get_num_components ( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip) :: serial_fe_space_get_num_components
  integer(ip) :: field_id
  serial_fe_space_get_num_components = 0
  do field_id = 1, this%get_num_fields()
     serial_fe_space_get_num_components = serial_fe_space_get_num_components + &
          this%reference_fes(this%set_ids_to_reference_fes(field_id,1))%p%get_num_field_components()
  end do
end function serial_fe_space_get_num_components

function serial_fe_space_get_max_num_shape_functions( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_num_shape_functions
  integer(ip) :: irefe
  serial_fe_space_get_max_num_shape_functions = 0
  do irefe = 1, this%reference_fes_size
     serial_fe_space_get_max_num_shape_functions = max(serial_fe_space_get_max_num_shape_functions, &
          this%reference_fes(irefe)%p%get_num_shape_functions())
  end do
end function serial_fe_space_get_max_num_shape_functions

function serial_fe_space_get_max_num_dofs_on_a_cell( this ) result (max_dofs)
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip) :: i, max_dofs
  class(fe_cell_iterator_t), allocatable :: fe
  
  ! If (same) set of reference FEs on top of all cells ...
  if ( this%same_reference_fes_on_all_cells ) then
    max_dofs = 0
    do i=1, size(this%reference_fes) 
      max_dofs = max_dofs + this%reference_fes(i)%p%get_num_shape_functions()
    end do 
  else
    max_dofs = 0
    call this%create_fe_cell_iterator(fe)
    do while (.not. fe%has_finished())
      max_dofs = max(max_dofs,fe%get_num_dofs())
      call fe%next()
    end do
    call this%free_fe_cell_iterator(fe)
   end if
end function serial_fe_space_get_max_num_dofs_on_a_cell

function serial_fe_space_get_max_num_dofs_per_field_on_a_cell( this, field_id ) result (max_dofs)
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip),              intent(in) :: field_id
  integer(ip) :: i, max_dofs
  class(fe_cell_iterator_t), allocatable :: fe
  
  assert(field_id <= this%get_num_fields())
  ! If (same) set of reference FEs on top of all cells ...
  if ( this%same_reference_fes_on_all_cells ) then 
    max_dofs = this%reference_fes(field_id)%p%get_num_shape_functions()
  else
    max_dofs = 0
    call this%create_fe_cell_iterator(fe)
    do while (.not. fe%has_finished())
      max_dofs = max(max_dofs,fe%get_num_dofs_field(field_id))
      call fe%next()
    end do
    call this%free_fe_cell_iterator(fe)
   end if
end function serial_fe_space_get_max_num_dofs_per_field_on_a_cell

function serial_fe_space_get_max_num_quadrature_points( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_num_quadrature_points
  type(quadrature_t), pointer :: cell_quadratures(:)
  integer(ip)                 :: iquad
  serial_fe_space_get_max_num_quadrature_points = 0
  cell_quadratures => this%cell_quadratures%get_pointer()
  do iquad = 1, size(cell_quadratures)
     serial_fe_space_get_max_num_quadrature_points =         &
          max(serial_fe_space_get_max_num_quadrature_points, &
          cell_quadratures(iquad)%get_num_quadrature_points())
  end do
end function serial_fe_space_get_max_num_quadrature_points

function serial_fe_space_get_max_num_nodal_quadrature_points( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_num_nodal_quadrature_points
  integer(ip) :: i
  type(quadrature_t), pointer :: nodal_quadrature

  serial_fe_space_get_max_num_nodal_quadrature_points = 0
  do i= 1, this%reference_fes_size
     if (this%reference_fes(i)%p%has_nodal_quadrature()) then
        nodal_quadrature => this%reference_fes(i)%p%get_nodal_quadrature()
        serial_fe_space_get_max_num_nodal_quadrature_points =       & 
             max(serial_fe_space_get_max_num_nodal_quadrature_points, &
             nodal_quadrature%get_num_quadrature_points())
     end if
  end do
end function serial_fe_space_get_max_num_nodal_quadrature_points

function serial_fe_space_get_max_num_facet_quadrature_points( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_num_facet_quadrature_points
  type(quadrature_t), pointer :: facet_quadratures(:)
  integer(ip)                 :: iquad
  serial_fe_space_get_max_num_facet_quadrature_points = 0
  facet_quadratures => this%facet_quadratures%get_pointer()
  do iquad = 1, size(facet_quadratures)
     serial_fe_space_get_max_num_facet_quadrature_points =       & 
          max(serial_fe_space_get_max_num_facet_quadrature_points, &
          facet_quadratures(iquad)%get_num_quadrature_points())
  end do
end function serial_fe_space_get_max_num_facet_quadrature_points

function serial_fe_space_get_num_facet_quadratures(this)
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_num_facet_quadratures
  serial_fe_space_get_num_facet_quadratures = this%facet_quadratures%size()
end function serial_fe_space_get_num_facet_quadratures

function serial_fe_space_get_max_order( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_order
  integer(ip) :: irefe
  serial_fe_space_get_max_order = 0
  do irefe = 1, this%reference_fes_size
     serial_fe_space_get_max_order = max(serial_fe_space_get_max_order, &
          this%reference_fes(irefe)%p%get_max_order())
  end do
end function serial_fe_space_get_max_order

function serial_fe_space_get_triangulation( this) result(triangulation)
  implicit none
  class(serial_fe_space_t)      , intent(in)    :: this 
  class(triangulation_t), pointer       :: triangulation
  assert ( associated(this%triangulation) )
  triangulation => this%triangulation
end function serial_fe_space_get_triangulation

subroutine serial_fe_space_set_triangulation( this, triangulation )
  implicit none
  class(serial_fe_space_t)                  , intent(inout) :: this 
  class(triangulation_t), target, intent(in)    :: triangulation
  this%triangulation => triangulation
end subroutine serial_fe_space_set_triangulation

subroutine serial_fe_space_set_environment( this, environment)
  implicit none
  class(serial_fe_space_t)                  , intent(inout) :: this 
  class(environment_t), target              , intent(in)    :: environment
  this%environment => environment
end subroutine serial_fe_space_set_environment

function serial_fe_space_get_environment(this) result(environment)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  class(environment_t), pointer:: environment 
  environment => this%environment
end function serial_fe_space_get_environment

function serial_fe_space_get_conditions( this) result(conditions)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this 
  class(conditions_t), pointer :: conditions
  assert ( associated(this%conditions) )
  conditions => this%conditions
end function serial_fe_space_get_conditions

subroutine serial_fe_space_set_conditions( this, conditions )
  implicit none
  class(serial_fe_space_t)        , intent(inout) :: this 
  class(conditions_t)     , target, intent(in)    :: conditions
  this%conditions => conditions
end subroutine serial_fe_space_set_conditions

function serial_fe_space_get_ptr_dofs_per_fe(this)
  implicit none
  class(serial_fe_space_t), target, intent(in)    :: this 
  type(std_vector_integer_ip_t), pointer :: serial_fe_space_get_ptr_dofs_per_fe(:)
  serial_fe_space_get_ptr_dofs_per_fe => this%ptr_dofs_x_fe
end function serial_fe_space_get_ptr_dofs_per_fe

function serial_fe_space_get_num_total_free_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  integer(ip) :: serial_fe_space_get_num_total_free_dofs
  serial_fe_space_get_num_total_free_dofs = this%num_total_free_dofs
end function serial_fe_space_get_num_total_free_dofs

subroutine serial_fe_space_set_num_total_free_dofs(this,num_total_free_dofs)
  implicit none
  class(serial_fe_space_t), intent(inout)    :: this 
  integer(ip), intent(in) :: num_total_free_dofs
  this%num_total_free_dofs = num_total_free_dofs
end subroutine serial_fe_space_set_num_total_free_dofs

function serial_fe_space_get_num_total_free_ghost_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  integer(ip) :: serial_fe_space_get_num_total_free_ghost_dofs
  serial_fe_space_get_num_total_free_ghost_dofs = this%num_total_free_ghost_dofs
end function serial_fe_space_get_num_total_free_ghost_dofs

subroutine serial_fe_space_set_num_total_free_ghost_dofs(this,num_ghost_dofs)
  implicit none
  class(serial_fe_space_t), intent(inout)    :: this 
  integer(ip), intent(in) :: num_ghost_dofs
  this%num_total_free_ghost_dofs = num_ghost_dofs
end subroutine serial_fe_space_set_num_total_free_ghost_dofs

function serial_fe_space_get_num_fixed_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  integer(ip) :: serial_fe_space_get_num_fixed_dofs
  serial_fe_space_get_num_fixed_dofs = this%num_fixed_dofs
end function serial_fe_space_get_num_fixed_dofs

subroutine serial_fe_space_set_num_fixed_dofs(this,num_fixed_dofs)
  implicit none
  class(serial_fe_space_t), intent(inout)    :: this 
  integer(ip), intent(in) :: num_fixed_dofs
  this%num_fixed_dofs = num_fixed_dofs
end subroutine serial_fe_space_set_num_fixed_dofs

function serial_fe_space_get_num_dirichlet_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  integer(ip) :: serial_fe_space_get_num_dirichlet_dofs
  serial_fe_space_get_num_dirichlet_dofs = this%num_dirichlet_dofs
end function serial_fe_space_get_num_dirichlet_dofs

function serial_fe_space_get_num_hanging_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  integer(ip) :: serial_fe_space_get_num_hanging_dofs
  serial_fe_space_get_num_hanging_dofs = this%num_hanging_dofs
end function serial_fe_space_get_num_hanging_dofs

subroutine serial_fe_space_set_num_hanging_dofs(this,num_hanging_dofs)
  implicit none
  class(serial_fe_space_t), intent(inout)    :: this 
  integer(ip), intent(in) :: num_hanging_dofs
  this%num_hanging_dofs = num_hanging_dofs
end subroutine serial_fe_space_set_num_hanging_dofs

function serial_fe_space_get_num_hanging_ghost_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  integer(ip) :: serial_fe_space_get_num_hanging_ghost_dofs
  serial_fe_space_get_num_hanging_ghost_dofs = this%num_hanging_ghost_dofs
end function serial_fe_space_get_num_hanging_ghost_dofs

subroutine serial_fe_space_set_num_hanging_ghost_dofs(this,num_hanging_ghost_dofs)
  implicit none
  class(serial_fe_space_t), intent(inout)    :: this 
  integer(ip), intent(in) :: num_hanging_ghost_dofs
  this%num_hanging_ghost_dofs = num_hanging_ghost_dofs
end subroutine serial_fe_space_set_num_hanging_ghost_dofs

function serial_fe_space_get_num_blocks( this)
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_num_blocks
  serial_fe_space_get_num_blocks = this%block_layout%get_num_blocks()
end function serial_fe_space_get_num_blocks

function serial_fe_space_get_field_blocks( this )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  integer(ip), pointer :: serial_fe_space_get_field_blocks(:)
  class(environment_t), pointer :: environment
  environment => this%get_environment()
  nullify(serial_fe_space_get_field_blocks)
  if ( environment%am_i_l1_task() ) then
     serial_fe_space_get_field_blocks => this%block_layout%get_field_id_to_block_id()
  end if
end function serial_fe_space_get_field_blocks

function serial_fe_space_get_field_coupling( this )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  logical, pointer :: serial_fe_space_get_field_coupling(:,:)
  class(environment_t), pointer :: environment
  environment => this%get_environment()
  nullify(serial_fe_space_get_field_coupling)
  if ( environment%am_i_l1_task() ) then
     serial_fe_space_get_field_coupling => this%block_layout%get_field_coupling()
  end if
end function serial_fe_space_get_field_coupling

! Returns the number of DoFs associated to block with identifier block_id
function serial_fe_space_get_block_num_dofs ( this, block_id )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)          , intent(in) :: block_id
  integer(ip)                       :: serial_fe_space_get_block_num_dofs
  class(environment_t), pointer  :: environment
  environment => this%get_environment()
  serial_fe_space_get_block_num_dofs = 0
  if ( environment%am_i_l1_task() ) then 
     serial_fe_space_get_block_num_dofs  = this%block_layout%get_block_num_dofs(block_id)
  end if
end function serial_fe_space_get_block_num_dofs

! Sets the number of DoFs associated to block with identifier block_id to num_dofs
subroutine serial_fe_space_set_block_num_dofs ( this, block_id, num_dofs )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip)             , intent(in)    :: block_id
  integer(ip)             , intent(in)    :: num_dofs
  class(environment_t), pointer  :: environment
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then 
     call this%block_layout%set_block_num_dofs(block_id,num_dofs)
  end if
end subroutine serial_fe_space_set_block_num_dofs

! Returns a pointer to the block_layout member variable
function serial_fe_space_get_block_layout ( this )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(block_layout_t), pointer :: serial_fe_space_get_block_layout
  serial_fe_space_get_block_layout => this%block_layout
end function serial_fe_space_get_block_layout

function serial_fe_space_get_ptr_constraining_free_dofs(this)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(std_vector_integer_ip_t), pointer :: serial_fe_space_get_ptr_constraining_free_dofs
  serial_fe_space_get_ptr_constraining_free_dofs => this%ptr_constraining_free_dofs
end function serial_fe_space_get_ptr_constraining_free_dofs

function serial_fe_space_get_ptr_constraining_dirichlet_dofs(this)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(std_vector_integer_ip_t), pointer :: serial_fe_space_get_ptr_constraining_dirichlet_dofs
  serial_fe_space_get_ptr_constraining_dirichlet_dofs => this%ptr_constraining_dirichlet_dofs
end function serial_fe_space_get_ptr_constraining_dirichlet_dofs

function serial_fe_space_get_constraining_free_dofs(this)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(std_vector_integer_ip_t), pointer :: serial_fe_space_get_constraining_free_dofs
  serial_fe_space_get_constraining_free_dofs => this%constraining_free_dofs
end function serial_fe_space_get_constraining_free_dofs

function serial_fe_space_get_constraining_free_dofs_coefficients(this)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(std_vector_real_rp_t), pointer :: serial_fe_space_get_constraining_free_dofs_coefficients
  serial_fe_space_get_constraining_free_dofs_coefficients => this%constraining_free_dofs_coefficients
end function serial_fe_space_get_constraining_free_dofs_coefficients

function serial_fe_space_get_constraining_dirichlet_dofs(this)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(std_vector_integer_ip_t), pointer :: serial_fe_space_get_constraining_dirichlet_dofs
  serial_fe_space_get_constraining_dirichlet_dofs => this%constraining_dirichlet_dofs
end function serial_fe_space_get_constraining_dirichlet_dofs

function serial_fe_space_get_constraining_dirichlet_dofs_coefficients(this)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(std_vector_real_rp_t), pointer :: serial_fe_space_get_constraining_dirichlet_dofs_coefficients
  serial_fe_space_get_constraining_dirichlet_dofs_coefficients => this%constraining_dirichlet_dofs_coefficients
end function serial_fe_space_get_constraining_dirichlet_dofs_coefficients

function serial_fe_space_get_constraints_independent_term(this)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
     type(std_vector_real_rp_t), pointer :: serial_fe_space_get_constraints_independent_term
     serial_fe_space_get_constraints_independent_term => this%constraints_independent_term
end function serial_fe_space_get_constraints_independent_term

function serial_fe_space_is_free_dof ( this, dof_lid )
  implicit none
  class(serial_fe_space_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: dof_lid
  logical :: serial_fe_space_is_free_dof
  serial_fe_space_is_free_dof = (dof_lid > 0 .and. dof_lid <= this%num_total_free_dofs)
end function serial_fe_space_is_free_dof

function serial_fe_space_is_ghost_dof ( this, dof_lid )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)             , intent(in) :: dof_lid
  logical :: serial_fe_space_is_ghost_dof
  serial_fe_space_is_ghost_dof = (dof_lid > this%num_total_free_dofs .and. (dof_lid <= (this%num_total_free_dofs + this%num_total_free_ghost_dofs)))
end function serial_fe_space_is_ghost_dof

function serial_fe_space_is_strong_dirichlet_dof ( this, dof_lid )
  implicit none
  class(serial_fe_space_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: dof_lid
  logical :: serial_fe_space_is_strong_dirichlet_dof
  serial_fe_space_is_strong_dirichlet_dof = (dof_lid < 0 .and. dof_lid >= -this%num_dirichlet_dofs )
end function serial_fe_space_is_strong_dirichlet_dof

function serial_fe_space_is_fixed_dof ( this, dof_lid )
  implicit none
  class(serial_fe_space_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: dof_lid
  logical :: serial_fe_space_is_fixed_dof
  serial_fe_space_is_fixed_dof = dof_lid < 0
end function serial_fe_space_is_fixed_dof

function serial_fe_space_is_hanging_dof ( this, dof_lid )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)              , intent(in) :: dof_lid
  logical :: serial_fe_space_is_hanging_dof
  serial_fe_space_is_hanging_dof = dof_lid < -this%num_dirichlet_dofs
end function serial_fe_space_is_hanging_dof

subroutine serial_fe_space_create_fe_cell_iterator ( this, fe, fe_cell_predicate )
  implicit none
  class(serial_fe_space_t)              , intent(in)    :: this
  class(fe_cell_iterator_t) ,allocatable, intent(inout) :: fe
  class(fe_cell_predicate_t),   optional, intent(in)    :: fe_cell_predicate
  integer(ip) :: istat
  call this%free_fe_cell_iterator(fe)
  allocate(fe_cell_iterator_t :: fe, stat=istat); check(istat==0)
  call fe%create(this,fe_cell_predicate)
end subroutine serial_fe_space_create_fe_cell_iterator

subroutine serial_fe_space_free_fe_cell_iterator ( this, fe )
  implicit none
  class(serial_fe_space_t)         , intent(in)  :: this
  class(fe_cell_iterator_t), allocatable, intent(inout) :: fe
  integer(ip) :: istat
  if(allocated(fe)) then
     call fe%free()
     deallocate(fe, stat=istat); check(istat==0)
  end if
end subroutine serial_fe_space_free_fe_cell_iterator

subroutine serial_fe_space_create_fe_vef_iterator ( this, fe_vef )
  implicit none
  class(serial_fe_space_t), target, intent(in)    :: this
  type(fe_vef_iterator_t)         , intent(inout) :: fe_vef
  class(triangulation_t), pointer :: triangulation
  class(vef_iterator_t), allocatable :: vef
  triangulation => this%get_triangulation()
  call triangulation%create_vef_iterator(vef)
  call fe_vef%free()
  call fe_vef%create(this,vef)
  call triangulation%free_vef_iterator(vef)
end subroutine serial_fe_space_create_fe_vef_iterator

subroutine serial_fe_space_create_itfc_fe_vef_iterator ( this, fe_vef )
  implicit none
  class(serial_fe_space_t), target, intent(in)    :: this
  type(fe_vef_iterator_t)         , intent(inout) :: fe_vef
  type(itfc_vef_iterator_t) :: vef
  call fe_vef%free()
  call fe_vef%create(this,vef)
end subroutine serial_fe_space_create_itfc_fe_vef_iterator

subroutine serial_fe_space_free_fe_vef_iterator ( this, fe_vef )
  implicit none
  class(serial_fe_space_t), intent(in)    :: this
  class(fe_vef_iterator_t), intent(inout) :: fe_vef
  call fe_vef%free()
end subroutine serial_fe_space_free_fe_vef_iterator

subroutine serial_fe_space_create_fe_facet_iterator ( this, fe_face )
  implicit none
  class(serial_fe_space_t) , target     , intent(in)    :: this
  class(fe_facet_iterator_t), allocatable, intent(inout) :: fe_face
  class(vef_iterator_t), allocatable :: vef
  class(triangulation_t), pointer :: triangulation
  integer(ip)          :: istat
  call this%free_fe_facet_iterator(fe_face)
  triangulation => this%get_triangulation()
  call triangulation%create_vef_iterator(vef)
  allocate(fe_facet_iterator_t :: fe_face, stat=istat); check(istat==0)
  call fe_face%create(this,vef)
  call triangulation%free_vef_iterator(vef)
end subroutine serial_fe_space_create_fe_facet_iterator

subroutine serial_fe_space_free_fe_facet_iterator ( this, fe_face )
  implicit none
  class(serial_fe_space_t)              , intent(in)    :: this
  class(fe_facet_iterator_t), allocatable, intent(inout) :: fe_face
  integer(ip) :: istat
  if (allocated(fe_face)) then
    call fe_face%free()
    deallocate(fe_face, stat=istat); check(istat==0);
  end if
end subroutine serial_fe_space_free_fe_facet_iterator

subroutine serial_fe_space_allocate_and_init_has_hanging_dofs_x_fe(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  integer(ip) :: field_id, error
  if ( .not. allocated( this%has_hanging_dofs_x_fe ) ) then
    allocate( this%has_hanging_dofs_x_fe(this%num_fields), stat = error ) ; check( error == 0 )
  end if
  do field_id = 1,this%num_fields
    call this%has_hanging_dofs_x_fe(field_id)%resize(0)
    call this%has_hanging_dofs_x_fe(field_id)%resize(this%triangulation%get_num_cells(),.false.)
  end do
end subroutine serial_fe_space_allocate_and_init_has_hanging_dofs_x_fe

subroutine serial_fe_space_free_has_hanging_dofs_x_fe(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  integer(ip) :: field_id, error
  if ( allocated(this%has_hanging_dofs_x_fe) ) then
    do field_id = 1,this%num_fields
      call this%has_hanging_dofs_x_fe(field_id)%free()
    end do
    deallocate( this%has_hanging_dofs_x_fe, stat = error ) ; check ( error == 0 )
  end if
end subroutine serial_fe_space_free_has_hanging_dofs_x_fe

subroutine serial_fe_space_free_ptr_constraining_free_dofs( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  call this%ptr_constraining_free_dofs%free()
end subroutine serial_fe_space_free_ptr_constraining_free_dofs

subroutine serial_fe_space_free_constraining_free_dofs( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  call this%constraining_free_dofs%free()  
end subroutine serial_fe_space_free_constraining_free_dofs

subroutine serial_fe_space_free_constraining_free_dofs_coefficients( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  integer(ip) :: istat, block_id
  call this%constraining_free_dofs_coefficients%free()   
end subroutine serial_fe_space_free_constraining_free_dofs_coefficients

subroutine serial_fe_space_free_ptr_constraining_dirichlet_dofs( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  call this%ptr_constraining_dirichlet_dofs%free()
end subroutine serial_fe_space_free_ptr_constraining_dirichlet_dofs

subroutine serial_fe_space_free_constraining_dirichlet_dofs( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  call this%constraining_dirichlet_dofs%free()  
end subroutine serial_fe_space_free_constraining_dirichlet_dofs

subroutine serial_fe_space_free_constraining_dirichlet_dofs_coefficients( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  integer(ip) :: istat, block_id
  call this%constraining_dirichlet_dofs_coefficients%free()   
end subroutine serial_fe_space_free_constraining_dirichlet_dofs_coefficients

subroutine serial_fe_space_free_constraints_independent_term( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  integer(ip) :: istat, block_id
  call this%constraints_independent_term%free()   
end subroutine serial_fe_space_free_constraints_independent_term

subroutine serial_fe_space_setup_hanging_node_constraints ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  class(fe_cell_iterator_t), allocatable :: fe
  class(fe_cell_iterator_t), allocatable :: coarser_fe
  type(fe_vef_iterator_t) :: fe_vef, fe_facet_touching_coarser_fe, coarser_vef
  type(list_iterator_t) :: fe_own_dofs_on_vef_iterator
  type(list_iterator_t) :: fe_dofs_on_vef_iterator 
  type(list_iterator_t) :: coarser_fe_dofs_on_vef_iterator
  integer(ip) :: improper_vef_lid
  integer(ip) :: block_id, field_id
  class(reference_fe_t), pointer :: reference_fe, coarser_reference_fe
  integer(ip), pointer :: fe_dofs(:), coarser_fe_fe_dofs(:)
  integer(ip) :: istat, i, icell, min_cell_gid
  integer(ip) :: improper_dof_lid, hanging_dof_lid
  integer(ip) :: improper_vef_ivef, coarser_fe_ivef, coarse_fe_subvef
  integer(ip) :: coarser_fe_ivef_fe_facet, coarse_fe_subvef_fe_facet
  integer(ip), pointer :: field_blocks(:)
  integer(ip) :: qpoint, ishape_fe, ishape_coarser_fe, subcell_id 
  type(interpolation_t), pointer :: h_refinement_interpolation
  integer(ip), pointer :: h_refinement_subedge_permutation(:,:,:)
  integer(ip), pointer :: h_refinement_subfacet_permutation(:,:,:)
  integer(ip), pointer :: h_refinement_subcell_permutation(:,:,:)
  real(rp) :: coefficient
  integer(ip) :: num_cell_vertices, num_cell_edges, num_cell_faces
  integer(ip) :: num_subedges_x_edge, num_subfaces_x_face
  integer(ip) :: vef_lid, facet_lid
  type(list_t), pointer :: facets_n_face
  type(list_iterator_t) :: facets_n_face_iterator
  type(list_iterator_t) :: dofs_n_facet_iterator
  integer(ip) :: facet_dof

  logical :: local_found
  
  ! Re-size to 0 to force re-initialization during second resize (to the actual/correct size)
  call this%ptr_constraining_free_dofs%resize(0)
  call this%ptr_constraining_dirichlet_dofs%resize(0)
  call this%constraining_free_dofs%resize(0)
  call this%constraining_free_dofs_coefficients%resize(0)
  call this%constraining_dirichlet_dofs%resize(0)
  call this%constraining_dirichlet_dofs_coefficients%resize(0)
  call this%constraints_independent_term%resize(0)

  call this%ptr_constraining_free_dofs%resize(this%num_hanging_dofs+1,0)
  call this%ptr_constraining_dirichlet_dofs%resize(this%num_hanging_dofs+1,0)
  call this%constraining_free_dofs%resize(this%num_hanging_dofs)
  call this%constraining_free_dofs_coefficients%resize(this%num_hanging_dofs)
  call this%constraining_dirichlet_dofs%resize(this%num_hanging_dofs)
  call this%constraining_dirichlet_dofs_coefficients%resize(this%num_hanging_dofs)
  call this%constraints_independent_term%resize(this%num_hanging_dofs)

  if ( this%num_hanging_dofs == 0 ) return
    
  field_blocks => this%get_field_blocks()
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(coarser_fe)
  call this%create_fe_vef_iterator(fe_vef)
  call this%create_fe_vef_iterator(fe_facet_touching_coarser_fe)
  call this%create_fe_vef_iterator(coarser_vef)

  reference_fe => fe%get_reference_fe(1)
  num_cell_vertices = reference_fe%get_num_vertices()
  if  (this%triangulation%get_num_dims() == 3) then
     num_cell_edges       = reference_fe%get_num_n_faces_of_dim(1)
     num_subfaces_x_face  = 4
     num_subedges_x_edge  = 2 
  else
     num_cell_edges       = 0
     num_subfaces_x_face  = 2
  end if
  num_cell_faces = reference_fe%get_num_facets()

  ! Computation of constraints     
  do improper_vef_lid = 1, this%triangulation%get_num_improper_vefs()
     call fe_vef%set_gid(-improper_vef_lid)
     
     do field_id=1, this%get_num_fields()

        ! Retrieve all data related to the current improper vef 
        ! and one of the cells that owns it
        local_found = .false.
        do icell = 1,fe_vef%get_num_cells_around()
           call fe_vef%get_cell_around(icell,fe)
           if ( fe%is_local() .and. .not. fe%is_void(field_id) ) then 
             local_found = .true.
             exit
           end if
        end do
        if ( .not. local_found ) then
          do icell = 1,fe_vef%get_num_cells_around()
            call fe_vef%get_cell_around(icell,fe)
            if ( fe%is_ghost() .and. .not. fe%is_void(field_id) ) exit
          end do
        end if
        if ( fe%is_void(field_id) ) cycle
        improper_vef_ivef = fe%get_vef_lid_from_gid(fe_vef%get_gid())
        call fe%get_field_fe_dofs(field_id,fe_dofs)

        ! Retrieve all data related to the first improper cell around current improper vef
        do icell = 1,fe_vef%get_num_improper_cells_around()
           call fe_vef%get_improper_cell_around(icell,coarser_fe)
           if ( .not. ( coarser_fe%is_void(field_id) .or. ( fe%is_ghost() .and. coarser_fe%is_ghost() ) ) ) exit
        end do
        if ( coarser_fe%is_void(field_id) .or. ( fe%is_ghost() .and. coarser_fe%is_ghost() ) ) cycle
        coarser_fe_ivef = fe_vef%get_improper_cell_around_ivef(icell)
        call coarser_fe%get_field_fe_dofs(field_id,coarser_fe_fe_dofs)

        reference_fe => fe%get_reference_fe(field_id)
        coarser_reference_fe  => coarser_fe%get_reference_fe(field_id)
        block_id = field_blocks(field_id)
        fe_own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(improper_vef_ivef)
        do while (.not. fe_own_dofs_on_vef_iterator%is_upper_bound() )
           improper_dof_lid = fe_dofs(fe_own_dofs_on_vef_iterator%get_current())
           ishape_fe = fe_own_dofs_on_vef_iterator%get_current()

           if ( fe%is_free_dof(improper_dof_lid) .or. fe%is_ghost_dof(improper_dof_lid) ) exit

           improper_dof_lid = abs(improper_dof_lid)
           hanging_dof_lid  = improper_dof_lid - this%num_dirichlet_dofs

           coarser_fe_dofs_on_vef_iterator = coarser_reference_fe%create_dofs_on_n_face_iterator(coarser_fe_ivef)
           do while (.not. coarser_fe_dofs_on_vef_iterator%is_upper_bound() )
              ishape_coarser_fe = coarser_fe_dofs_on_vef_iterator%get_current()

              if ( coarser_reference_fe%get_fe_type() == fe_type_lagrangian ) then
                if ( coarser_reference_fe%get_component_node(ishape_coarser_fe) /= reference_fe%get_component_node(ishape_fe) ) then
                  call coarser_fe_dofs_on_vef_iterator%next()
                  cycle
                end if
              end if

              if ( fe%is_strong_dirichlet_dof( coarser_fe_fe_dofs(coarser_fe_dofs_on_vef_iterator%get_current()) ) ) then
                call this%ptr_constraining_dirichlet_dofs%set(hanging_dof_lid+1, &
                     this%ptr_constraining_dirichlet_dofs%get(hanging_dof_lid+1)+1)
              else
                call this%ptr_constraining_free_dofs%set(hanging_dof_lid+1, &
                     this%ptr_constraining_free_dofs%get(hanging_dof_lid+1)+1)
              end if

              call coarser_fe_dofs_on_vef_iterator%next()
           end do
           call fe_own_dofs_on_vef_iterator%next() 
        end do
     end do
  end do


  call this%ptr_constraining_free_dofs%transform_length_to_header()
  call this%constraining_free_dofs%resize(this%ptr_constraining_free_dofs%get(this%ptr_constraining_free_dofs%size())-1)
  call this%constraining_free_dofs_coefficients%resize(this%ptr_constraining_free_dofs%get(this%ptr_constraining_free_dofs%size())-1)
  call this%ptr_constraining_dirichlet_dofs%transform_length_to_header()

  call this%constraining_dirichlet_dofs%resize(this%ptr_constraining_dirichlet_dofs%get(this%ptr_constraining_dirichlet_dofs%size())-1)
  call this%constraining_dirichlet_dofs_coefficients%resize(this%ptr_constraining_dirichlet_dofs%get(this%ptr_constraining_dirichlet_dofs%size())-1)

  ! Computation of constraints     
  do improper_vef_lid = 1, this%triangulation%get_num_improper_vefs()
     call fe_vef%set_gid(-improper_vef_lid)

     do field_id=1, this%get_num_fields()

        ! Retrieve all data related to the current improper vef 
        ! and one of the cells that owns it
        local_found = .false.
        do icell = 1,fe_vef%get_num_cells_around()
           call fe_vef%get_cell_around(icell,fe)
           if ( fe%is_local() .and. .not. fe%is_void(field_id) ) then 
             local_found = .true.
             exit
           end if
        end do
        if ( .not. local_found ) then
          do icell = 1,fe_vef%get_num_cells_around()
            call fe_vef%get_cell_around(icell,fe)
            if ( fe%is_ghost() .and. .not. fe%is_void(field_id) ) exit
          end do
        end if
        if ( fe%is_void(field_id) ) cycle
        improper_vef_ivef = fe%get_vef_lid_from_gid(fe_vef%get_gid())
        call fe%get_field_fe_dofs(field_id,fe_dofs)

        ! Retrieve all data related to the first improper cell around current improper vef
        do icell = 1,fe_vef%get_num_improper_cells_around()
           call fe_vef%get_improper_cell_around(icell,coarser_fe)
           if ( .not. ( coarser_fe%is_void(field_id) .or. ( fe%is_ghost() .and. coarser_fe%is_ghost() ) ) ) exit
        end do
        if ( coarser_fe%is_void(field_id) .or. ( fe%is_ghost() .and. coarser_fe%is_ghost() ) ) cycle
        coarser_fe_ivef  = fe_vef%get_improper_cell_around_ivef(icell)
        coarse_fe_subvef = fe_vef%get_improper_cell_around_subvef(icell)

        call coarser_fe%get_field_fe_dofs(field_id,coarser_fe_fe_dofs)
        call coarser_fe%get_vef(coarser_fe_ivef,coarser_vef)

        reference_fe => fe%get_reference_fe(field_id)
        coarser_reference_fe => coarser_fe%get_reference_fe(field_id)

        h_refinement_subedge_permutation  => coarser_reference_fe%get_h_refinement_subedge_permutation()
        h_refinement_subfacet_permutation => coarser_reference_fe%get_h_refinement_subfacet_permutation() 

        block_id = field_blocks(field_id)
        fe_own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(improper_vef_ivef)
        fe_dofs_on_vef_iterator = reference_fe%create_dofs_on_n_face_iterator(improper_vef_ivef)
        do while (.not. fe_own_dofs_on_vef_iterator%is_upper_bound() )
           ishape_fe = fe_own_dofs_on_vef_iterator%get_current()
           improper_dof_lid = fe_dofs(ishape_fe)
           assert ( fe%is_fixed_dof(improper_dof_lid) )
           improper_dof_lid = abs(improper_dof_lid)
           hanging_dof_lid  = improper_dof_lid - this%num_dirichlet_dofs

           call fe_dofs_on_vef_iterator%begin() 
           do while (.not. fe_dofs_on_vef_iterator%is_upper_bound() )
              if ( fe_dofs_on_vef_iterator%get_current() == ishape_fe ) exit
              call fe_dofs_on_vef_iterator%next() 
           end do
           assert (.not. fe_dofs_on_vef_iterator%is_upper_bound() )

              if ( fe_vef%get_dim() == 0 ) then ! vef is a corner (2D/3D)
                 if ( coarser_vef%get_dim()  == 1 .and. this%triangulation%get_num_dims() == 3) then
                    qpoint = h_refinement_subedge_permutation(coarser_fe_ivef-num_cell_vertices,num_subedges_x_edge,1)
                 else
                    qpoint = h_refinement_subfacet_permutation(coarser_fe_ivef-num_cell_vertices-num_cell_edges,num_subfaces_x_face,1)
                 end if
              else if ( fe_vef%get_dim()  == 1 .and. this%triangulation%get_num_dims() == 3 .and. coarse_fe_subvef > 0 ) then 
                 qpoint = h_refinement_subedge_permutation(coarser_fe_ivef-num_cell_vertices, &
                      coarse_fe_subvef, &
                      fe_dofs_on_vef_iterator%get_distance_to_lower_bound())
              else if ( fe_vef%get_dim()  == 1 .and. this%triangulation%get_num_dims() == 3 .and. coarse_fe_subvef < 0 ) then
                 do icell = 1,fe_vef%get_num_cells_around()
                   call fe_vef%get_cell_around(icell,fe)
                   if ( .not. fe%is_void(field_id) ) exit
                 end do
                 
                 call fe%get_field_fe_dofs(field_id,fe_dofs)

                 reference_fe  => fe%get_reference_fe(field_id)    
                 facets_n_face => reference_fe%get_facets_n_face()      

                 ! Go over faces around fe_vef in cell and find facet touching the coarser FE
                 facet_loop: do facet_lid = reference_fe%get_first_facet_id(), &
                      reference_fe%get_first_facet_id() + reference_fe%get_num_facets()-1
                    call fe_facet_touching_coarser_fe%set_gid(fe%get_vef_gid(facet_lid))
                    if (.not. fe_facet_touching_coarser_fe%is_proper()) then
                       facets_n_face_iterator = facets_n_face%create_iterator(facet_lid)
                       do while (.not. facets_n_face_iterator%is_upper_bound())
                          if (fe%get_vef_gid(facets_n_face_iterator%get_current()) == fe_vef%get_gid() ) then
                             exit facet_loop
                          end if
                          call facets_n_face_iterator%next()
                       end do
                    end if
                 end do facet_loop

                 assert(facet_lid<=reference_fe%get_first_facet_id() + reference_fe%get_num_facets()-1)

                 ! Go over DoFs on facet, and locate the facet dof LID corresponding to the edge DoF 
                 facet_dof=1
                 dofs_n_facet_iterator = reference_fe%create_dofs_n_face_iterator(facet_lid)
                 do while (.not. dofs_n_facet_iterator%is_upper_bound())
                    if (fe_dofs(dofs_n_facet_iterator%get_current()) == -improper_dof_lid) then
                       exit
                    end if
                    call dofs_n_facet_iterator%next()
                    facet_dof = facet_dof+1
                 end do
                 assert (.not. dofs_n_facet_iterator%is_upper_bound())
                 
                 coarser_fe_ivef_fe_facet = fe_facet_touching_coarser_fe%get_improper_cell_around_ivef(ife_around=1) 
                 coarse_fe_subvef_fe_facet = fe_facet_touching_coarser_fe%get_improper_cell_around_subvef(ife_around=1) 
                 ! fe_vef_bis is a facet, it only has one improper cell around
                 
                 qpoint = h_refinement_subfacet_permutation(coarser_fe_ivef_fe_facet-num_cell_vertices-num_cell_edges,&
                      coarse_fe_subvef_fe_facet,&
                      facet_dof)              
              else if (fe_vef%get_dim() == this%triangulation%get_num_dims()-1) then ! vef is a face (2D/3D)
                 qpoint = h_refinement_subfacet_permutation(coarser_fe_ivef-num_cell_vertices-num_cell_edges, &
                      coarse_fe_subvef, &
                      fe_dofs_on_vef_iterator%get_distance_to_lower_bound())
              end if

              coarser_fe_dofs_on_vef_iterator = coarser_reference_fe%create_dofs_on_n_face_iterator(coarser_fe_ivef)
           do while (.not. coarser_fe_dofs_on_vef_iterator%is_upper_bound() )
              ishape_coarser_fe = coarser_fe_dofs_on_vef_iterator%get_current() 

              ! In Lagrangian FEs the constraints are component by component (i.e., a DOF in component x will never constrain a DOF
              ! in component y or z)
              if ( coarser_reference_fe%get_fe_type() == fe_type_lagrangian ) then
                if ( coarser_reference_fe%get_component_node(ishape_coarser_fe) /= reference_fe%get_component_node(ishape_fe) ) then
                  call coarser_fe_dofs_on_vef_iterator%next()
                  cycle
                end if
              end if

              ! Evaluate coefficient
              call coarser_reference_fe%get_h_refinement_coefficient(ishape_fe,ishape_coarser_fe,qpoint,coefficient)

              ! Set dependency and coefficient into the corresponding std_vector data structure
              if ( fe%is_strong_dirichlet_dof( coarser_fe_fe_dofs(ishape_coarser_fe) ) ) then
                call this%constraining_dirichlet_dofs%set(this%ptr_constraining_dirichlet_dofs%get(hanging_dof_lid),&
                     coarser_fe_fe_dofs(ishape_coarser_fe))
                call this%constraining_dirichlet_dofs_coefficients%set(this%ptr_constraining_dirichlet_dofs%get(hanging_dof_lid),&
                     coefficient)
                call this%ptr_constraining_dirichlet_dofs%set(hanging_dof_lid, &
                     this%ptr_constraining_dirichlet_dofs%get(hanging_dof_lid)+1)
              else
                call this%constraining_free_dofs%set(this%ptr_constraining_free_dofs%get(hanging_dof_lid),&
                     coarser_fe_fe_dofs(ishape_coarser_fe))
                call this%constraining_free_dofs_coefficients%set(this%ptr_constraining_free_dofs%get(hanging_dof_lid),&
                     coefficient)
                call this%ptr_constraining_free_dofs%set(hanging_dof_lid, &
                     this%ptr_constraining_free_dofs%get(hanging_dof_lid)+1)
              end if

              call coarser_fe_dofs_on_vef_iterator%next()
           end do
           call fe_own_dofs_on_vef_iterator%next() 
        end do
     end do
  end do

  do i=this%ptr_constraining_free_dofs%size(),2,-1
     call this%ptr_constraining_free_dofs%set(i, this%ptr_constraining_free_dofs%get(i-1))
  end do
  call this%ptr_constraining_free_dofs%set(1,1)

  do i=this%ptr_constraining_dirichlet_dofs%size(),2,-1
     call this%ptr_constraining_dirichlet_dofs%set(i, this%ptr_constraining_dirichlet_dofs%get(i-1))
  end do
  call this%ptr_constraining_dirichlet_dofs%set(1,1)

  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(fe_vef)
  call this%free_fe_vef_iterator(fe_facet_touching_coarser_fe)
  call this%free_fe_vef_iterator(coarser_vef)
end subroutine serial_fe_space_setup_hanging_node_constraints

subroutine serial_fe_space_project_field_cell_to_ref_fes(this)
  implicit none
  class(serial_fe_space_t),        intent(inout) :: this
  type(std_vector_integer_ip_t), pointer     :: refinement_and_coarsening_flags
  class(fe_cell_iterator_t)    , allocatable :: new_fe
  class(reference_fe_t)        , pointer     :: reference_fe
  type(std_vector_integer_ip_t), allocatable :: old_field_cell_to_ref_fes(:)
  integer(ip)                                :: num_children_x_cell
  integer(ip)                                :: subcell_id, old_cell_lid, new_cell_lid
  integer(ip)                                :: field_id
  integer(ip)                                :: transformation_flag
  integer(ip)                                :: old_reference_fe_id
  integer(ip)                                :: old_num_local_cells, old_num_ghost_cells
  integer(ip) :: istat
   
#ifdef ENABLE_P4EST
  refinement_and_coarsening_flags => this%triangulation%get_refinement_and_coarsening_flags()  
  old_num_local_cells = this%triangulation%get_previous_num_local_cells()
  old_num_ghost_cells = this%triangulation%get_previous_num_ghost_cells()  
  
  call this%create_fe_cell_iterator(new_fe)
  reference_fe => new_fe%get_reference_fe_geo()
  num_children_x_cell = reference_fe%get_num_n_faces_of_dim(0)
  
  ! We have to resize the this%field_cell_to_ref_fes(:) corresponding to all fields
  ! at once before the next loop, because it is a precondition of fe_cell_iterator_t%set_gid()
  ! to work
  allocate(old_field_cell_to_ref_fes(this%num_fields), stat=istat); check(istat==0)
  do field_id = 1,this%num_fields
    call old_field_cell_to_ref_fes(field_id)%copy(this%field_cell_to_ref_fes(field_id))
    call this%field_cell_to_ref_fes(field_id)%resize(0)
    call this%field_cell_to_ref_fes(field_id)%resize(this%triangulation%get_num_cells(),1)
  end do   
  
  do field_id = 1,this%num_fields
    old_cell_lid = 1
    new_cell_lid = 1
    do while ( old_cell_lid .le. old_num_local_cells )
      transformation_flag = refinement_and_coarsening_flags%get(old_cell_lid)
      old_reference_fe_id  = old_field_cell_to_ref_fes(field_id)%get(old_cell_lid)
      call new_fe%set_gid(new_cell_lid)
      if ( transformation_flag == do_nothing ) then
        call new_fe%set_reference_fe_id(field_id,old_reference_fe_id)
        new_cell_lid = new_cell_lid + 1
      else if ( transformation_flag == refinement ) then
        do subcell_id = 0,num_children_x_cell-1
          call new_fe%set_reference_fe_id(field_id,old_reference_fe_id)
          new_cell_lid = new_cell_lid + 1
          call new_fe%set_gid(new_cell_lid)
        end do
      else if ( transformation_flag == coarsening ) then
        do subcell_id = 1,num_children_x_cell-1
          old_cell_lid = old_cell_lid + 1
          if ( old_reference_fe_id /= old_field_cell_to_ref_fes(field_id)%get(old_cell_lid) ) then
            massert(.false.,'Coarsened subcells do not have the same reference FE id')
          end if
        end do
        call new_fe%set_reference_fe_id(field_id,old_reference_fe_id)
        new_cell_lid = new_cell_lid + 1
      else
        massert(.false.,'Unrecognised refinement and coarsening flag')
      end if
      old_cell_lid = old_cell_lid + 1
    end do
  end do
  
  massert ( (new_cell_lid - 1) == this%triangulation%get_num_local_cells(), 'Loop in old cells failed to visit all new cells' )
  call this%free_fe_cell_iterator(new_fe)
  do field_id=1, this%num_fields
    call old_field_cell_to_ref_fes(field_id)%free()
  end do  
  deallocate(old_field_cell_to_ref_fes, stat=istat); check(istat==0)  
#else  
  call this%not_enabled_error()
#endif  
end subroutine serial_fe_space_project_field_cell_to_ref_fes

subroutine serial_fe_space_project_fe_integration_arrays(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  ! if allocated, FE integration arrays not projected
#ifdef ENABLE_P4EST  
#else  
  call this%not_enabled_error()
#endif  
end subroutine serial_fe_space_project_fe_integration_arrays

subroutine serial_fe_space_project_facet_integration_arrays(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  ! if allocated, FE face integration arrays not projected
#ifdef ENABLE_P4EST  
#else  
  call this%not_enabled_error()
#endif  
end subroutine serial_fe_space_project_facet_integration_arrays

subroutine serial_fe_space_compute_new_fe_function_values( this, old_ptr_dofs_x_fe, old_lst_dofs_gids, fe_function )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  type(std_vector_integer_ip_t)     , intent(in)    :: old_ptr_dofs_x_fe(:)
  type(std_vector_integer_ip_t)     , intent(in)    :: old_lst_dofs_gids  
  type(fe_function_t)               , intent(in)    :: fe_function
  
  type(std_vector_integer_ip_t)     , pointer     :: refinement_and_coarsening_flags
  class(fe_cell_iterator_t)         , allocatable :: new_fe
  class(reference_fe_t)             , pointer     :: reference_fe
  type(environment_t)               , pointer     :: environment  
  type(cell_import_t)               , pointer     :: cell_import
  real(rp)                          , allocatable :: old_nodal_values(:,:)
  real(rp)                          , pointer     :: p_new_fe_function_nodal_values(:)  
  integer(ip)                       , pointer     :: old_field_fe_dofs(:)
  integer(ip)                                     :: num_children_x_cell
  integer(ip)                                     :: transformation_flag
  integer(ip)                                     :: subcell_id, old_cell_lid, new_cell_lid
  integer(ip)                                     :: current_old_cell_lid, current_new_cell_lid
  integer(ip)                                     :: old_num_local_cells
  integer(ip)                                     :: old_num_ghost_cells  
  integer(ip)                                     :: field_id
  integer(ip)                                     :: num_nodes_field
  integer(ip)                                     :: spos, epos

#ifdef ENABLE_P4EST
  environment => this%triangulation%get_environment()
  if ( environment%am_i_l1_task() ) then  
        refinement_and_coarsening_flags => this%triangulation%get_refinement_and_coarsening_flags()  
        if ( this%triangulation%get_num_cells() > 0 ) then
           old_num_local_cells = this%triangulation%get_previous_num_local_cells()
           old_num_ghost_cells = this%triangulation%get_previous_num_ghost_cells()        

           p_new_fe_function_nodal_values => this%new_fe_function_nodal_values%get_pointer()

           call this%create_fe_cell_iterator(new_fe)
           reference_fe => new_fe%get_reference_fe_geo()
           num_children_x_cell = reference_fe%get_num_n_faces_of_dim(0)
           call memalloc(num_children_x_cell, &
                this%get_max_num_shape_functions(),old_nodal_values,__FILE__,__LINE__)
           old_cell_lid = 1
           new_cell_lid = 1
           do while ( old_cell_lid .le. old_num_local_cells )
              transformation_flag = refinement_and_coarsening_flags%get(old_cell_lid)
              do field_id = 1,this%get_num_fields()
                 call new_fe%set_gid(new_cell_lid) 
                 current_old_cell_lid = old_cell_lid
                 current_new_cell_lid = new_cell_lid
                 reference_fe => new_fe%get_reference_fe(field_id) ! Only h-adaptivity
                 num_nodes_field = reference_fe%get_num_shape_functions()
                 old_field_fe_dofs => this%get_field_fe_dofs(field_id,current_old_cell_lid,old_ptr_dofs_x_fe,old_lst_dofs_gids)
                 call fe_function%gather_nodal_values( field_id, & 
                      old_field_fe_dofs, &
                      num_nodes_field, & 
                      this%get_field_blocks(), &
                      old_nodal_values(1,1:num_nodes_field) )

                 if ( transformation_flag == do_nothing ) then
                    call this%get_new_lst_dofs_spos_epos(field_id,current_new_cell_lid,spos,epos)
                    p_new_fe_function_nodal_values(spos:epos) = old_nodal_values(1,1:num_nodes_field)
                    current_new_cell_lid = current_new_cell_lid + 1
                 else if ( transformation_flag == refinement ) then
                    do subcell_id = 0,num_children_x_cell-1
                       call this%get_new_lst_dofs_spos_epos(field_id,current_new_cell_lid,spos,epos)
                       if ( .not. new_fe%is_void(field_id) ) then 
                         call reference_fe%interpolate_nodal_values_on_subcell( subcell_id,                            & 
                                                                                old_nodal_values(1,1:num_nodes_field), &
                                                                                p_new_fe_function_nodal_values(spos:epos) )
                       end if
                       current_new_cell_lid = current_new_cell_lid + 1
                       call new_fe%set_gid(current_new_cell_lid)
                    end do
                 else if ( transformation_flag == coarsening ) then
                    do subcell_id = 1,num_children_x_cell-1
                       current_old_cell_lid = current_old_cell_lid + 1
                       old_field_fe_dofs => this%get_field_fe_dofs(field_id,current_old_cell_lid,old_ptr_dofs_x_fe,old_lst_dofs_gids)
                       call fe_function%gather_nodal_values( field_id, & 
                            old_field_fe_dofs, &
                            num_nodes_field, & 
                            this%get_field_blocks(), &
                            old_nodal_values(subcell_id+1,1:num_nodes_field) )
                    end do
                    call this%get_new_lst_dofs_spos_epos(field_id,current_new_cell_lid,spos,epos)
                    if ( .not. new_fe%is_void(field_id) ) then 
                      call reference_fe%project_nodal_values_on_cell( old_nodal_values(:,1:num_nodes_field), &
                                                                      p_new_fe_function_nodal_values(spos:epos))
                    end if
                    current_new_cell_lid = current_new_cell_lid + 1
                 else
                    massert(.false.,'Unrecognised refinement and coarsening flag')
                 end if
              end do
              old_cell_lid = current_old_cell_lid
              new_cell_lid = current_new_cell_lid
              old_cell_lid = old_cell_lid + 1
           end do
           massert ( new_cell_lid - 1 == this%triangulation%get_num_local_cells(), 'Loop in old cells failed to visit all new cells' )
           call this%free_fe_cell_iterator(new_fe)
           call memfree(old_nodal_values,__FILE__,__LINE__)
        end if
  end if 
#else  
  call this%not_enabled_error()
#endif    
end subroutine serial_fe_space_compute_new_fe_function_values

subroutine serial_fe_space_insert_new_fe_function_nodal_values( this, fe_function )
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this
  type(fe_function_t)         , intent(inout) :: fe_function
  class(fe_cell_iterator_t)   , allocatable :: new_fe
  type(environment_t), pointer :: environment
  integer(ip)                  :: field_id, current_new_cell_lid, spos, epos
  real(rp),            pointer :: p_new_fe_function_nodal_values(:)
#ifdef ENABLE_P4EST  
  environment => this%triangulation%get_environment()
  if ( environment%am_i_l1_task() ) then
    p_new_fe_function_nodal_values => this%new_fe_function_nodal_values%get_pointer()      
    call fe_function%create(this)
    call this%create_fe_cell_iterator(new_fe)    
    call new_fe%first()
    do while ( .not. new_fe%has_finished() )
       current_new_cell_lid = new_fe%get_gid() 
       do field_id=1, this%num_fields 
          call this%get_new_lst_dofs_spos_epos(field_id,current_new_cell_lid,spos,epos)
          call fe_function%insert_nodal_values( new_fe,   &
                                                field_id, &
                                                p_new_fe_function_nodal_values(spos:epos))
       end do
       call new_fe%next()
    end do
    call this%update_hanging_dof_values(fe_function)
    call this%free_fe_cell_iterator(new_fe)
  end if
#else  
  call this%not_enabled_error()
#endif   
end subroutine serial_fe_space_insert_new_fe_function_nodal_values

subroutine serial_fe_space_refine_and_coarsen_single_fe_function( this, fe_function )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  type(fe_function_t)     , optional, intent(inout) :: fe_function
  type(std_vector_integer_ip_t)     , allocatable :: old_ptr_dofs_x_fe(:)
  type(std_vector_integer_ip_t)                   :: old_lst_dofs_gids
  integer(ip)                                     :: field_id
  integer(ip)                                     :: error
  type(environment_t), pointer                    :: environment
#ifdef ENABLE_P4EST
  environment => this%triangulation%get_environment()
  if ( environment%am_i_l1_task() ) then
     if ( present(fe_function) ) then
        call this%update_after_refine_coarsen(old_ptr_dofs_x_fe,old_lst_dofs_gids)
        call this%new_fe_function_nodal_values%resize(0)
        call this%new_fe_function_nodal_values%resize(this%ptr_dofs_x_fe(1)%get(this%triangulation%get_num_cells()+1)-1)
        call this%compute_new_fe_function_values(old_ptr_dofs_x_fe,old_lst_dofs_gids,fe_function)
        call this%comm_new_fe_function_nodal_values()
        call this%insert_new_fe_function_nodal_values(fe_function)
        do field_id = 1,this%num_fields
           call old_ptr_dofs_x_fe(field_id)%free()
        end do
        deallocate( old_ptr_dofs_x_fe, stat = error ); check( error == 0 )
        call old_lst_dofs_gids%free()  
     else
        call this%update_after_refine_coarsen()
     end if
  end if
#else  
  call this%not_enabled_error()
#endif    
end subroutine serial_fe_space_refine_and_coarsen_single_fe_function

subroutine serial_fe_space_comm_new_fe_function_nodal_values(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
end subroutine serial_fe_space_comm_new_fe_function_nodal_values

subroutine serial_fe_space_refine_and_coarsen_fe_function_array( this, fe_functions )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  type(p_fe_function_t)   , intent(inout) :: fe_functions(:)
  type(std_vector_integer_ip_t)     , allocatable :: old_ptr_dofs_x_fe(:)
  type(std_vector_integer_ip_t)                   :: old_lst_dofs_gids
  integer(ip)                                     :: field_id
  integer(ip)                                     :: ifunc
  integer(ip)                                     :: error  
  type(environment_t), pointer :: environment
#ifdef ENABLE_P4EST
  environment => this%triangulation%get_environment()
  if ( environment%am_i_l1_task() ) then
     call this%update_after_refine_coarsen(old_ptr_dofs_x_fe,old_lst_dofs_gids)
     call this%new_fe_function_nodal_values%resize(0)
     call this%new_fe_function_nodal_values%resize(this%ptr_dofs_x_fe(1)%get(this%triangulation%get_num_cells()+1)-1)
     do ifunc = 1,size(fe_functions)
       call this%compute_new_fe_function_values(old_ptr_dofs_x_fe,old_lst_dofs_gids,fe_functions(ifunc)%p)
       call this%comm_new_fe_function_nodal_values()
       call this%insert_new_fe_function_nodal_values(fe_functions(ifunc)%p)
     end do
     do field_id = 1,this%num_fields
        call old_ptr_dofs_x_fe(field_id)%free()
     end do
     deallocate( old_ptr_dofs_x_fe, stat = error ); check( error == 0 )
     call old_lst_dofs_gids%free()  
  end if
#else  
  call this%not_enabled_error()
#endif
end subroutine serial_fe_space_refine_and_coarsen_fe_function_array

subroutine serial_fe_space_update_after_refine_coarsen(this, old_ptr_dofs_x_fe, old_lst_dofs_gids)
  implicit none
  class(serial_fe_space_t)                            , intent(inout) :: this
  type(std_vector_integer_ip_t), allocatable, optional, intent(inout) :: old_ptr_dofs_x_fe(:)
  type(std_vector_integer_ip_t)             , optional, intent(inout) :: old_lst_dofs_gids
  type(environment_t), pointer :: environment
  integer(ip) :: field_id
  type(block_layout_t), pointer :: block_layout
#ifdef DEBUG
  if ( present(old_ptr_dofs_x_fe) .or. present(old_lst_dofs_gids) ) then
    assert ( present(old_lst_dofs_gids) ) 
    assert ( present(old_ptr_dofs_x_fe) )
  end if 
#endif
  
#ifdef ENABLE_P4EST  
  environment   => this%triangulation%get_environment()
  if ( environment%am_i_l1_task() ) then
     if ( present (old_ptr_dofs_x_fe) ) then 
       call this%copy_ptr_lst_dofs(old_ptr_dofs_x_fe,old_lst_dofs_gids)
     end if
     call this%project_field_cell_to_ref_fes()
     call this%fill_facet_gids()
     call this%project_fe_integration_arrays()
     call this%project_facet_integration_arrays()
     call this%allocate_and_init_ptr_lst_dofs_gids()
     call this%allocate_and_init_at_strong_dirichlet_bound()
     call this%allocate_and_init_has_fixed_dofs()
     call this%allocate_and_init_has_hanging_dofs_x_fe()
     call this%fill_same_reference_fe_or_void_x_field()
     call this%allocate_and_fill_gen_dof_num_scratch_data()
     call this%set_up_strong_dirichlet_bcs()
     ! Force that a new DoF numbering is generated for the refined/coarsened triangulation
     call this%generate_global_dof_numbering()
  end if
#else  
  call this%not_enabled_error()
#endif
end subroutine serial_fe_space_update_after_refine_coarsen

subroutine serial_fe_space_update_hanging_dof_values (this, fe_function )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  class(fe_function_t)    , intent(inout) :: fe_function
  
  type(serial_scalar_array_t), pointer :: fixed_dof_values
  real(rp)                   , pointer :: fixed_dof_values_entries(:)
  
  integer(ip) :: i_gid, spos, epos, pos, k_gid
  real(rp) :: weight, free_dof_value(1)
  
  fixed_dof_values         => fe_function%get_fixed_dof_values()
  fixed_dof_values_entries => fixed_dof_values%get_entries()
  fixed_dof_values_entries(this%num_dirichlet_dofs+1:this%num_fixed_dofs) = 0.0_rp
  
  ! Here, we only compute hanging DoF values for those hanging DoFs X s.t.
  ! the DoFs on which X depends are at least on one local cell (btw,
  ! the number of such DoFs is this%num_hanging_dofs-this%num_hanging_ghost_dofs).
  ! This MUST BE as it is because we did not yet gather DoF values on ghost cells
  ! from remote processors
  do i_gid = 1, this%num_hanging_dofs-this%num_hanging_ghost_dofs
    spos = this%ptr_constraining_free_dofs%get(i_gid)
    epos = this%ptr_constraining_free_dofs%get(i_gid+1)-1
    do pos=spos, epos 
      k_gid = this%constraining_free_dofs%get(pos)
      weight = this%constraining_free_dofs_coefficients%get(pos)
         call fe_function%free_dof_values%extract_subvector ( iblock = 1, &
                                             size_indices = 1, &
                                             indices = [k_gid], &
                                             values = free_dof_value )
      fixed_dof_values_entries(i_gid+this%num_dirichlet_dofs) = &
         & fixed_dof_values_entries(i_gid+this%num_dirichlet_dofs) +  &
         & weight*free_dof_value(1)
    end do
    spos = this%ptr_constraining_dirichlet_dofs%get(i_gid)
    epos = this%ptr_constraining_dirichlet_dofs%get(i_gid+1)-1
    do pos=spos, epos 
      k_gid = this%constraining_dirichlet_dofs%get(pos)
      weight = this%constraining_dirichlet_dofs_coefficients%get(pos)
      fixed_dof_values_entries(i_gid+this%num_dirichlet_dofs) = &
         & fixed_dof_values_entries(i_gid+this%num_dirichlet_dofs) + &
         & weight*fixed_dof_values_entries(abs(k_gid))
    end do
  end do
end subroutine serial_fe_space_update_hanging_dof_values 

subroutine serial_fe_space_update_ghost_dof_values (this, fe_function )
  implicit none
  class(serial_fe_space_t), intent(in)    :: this
  class(fe_function_t)    , intent(inout) :: fe_function
end subroutine serial_fe_space_update_ghost_dof_values 



function serial_fe_space_update_get_field_offset_component (this, field_id )
  implicit none
  class(serial_fe_space_t), intent(in)    :: this
  class(reference_fe_t), pointer :: reference_fe
  integer(ip)    , intent(in)  :: field_id
  integer(ip) :: serial_fe_space_update_get_field_offset_component
  integer(ip) :: i
  serial_fe_space_update_get_field_offset_component = 1
  do i = 1, field_id-1
     reference_fe => this%get_reference_fe(i)
     serial_fe_space_update_get_field_offset_component = serial_fe_space_update_get_field_offset_component &
                                                         + reference_fe%get_num_field_components()
  end do
end function serial_fe_space_update_get_field_offset_component 

#ifndef ENABLE_P4EST
  subroutine serial_fe_space_not_enabled_error(this)
    class(serial_fe_space_t), intent(in) :: this
    write (stderr,*) 'Error: FEMPAR was not compiled with -DENABLE_P4EST.'
    write (stderr,*) "Error: You must activate this CPP macro in order to use P4EST"
    check(.false.)
  end subroutine serial_fe_space_not_enabled_error
#endif

! Auxiliar procedures
  function serial_fe_space_get_field_fe_dofs(this,field_id,current_old_cell_lid,old_ptr_dofs_x_fe,old_lst_dofs_gids)
    implicit none
    class(serial_fe_space_t),          intent(in) :: this    
    integer(ip),                       intent(in) :: field_id
    integer(ip),                       intent(in) :: current_old_cell_lid
    type(std_vector_integer_ip_t),     intent(in) :: old_ptr_dofs_x_fe(:)
    type(std_vector_integer_ip_t),     intent(in) :: old_lst_dofs_gids
    integer(ip), pointer     :: serial_fe_space_get_field_fe_dofs(:)
    integer(ip)              :: spos, epos
    spos = old_ptr_dofs_x_fe(field_id)%get(current_old_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      epos = old_ptr_dofs_x_fe(1)%get(current_old_cell_lid+1)-1
    else
      epos = old_ptr_dofs_x_fe(field_id+1)%get(current_old_cell_lid)-1
    end if
    serial_fe_space_get_field_fe_dofs => old_lst_dofs_gids%get_pointer(spos,epos)
  end function serial_fe_space_get_field_fe_dofs
  
  function serial_fe_space_get_new_num_dofs(this, field_id, current_new_cell_lid, old_ptr_dofs_x_fe)
    implicit none
    class(serial_fe_space_t),          intent(in) :: this    
    integer(ip),                       intent(in) :: field_id
    integer(ip),                       intent(in) :: current_new_cell_lid
    type(std_vector_integer_ip_t),     intent(in) :: old_ptr_dofs_x_fe(:)
    integer(ip) :: serial_fe_space_get_new_num_dofs
    integer(ip) :: spos, epos
    spos = this%ptr_dofs_x_fe(field_id)%get(current_new_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      if ( this%ptr_dofs_x_fe(1)%size() > 1 ) then 
        epos = this%ptr_dofs_x_fe(1)%get(current_new_cell_lid+1)-1
      else 
        epos = old_ptr_dofs_x_fe(1)%get(current_new_cell_lid+1)-1
      end if 
    else
      if ( this%ptr_dofs_x_fe(field_id+1)%size() > 1 ) then
        epos = this%ptr_dofs_x_fe(field_id+1)%get(current_new_cell_lid)-1
      else 
        epos = old_ptr_dofs_x_fe(field_id+1)%get(current_new_cell_lid)-1
      end if 
    end if
    serial_fe_space_get_new_num_dofs = epos-spos+1
  end function serial_fe_space_get_new_num_dofs
  
  subroutine serial_fe_space_get_old_lst_dofs_spos_epos(this, field_id, current_old_cell_lid, old_ptr_dofs_x_fe, spos, epos)
    implicit none
    class(serial_fe_space_t),          intent(in) :: this    
    integer(ip),                       intent(in) :: field_id
    integer(ip),                       intent(in) :: current_old_cell_lid
    type(std_vector_integer_ip_t),     intent(in) :: old_ptr_dofs_x_fe(:)
    integer(ip),                    intent(inout) :: spos, epos
    spos = old_ptr_dofs_x_fe(field_id)%get(current_old_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      epos = old_ptr_dofs_x_fe(1)%get(current_old_cell_lid+1)-1
    else
      epos = old_ptr_dofs_x_fe(field_id+1)%get(current_old_cell_lid)-1
    end if
  end subroutine serial_fe_space_get_old_lst_dofs_spos_epos  
  
  subroutine serial_fe_space_get_new_lst_dofs_spos_epos(this, field_id, current_new_cell_lid, spos, epos)
    implicit none
    class(serial_fe_space_t),          intent(in) :: this    
    integer(ip),                       intent(in) :: field_id
    integer(ip),                       intent(in) :: current_new_cell_lid
    integer(ip),                    intent(inout) :: spos, epos
    spos = this%ptr_dofs_x_fe(field_id)%get(current_new_cell_lid)
    if ( field_id == this%get_num_fields() ) then
      epos = this%ptr_dofs_x_fe(1)%get(current_new_cell_lid+1)-1
    else
      epos = this%ptr_dofs_x_fe(field_id+1)%get(current_new_cell_lid)-1
    end if
  end subroutine serial_fe_space_get_new_lst_dofs_spos_epos 
